   1              		.syntax unified
   2              		.cpu cortex-m4
   3              		.eabi_attribute 27, 3
   4              		.fpu fpv4-sp-d16
   5              		.eabi_attribute 20, 1
   6              		.eabi_attribute 21, 1
   7              		.eabi_attribute 23, 3
   8              		.eabi_attribute 24, 1
   9              		.eabi_attribute 25, 1
  10              		.eabi_attribute 26, 1
  11              		.eabi_attribute 30, 6
  12              		.eabi_attribute 18, 4
  13              		.thumb
  14              		.file	"tasks.c"
  22              	.Ltext0:
  23              		.cfi_sections	.debug_frame
  24              		.global	pxCurrentTCB
  25              		.section	.bss.pxCurrentTCB,"aw",%nobits
  26              		.align	2
  29              	pxCurrentTCB:
  30 0000 00000000 		.space	4
  31              		.section	.bss.pxReadyTasksLists,"aw",%nobits
  32              		.align	2
  35              	pxReadyTasksLists:
  36 0000 00000000 		.space	100
  36      00000000 
  36      00000000 
  36      00000000 
  36      00000000 
  37              		.section	.bss.xDelayedTaskList1,"aw",%nobits
  38              		.align	2
  41              	xDelayedTaskList1:
  42 0000 00000000 		.space	20
  42      00000000 
  42      00000000 
  42      00000000 
  42      00000000 
  43              		.section	.bss.xDelayedTaskList2,"aw",%nobits
  44              		.align	2
  47              	xDelayedTaskList2:
  48 0000 00000000 		.space	20
  48      00000000 
  48      00000000 
  48      00000000 
  48      00000000 
  49              		.section	.bss.pxDelayedTaskList,"aw",%nobits
  50              		.align	2
  53              	pxDelayedTaskList:
  54 0000 00000000 		.space	4
  55              		.section	.bss.pxOverflowDelayedTaskList,"aw",%nobits
  56              		.align	2
  59              	pxOverflowDelayedTaskList:
  60 0000 00000000 		.space	4
  61              		.section	.bss.xPendingReadyList,"aw",%nobits
  62              		.align	2
  65              	xPendingReadyList:
  66 0000 00000000 		.space	20
  66      00000000 
  66      00000000 
  66      00000000 
  66      00000000 
  67              		.section	.bss.xTasksWaitingTermination,"aw",%nobits
  68              		.align	2
  71              	xTasksWaitingTermination:
  72 0000 00000000 		.space	20
  72      00000000 
  72      00000000 
  72      00000000 
  72      00000000 
  73              		.section	.bss.uxTasksDeleted,"aw",%nobits
  74              		.align	2
  77              	uxTasksDeleted:
  78 0000 00000000 		.space	4
  79              		.section	.bss.xSuspendedTaskList,"aw",%nobits
  80              		.align	2
  83              	xSuspendedTaskList:
  84 0000 00000000 		.space	20
  84      00000000 
  84      00000000 
  84      00000000 
  84      00000000 
  85              		.section	.bss.uxCurrentNumberOfTasks,"aw",%nobits
  86              		.align	2
  89              	uxCurrentNumberOfTasks:
  90 0000 00000000 		.space	4
  91              		.section	.bss.xTickCount,"aw",%nobits
  92              		.align	2
  95              	xTickCount:
  96 0000 00000000 		.space	4
  97              		.section	.bss.uxTopUsedPriority,"aw",%nobits
  98              		.align	2
 101              	uxTopUsedPriority:
 102 0000 00000000 		.space	4
 103              		.section	.bss.uxTopReadyPriority,"aw",%nobits
 104              		.align	2
 107              	uxTopReadyPriority:
 108 0000 00000000 		.space	4
 109              		.section	.bss.xSchedulerRunning,"aw",%nobits
 110              		.align	2
 113              	xSchedulerRunning:
 114 0000 00000000 		.space	4
 115              		.section	.bss.uxSchedulerSuspended,"aw",%nobits
 116              		.align	2
 119              	uxSchedulerSuspended:
 120 0000 00000000 		.space	4
 121              		.section	.bss.uxMissedTicks,"aw",%nobits
 122              		.align	2
 125              	uxMissedTicks:
 126 0000 00000000 		.space	4
 127              		.section	.bss.xMissedYield,"aw",%nobits
 128              		.align	2
 131              	xMissedYield:
 132 0000 00000000 		.space	4
 133              		.section	.bss.xNumOfOverflows,"aw",%nobits
 134              		.align	2
 137              	xNumOfOverflows:
 138 0000 00000000 		.space	4
 139              		.section	.bss.uxTCBNumber,"aw",%nobits
 140              		.align	2
 143              	uxTCBNumber:
 144 0000 00000000 		.space	4
 145              		.section	.data.xNextTaskUnblockTime,"aw",%progbits
 146              		.align	2
 149              	xNextTaskUnblockTime:
 150 0000 FFFFFFFF 		.word	-1
 151              		.section	.text.xTaskGenericCreate,"ax",%progbits
 152              		.align	2
 153              		.global	xTaskGenericCreate
 154              		.thumb
 155              		.thumb_func
 157              	xTaskGenericCreate:
 158              	.LFB110:
 159              		.file 1 "lib/FreeRTOS/tasks.c"
   1:lib/FreeRTOS/tasks.c **** /*
   2:lib/FreeRTOS/tasks.c ****     FreeRTOS V7.1.0 - Copyright (C) 2011 Real Time Engineers Ltd.
   3:lib/FreeRTOS/tasks.c **** 	
   4:lib/FreeRTOS/tasks.c **** 
   5:lib/FreeRTOS/tasks.c ****     ***************************************************************************
   6:lib/FreeRTOS/tasks.c ****      *                                                                       *
   7:lib/FreeRTOS/tasks.c ****      *    FreeRTOS tutorial books are available in pdf and paperback.        *
   8:lib/FreeRTOS/tasks.c ****      *    Complete, revised, and edited pdf reference manuals are also       *
   9:lib/FreeRTOS/tasks.c ****      *    available.                                                         *
  10:lib/FreeRTOS/tasks.c ****      *                                                                       *
  11:lib/FreeRTOS/tasks.c ****      *    Purchasing FreeRTOS documentation will not only help you, by       *
  12:lib/FreeRTOS/tasks.c ****      *    ensuring you get running as quickly as possible and with an        *
  13:lib/FreeRTOS/tasks.c ****      *    in-depth knowledge of how to use FreeRTOS, it will also help       *
  14:lib/FreeRTOS/tasks.c ****      *    the FreeRTOS project to continue with its mission of providing     *
  15:lib/FreeRTOS/tasks.c ****      *    professional grade, cross platform, de facto standard solutions    *
  16:lib/FreeRTOS/tasks.c ****      *    for microcontrollers - completely free of charge!                  *
  17:lib/FreeRTOS/tasks.c ****      *                                                                       *
  18:lib/FreeRTOS/tasks.c ****      *    >>> See http://www.FreeRTOS.org/Documentation for details. <<<     *
  19:lib/FreeRTOS/tasks.c ****      *                                                                       *
  20:lib/FreeRTOS/tasks.c ****      *    Thank you for using FreeRTOS, and thank you for your support!      *
  21:lib/FreeRTOS/tasks.c ****      *                                                                       *
  22:lib/FreeRTOS/tasks.c ****     ***************************************************************************
  23:lib/FreeRTOS/tasks.c **** 
  24:lib/FreeRTOS/tasks.c **** 
  25:lib/FreeRTOS/tasks.c ****     This file is part of the FreeRTOS distribution.
  26:lib/FreeRTOS/tasks.c **** 
  27:lib/FreeRTOS/tasks.c ****     FreeRTOS is free software; you can redistribute it and/or modify it under
  28:lib/FreeRTOS/tasks.c ****     the terms of the GNU General Public License (version 2) as published by the
  29:lib/FreeRTOS/tasks.c ****     Free Software Foundation AND MODIFIED BY the FreeRTOS exception.
  30:lib/FreeRTOS/tasks.c ****     >>>NOTE<<< The modification to the GPL is included to allow you to
  31:lib/FreeRTOS/tasks.c ****     distribute a combined work that includes FreeRTOS without being obliged to
  32:lib/FreeRTOS/tasks.c ****     provide the source code for proprietary components outside of the FreeRTOS
  33:lib/FreeRTOS/tasks.c ****     kernel.  FreeRTOS is distributed in the hope that it will be useful, but
  34:lib/FreeRTOS/tasks.c ****     WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  35:lib/FreeRTOS/tasks.c ****     or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
  36:lib/FreeRTOS/tasks.c ****     more details. You should have received a copy of the GNU General Public
  37:lib/FreeRTOS/tasks.c ****     License and the FreeRTOS license exception along with FreeRTOS; if not it
  38:lib/FreeRTOS/tasks.c ****     can be viewed here: http://www.freertos.org/a00114.html and also obtained
  39:lib/FreeRTOS/tasks.c ****     by writing to Richard Barry, contact details for whom are available on the
  40:lib/FreeRTOS/tasks.c ****     FreeRTOS WEB site.
  41:lib/FreeRTOS/tasks.c **** 
  42:lib/FreeRTOS/tasks.c ****     1 tab == 4 spaces!
  43:lib/FreeRTOS/tasks.c **** 
  44:lib/FreeRTOS/tasks.c ****     http://www.FreeRTOS.org - Documentation, latest information, license and
  45:lib/FreeRTOS/tasks.c ****     contact details.
  46:lib/FreeRTOS/tasks.c **** 
  47:lib/FreeRTOS/tasks.c ****     http://www.SafeRTOS.com - A version that is certified for use in safety
  48:lib/FreeRTOS/tasks.c ****     critical systems.
  49:lib/FreeRTOS/tasks.c **** 
  50:lib/FreeRTOS/tasks.c ****     http://www.OpenRTOS.com - Commercial support, development, porting,
  51:lib/FreeRTOS/tasks.c ****     licensing and training services.
  52:lib/FreeRTOS/tasks.c **** */
  53:lib/FreeRTOS/tasks.c **** 
  54:lib/FreeRTOS/tasks.c **** 
  55:lib/FreeRTOS/tasks.c **** #include <stdio.h>
  56:lib/FreeRTOS/tasks.c **** #include <stdlib.h>
  57:lib/FreeRTOS/tasks.c **** #include <string.h>
  58:lib/FreeRTOS/tasks.c **** 
  59:lib/FreeRTOS/tasks.c **** /* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
  60:lib/FreeRTOS/tasks.c **** all the API functions to use the MPU wrappers.  That should only be done when
  61:lib/FreeRTOS/tasks.c **** task.h is included from an application file. */
  62:lib/FreeRTOS/tasks.c **** #define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
  63:lib/FreeRTOS/tasks.c **** 
  64:lib/FreeRTOS/tasks.c **** #include "FreeRTOS.h"
  65:lib/FreeRTOS/tasks.c **** #include "task.h"
  66:lib/FreeRTOS/tasks.c **** #include "timers.h"
  67:lib/FreeRTOS/tasks.c **** #include "StackMacros.h"
  68:lib/FreeRTOS/tasks.c **** 
  69:lib/FreeRTOS/tasks.c **** #undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE
  70:lib/FreeRTOS/tasks.c **** 
  71:lib/FreeRTOS/tasks.c **** /*
  72:lib/FreeRTOS/tasks.c ****  * Macro to define the amount of stack available to the idle task.
  73:lib/FreeRTOS/tasks.c ****  */
  74:lib/FreeRTOS/tasks.c **** #define tskIDLE_STACK_SIZE	configMINIMAL_STACK_SIZE
  75:lib/FreeRTOS/tasks.c **** 
  76:lib/FreeRTOS/tasks.c **** /*
  77:lib/FreeRTOS/tasks.c ****  * Task control block.  A task control block (TCB) is allocated to each task,
  78:lib/FreeRTOS/tasks.c ****  * and stores the context of the task.
  79:lib/FreeRTOS/tasks.c ****  */
  80:lib/FreeRTOS/tasks.c **** typedef struct tskTaskControlBlock
  81:lib/FreeRTOS/tasks.c **** {
  82:lib/FreeRTOS/tasks.c **** 	volatile portSTACK_TYPE	*pxTopOfStack;		/*< Points to the location of the last item placed on the 
  83:lib/FreeRTOS/tasks.c **** 
  84:lib/FreeRTOS/tasks.c **** 	#if ( portUSING_MPU_WRAPPERS == 1 )
  85:lib/FreeRTOS/tasks.c **** 		xMPU_SETTINGS xMPUSettings;				/*< The MPU settings are defined as part of the port layer.  THIS 
  86:lib/FreeRTOS/tasks.c **** 	#endif	
  87:lib/FreeRTOS/tasks.c **** 	
  88:lib/FreeRTOS/tasks.c **** 	xListItem				xGenericListItem;	/*< List item used to place the TCB in ready and blocked queues. */
  89:lib/FreeRTOS/tasks.c **** 	xListItem				xEventListItem;		/*< List item used to place the TCB in event lists. */
  90:lib/FreeRTOS/tasks.c **** 	unsigned portBASE_TYPE	uxPriority;			/*< The priority of the task where 0 is the lowest priority. 
  91:lib/FreeRTOS/tasks.c **** 	portSTACK_TYPE			*pxStack;			/*< Points to the start of the stack. */
  92:lib/FreeRTOS/tasks.c **** 	signed char				pcTaskName[ configMAX_TASK_NAME_LEN ];/*< Descriptive name given to the task when c
  93:lib/FreeRTOS/tasks.c **** 
  94:lib/FreeRTOS/tasks.c **** 	#if ( portSTACK_GROWTH > 0 )
  95:lib/FreeRTOS/tasks.c **** 		portSTACK_TYPE *pxEndOfStack;			/*< Used for stack overflow checking on architectures where the s
  96:lib/FreeRTOS/tasks.c **** 	#endif
  97:lib/FreeRTOS/tasks.c **** 
  98:lib/FreeRTOS/tasks.c **** 	#if ( portCRITICAL_NESTING_IN_TCB == 1 )
  99:lib/FreeRTOS/tasks.c **** 		unsigned portBASE_TYPE uxCriticalNesting;
 100:lib/FreeRTOS/tasks.c **** 	#endif
 101:lib/FreeRTOS/tasks.c **** 
 102:lib/FreeRTOS/tasks.c **** 	#if ( configUSE_TRACE_FACILITY == 1 )
 103:lib/FreeRTOS/tasks.c **** 		unsigned portBASE_TYPE	uxTCBNumber;	/*< This stores a number that increments each time a TCB is c
 104:lib/FreeRTOS/tasks.c **** 		unsigned portBASE_TYPE  uxTaskNumber;	/*< This stores a number specifically for use by third part
 105:lib/FreeRTOS/tasks.c **** 	#endif
 106:lib/FreeRTOS/tasks.c **** 
 107:lib/FreeRTOS/tasks.c **** 	#if ( configUSE_MUTEXES == 1 )
 108:lib/FreeRTOS/tasks.c **** 		unsigned portBASE_TYPE uxBasePriority;	/*< The priority last assigned to the task - used by the p
 109:lib/FreeRTOS/tasks.c **** 	#endif
 110:lib/FreeRTOS/tasks.c **** 
 111:lib/FreeRTOS/tasks.c **** 	#if ( configUSE_APPLICATION_TASK_TAG == 1 )
 112:lib/FreeRTOS/tasks.c **** 		pdTASK_HOOK_CODE pxTaskTag;
 113:lib/FreeRTOS/tasks.c **** 	#endif
 114:lib/FreeRTOS/tasks.c **** 
 115:lib/FreeRTOS/tasks.c **** 	#if ( configGENERATE_RUN_TIME_STATS == 1 )
 116:lib/FreeRTOS/tasks.c **** 		unsigned long ulRunTimeCounter;		/*< Used for calculating how much CPU time each task is utilisin
 117:lib/FreeRTOS/tasks.c **** 	#endif
 118:lib/FreeRTOS/tasks.c **** 
 119:lib/FreeRTOS/tasks.c **** } tskTCB;
 120:lib/FreeRTOS/tasks.c **** 
 121:lib/FreeRTOS/tasks.c **** 
 122:lib/FreeRTOS/tasks.c **** /*
 123:lib/FreeRTOS/tasks.c ****  * Some kernel aware debuggers require data to be viewed to be global, rather
 124:lib/FreeRTOS/tasks.c ****  * than file scope.
 125:lib/FreeRTOS/tasks.c ****  */
 126:lib/FreeRTOS/tasks.c **** #ifdef portREMOVE_STATIC_QUALIFIER
 127:lib/FreeRTOS/tasks.c **** 	#define static
 128:lib/FreeRTOS/tasks.c **** #endif
 129:lib/FreeRTOS/tasks.c **** 
 130:lib/FreeRTOS/tasks.c **** /*lint -e956 */
 131:lib/FreeRTOS/tasks.c **** PRIVILEGED_DATA tskTCB * volatile pxCurrentTCB = NULL;
 132:lib/FreeRTOS/tasks.c **** 
 133:lib/FreeRTOS/tasks.c **** /* Lists for ready and blocked tasks. --------------------*/
 134:lib/FreeRTOS/tasks.c **** 
 135:lib/FreeRTOS/tasks.c **** PRIVILEGED_DATA static xList pxReadyTasksLists[ configMAX_PRIORITIES ];	/*< Prioritised ready tasks
 136:lib/FreeRTOS/tasks.c **** PRIVILEGED_DATA static xList xDelayedTaskList1;							/*< Delayed tasks. */
 137:lib/FreeRTOS/tasks.c **** PRIVILEGED_DATA static xList xDelayedTaskList2;							/*< Delayed tasks (two lists are used - one f
 138:lib/FreeRTOS/tasks.c **** PRIVILEGED_DATA static xList * volatile pxDelayedTaskList ;				/*< Points to the delayed task list 
 139:lib/FreeRTOS/tasks.c **** PRIVILEGED_DATA static xList * volatile pxOverflowDelayedTaskList;		/*< Points to the delayed task 
 140:lib/FreeRTOS/tasks.c **** PRIVILEGED_DATA static xList xPendingReadyList;							/*< Tasks that have been readied while the sc
 141:lib/FreeRTOS/tasks.c **** 
 142:lib/FreeRTOS/tasks.c **** #if ( INCLUDE_vTaskDelete == 1 )
 143:lib/FreeRTOS/tasks.c **** 
 144:lib/FreeRTOS/tasks.c **** 	PRIVILEGED_DATA static xList xTasksWaitingTermination;				/*< Tasks that have been deleted - but t
 145:lib/FreeRTOS/tasks.c **** 	PRIVILEGED_DATA static volatile unsigned portBASE_TYPE uxTasksDeleted = ( unsigned portBASE_TYPE )
 146:lib/FreeRTOS/tasks.c **** 
 147:lib/FreeRTOS/tasks.c **** #endif
 148:lib/FreeRTOS/tasks.c **** 
 149:lib/FreeRTOS/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
 150:lib/FreeRTOS/tasks.c **** 
 151:lib/FreeRTOS/tasks.c **** 	PRIVILEGED_DATA static xList xSuspendedTaskList;					/*< Tasks that are currently suspended. */
 152:lib/FreeRTOS/tasks.c **** 
 153:lib/FreeRTOS/tasks.c **** #endif
 154:lib/FreeRTOS/tasks.c **** 
 155:lib/FreeRTOS/tasks.c **** #if ( INCLUDE_xTaskGetIdleTaskHandle == 1 )
 156:lib/FreeRTOS/tasks.c **** 	
 157:lib/FreeRTOS/tasks.c **** 	PRIVILEGED_DATA static xTaskHandle xIdleTaskHandle = NULL;
 158:lib/FreeRTOS/tasks.c **** 	
 159:lib/FreeRTOS/tasks.c **** #endif
 160:lib/FreeRTOS/tasks.c **** 
 161:lib/FreeRTOS/tasks.c **** /* File private variables. --------------------------------*/
 162:lib/FreeRTOS/tasks.c **** PRIVILEGED_DATA static volatile unsigned portBASE_TYPE uxCurrentNumberOfTasks 	= ( unsigned portBAS
 163:lib/FreeRTOS/tasks.c **** PRIVILEGED_DATA static volatile portTickType xTickCount 						= ( portTickType ) 0U;
 164:lib/FreeRTOS/tasks.c **** PRIVILEGED_DATA static unsigned portBASE_TYPE uxTopUsedPriority	 				= tskIDLE_PRIORITY;
 165:lib/FreeRTOS/tasks.c **** PRIVILEGED_DATA static volatile unsigned portBASE_TYPE uxTopReadyPriority 		= tskIDLE_PRIORITY;
 166:lib/FreeRTOS/tasks.c **** PRIVILEGED_DATA static volatile signed portBASE_TYPE xSchedulerRunning 			= pdFALSE;
 167:lib/FreeRTOS/tasks.c **** PRIVILEGED_DATA static volatile unsigned portBASE_TYPE uxSchedulerSuspended	 	= ( unsigned portBASE
 168:lib/FreeRTOS/tasks.c **** PRIVILEGED_DATA static volatile unsigned portBASE_TYPE uxMissedTicks 			= ( unsigned portBASE_TYPE 
 169:lib/FreeRTOS/tasks.c **** PRIVILEGED_DATA static volatile portBASE_TYPE xMissedYield 						= ( portBASE_TYPE ) pdFALSE;
 170:lib/FreeRTOS/tasks.c **** PRIVILEGED_DATA static volatile portBASE_TYPE xNumOfOverflows 					= ( portBASE_TYPE ) 0;
 171:lib/FreeRTOS/tasks.c **** PRIVILEGED_DATA static unsigned portBASE_TYPE uxTCBNumber 						= ( unsigned portBASE_TYPE ) 0U;
 172:lib/FreeRTOS/tasks.c **** PRIVILEGED_DATA static portTickType xNextTaskUnblockTime						= ( portTickType ) portMAX_DELAY;
 173:lib/FreeRTOS/tasks.c **** 
 174:lib/FreeRTOS/tasks.c **** #if ( configGENERATE_RUN_TIME_STATS == 1 )
 175:lib/FreeRTOS/tasks.c **** 
 176:lib/FreeRTOS/tasks.c **** 	PRIVILEGED_DATA static char pcStatsString[ 50 ] ;
 177:lib/FreeRTOS/tasks.c **** 	PRIVILEGED_DATA static unsigned long ulTaskSwitchedInTime = 0UL;	/*< Holds the value of a timer/co
 178:lib/FreeRTOS/tasks.c **** 	static void prvGenerateRunTimeStatsForTasksInList( const signed char *pcWriteBuffer, xList *pxList
 179:lib/FreeRTOS/tasks.c **** 
 180:lib/FreeRTOS/tasks.c **** #endif
 181:lib/FreeRTOS/tasks.c **** 
 182:lib/FreeRTOS/tasks.c **** /* Debugging and trace facilities private variables and macros. ------------*/
 183:lib/FreeRTOS/tasks.c **** 
 184:lib/FreeRTOS/tasks.c **** /*
 185:lib/FreeRTOS/tasks.c ****  * The value used to fill the stack of a task when the task is created.  This
 186:lib/FreeRTOS/tasks.c ****  * is used purely for checking the high water mark for tasks.
 187:lib/FreeRTOS/tasks.c ****  */
 188:lib/FreeRTOS/tasks.c **** #define tskSTACK_FILL_BYTE	( 0xa5U )
 189:lib/FreeRTOS/tasks.c **** 
 190:lib/FreeRTOS/tasks.c **** /*
 191:lib/FreeRTOS/tasks.c ****  * Macros used by vListTask to indicate which state a task is in.
 192:lib/FreeRTOS/tasks.c ****  */
 193:lib/FreeRTOS/tasks.c **** #define tskBLOCKED_CHAR		( ( signed char ) 'B' )
 194:lib/FreeRTOS/tasks.c **** #define tskREADY_CHAR		( ( signed char ) 'R' )
 195:lib/FreeRTOS/tasks.c **** #define tskDELETED_CHAR		( ( signed char ) 'D' )
 196:lib/FreeRTOS/tasks.c **** #define tskSUSPENDED_CHAR	( ( signed char ) 'S' )
 197:lib/FreeRTOS/tasks.c **** 
 198:lib/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
 199:lib/FreeRTOS/tasks.c **** 
 200:lib/FreeRTOS/tasks.c **** /*
 201:lib/FreeRTOS/tasks.c ****  * Place the task represented by pxTCB into the appropriate ready queue for
 202:lib/FreeRTOS/tasks.c ****  * the task.  It is inserted at the end of the list.  One quirk of this is
 203:lib/FreeRTOS/tasks.c ****  * that if the task being inserted is at the same priority as the currently
 204:lib/FreeRTOS/tasks.c ****  * executing task, then it will only be rescheduled after the currently
 205:lib/FreeRTOS/tasks.c ****  * executing task has been rescheduled.
 206:lib/FreeRTOS/tasks.c ****  */
 207:lib/FreeRTOS/tasks.c **** #define prvAddTaskToReadyQueue( pxTCB )																					\
 208:lib/FreeRTOS/tasks.c **** 	if( ( pxTCB )->uxPriority > uxTopReadyPriority )																	\
 209:lib/FreeRTOS/tasks.c **** 	{																													\
 210:lib/FreeRTOS/tasks.c **** 		uxTopReadyPriority = ( pxTCB )->uxPriority;																		\
 211:lib/FreeRTOS/tasks.c **** 	}																													\
 212:lib/FreeRTOS/tasks.c **** 	vListInsertEnd( ( xList * ) &( pxReadyTasksLists[ ( pxTCB )->uxPriority ] ), &( ( pxTCB )->xGeneri
 213:lib/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
 214:lib/FreeRTOS/tasks.c **** 
 215:lib/FreeRTOS/tasks.c **** /*
 216:lib/FreeRTOS/tasks.c ****  * Macro that looks at the list of tasks that are currently delayed to see if
 217:lib/FreeRTOS/tasks.c ****  * any require waking.
 218:lib/FreeRTOS/tasks.c ****  *
 219:lib/FreeRTOS/tasks.c ****  * Tasks are stored in the queue in the order of their wake time - meaning
 220:lib/FreeRTOS/tasks.c ****  * once one tasks has been found whose timer has not expired we need not look
 221:lib/FreeRTOS/tasks.c ****  * any further down the list.
 222:lib/FreeRTOS/tasks.c ****  */
 223:lib/FreeRTOS/tasks.c **** #define prvCheckDelayedTasks()															\
 224:lib/FreeRTOS/tasks.c **** {																						\
 225:lib/FreeRTOS/tasks.c **** portTickType xItemValue;																\
 226:lib/FreeRTOS/tasks.c **** 																						\
 227:lib/FreeRTOS/tasks.c **** 	/* Is the tick count greater than or equal to the wake time of the first			\
 228:lib/FreeRTOS/tasks.c **** 	task referenced from the delayed tasks list? */										\
 229:lib/FreeRTOS/tasks.c **** 	if( xTickCount >= xNextTaskUnblockTime )											\
 230:lib/FreeRTOS/tasks.c **** 	{																					\
 231:lib/FreeRTOS/tasks.c **** 		for( ;; )																		\
 232:lib/FreeRTOS/tasks.c **** 		{																				\
 233:lib/FreeRTOS/tasks.c **** 			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )						\
 234:lib/FreeRTOS/tasks.c **** 			{																			\
 235:lib/FreeRTOS/tasks.c **** 				/* The delayed list is empty.  Set xNextTaskUnblockTime to the			\
 236:lib/FreeRTOS/tasks.c **** 				maximum possible value so it is extremely unlikely that the				\
 237:lib/FreeRTOS/tasks.c **** 				if( xTickCount >= xNextTaskUnblockTime ) test will pass next			\
 238:lib/FreeRTOS/tasks.c **** 				time through. */														\
 239:lib/FreeRTOS/tasks.c **** 				xNextTaskUnblockTime = portMAX_DELAY;									\
 240:lib/FreeRTOS/tasks.c **** 				break;																	\
 241:lib/FreeRTOS/tasks.c **** 			}																			\
 242:lib/FreeRTOS/tasks.c **** 			else																		\
 243:lib/FreeRTOS/tasks.c **** 			{																			\
 244:lib/FreeRTOS/tasks.c **** 				/* The delayed list is not empty, get the value of the item at			\
 245:lib/FreeRTOS/tasks.c **** 				the head of the delayed list.  This is the time at which the			\
 246:lib/FreeRTOS/tasks.c **** 				task at the head of the delayed list should be removed from				\
 247:lib/FreeRTOS/tasks.c **** 				the Blocked state. */													\
 248:lib/FreeRTOS/tasks.c **** 				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );	\
 249:lib/FreeRTOS/tasks.c **** 				xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );	\
 250:lib/FreeRTOS/tasks.c **** 																						\
 251:lib/FreeRTOS/tasks.c **** 				if( xTickCount < xItemValue )											\
 252:lib/FreeRTOS/tasks.c **** 				{																		\
 253:lib/FreeRTOS/tasks.c **** 					/* It is not time to unblock this item yet, but the item			\
 254:lib/FreeRTOS/tasks.c **** 					value is the time at which the task at the head of the				\
 255:lib/FreeRTOS/tasks.c **** 					blocked list should be removed from the Blocked state -				\
 256:lib/FreeRTOS/tasks.c **** 					so record the item value in xNextTaskUnblockTime. */				\
 257:lib/FreeRTOS/tasks.c **** 					xNextTaskUnblockTime = xItemValue;									\
 258:lib/FreeRTOS/tasks.c **** 					break;																\
 259:lib/FreeRTOS/tasks.c **** 				}																		\
 260:lib/FreeRTOS/tasks.c **** 																						\
 261:lib/FreeRTOS/tasks.c **** 				/* It is time to remove the item from the Blocked state. */				\
 262:lib/FreeRTOS/tasks.c **** 				vListRemove( &( pxTCB->xGenericListItem ) );							\
 263:lib/FreeRTOS/tasks.c **** 																						\
 264:lib/FreeRTOS/tasks.c **** 				/* Is the task waiting on an event also? */								\
 265:lib/FreeRTOS/tasks.c **** 				if( pxTCB->xEventListItem.pvContainer != NULL )							\
 266:lib/FreeRTOS/tasks.c **** 				{																		\
 267:lib/FreeRTOS/tasks.c **** 					vListRemove( &( pxTCB->xEventListItem ) );							\
 268:lib/FreeRTOS/tasks.c **** 				}																		\
 269:lib/FreeRTOS/tasks.c **** 				prvAddTaskToReadyQueue( pxTCB );										\
 270:lib/FreeRTOS/tasks.c **** 			}																			\
 271:lib/FreeRTOS/tasks.c **** 		}																				\
 272:lib/FreeRTOS/tasks.c **** 	}																					\
 273:lib/FreeRTOS/tasks.c **** }
 274:lib/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
 275:lib/FreeRTOS/tasks.c **** 
 276:lib/FreeRTOS/tasks.c **** /*
 277:lib/FreeRTOS/tasks.c ****  * Several functions take an xTaskHandle parameter that can optionally be NULL,
 278:lib/FreeRTOS/tasks.c ****  * where NULL is used to indicate that the handle of the currently executing
 279:lib/FreeRTOS/tasks.c ****  * task should be used in place of the parameter.  This macro simply checks to
 280:lib/FreeRTOS/tasks.c ****  * see if the parameter is NULL and returns a pointer to the appropriate TCB.
 281:lib/FreeRTOS/tasks.c ****  */
 282:lib/FreeRTOS/tasks.c **** #define prvGetTCBFromHandle( pxHandle ) ( ( ( pxHandle ) == NULL ) ? ( tskTCB * ) pxCurrentTCB : ( 
 283:lib/FreeRTOS/tasks.c **** 
 284:lib/FreeRTOS/tasks.c **** /* Callback function prototypes. --------------------------*/
 285:lib/FreeRTOS/tasks.c **** extern void vApplicationStackOverflowHook( xTaskHandle *pxTask, signed char *pcTaskName );
 286:lib/FreeRTOS/tasks.c **** extern void vApplicationTickHook( void );
 287:lib/FreeRTOS/tasks.c **** 		
 288:lib/FreeRTOS/tasks.c **** /* File private functions. --------------------------------*/
 289:lib/FreeRTOS/tasks.c **** 
 290:lib/FreeRTOS/tasks.c **** /*
 291:lib/FreeRTOS/tasks.c ****  * Utility to ready a TCB for a given task.  Mainly just copies the parameters
 292:lib/FreeRTOS/tasks.c ****  * into the TCB structure.
 293:lib/FreeRTOS/tasks.c ****  */
 294:lib/FreeRTOS/tasks.c **** static void prvInitialiseTCBVariables( tskTCB *pxTCB, const signed char * const pcName, unsigned po
 295:lib/FreeRTOS/tasks.c **** 
 296:lib/FreeRTOS/tasks.c **** /*
 297:lib/FreeRTOS/tasks.c ****  * Utility to ready all the lists used by the scheduler.  This is called
 298:lib/FreeRTOS/tasks.c ****  * automatically upon the creation of the first task.
 299:lib/FreeRTOS/tasks.c ****  */
 300:lib/FreeRTOS/tasks.c **** static void prvInitialiseTaskLists( void ) PRIVILEGED_FUNCTION;
 301:lib/FreeRTOS/tasks.c **** 
 302:lib/FreeRTOS/tasks.c **** /*
 303:lib/FreeRTOS/tasks.c ****  * The idle task, which as all tasks is implemented as a never ending loop.
 304:lib/FreeRTOS/tasks.c ****  * The idle task is automatically created and added to the ready lists upon
 305:lib/FreeRTOS/tasks.c ****  * creation of the first user task.
 306:lib/FreeRTOS/tasks.c ****  *
 307:lib/FreeRTOS/tasks.c ****  * The portTASK_FUNCTION_PROTO() macro is used to allow port/compiler specific
 308:lib/FreeRTOS/tasks.c ****  * language extensions.  The equivalent prototype for this function is:
 309:lib/FreeRTOS/tasks.c ****  *
 310:lib/FreeRTOS/tasks.c ****  * void prvIdleTask( void *pvParameters );
 311:lib/FreeRTOS/tasks.c ****  *
 312:lib/FreeRTOS/tasks.c ****  */
 313:lib/FreeRTOS/tasks.c **** static portTASK_FUNCTION_PROTO( prvIdleTask, pvParameters );
 314:lib/FreeRTOS/tasks.c **** 
 315:lib/FreeRTOS/tasks.c **** /*
 316:lib/FreeRTOS/tasks.c ****  * Utility to free all memory allocated by the scheduler to hold a TCB,
 317:lib/FreeRTOS/tasks.c ****  * including the stack pointed to by the TCB.
 318:lib/FreeRTOS/tasks.c ****  *
 319:lib/FreeRTOS/tasks.c ****  * This does not free memory allocated by the task itself (i.e. memory
 320:lib/FreeRTOS/tasks.c ****  * allocated by calls to pvPortMalloc from within the tasks application code).
 321:lib/FreeRTOS/tasks.c ****  */
 322:lib/FreeRTOS/tasks.c **** #if ( INCLUDE_vTaskDelete == 1 )
 323:lib/FreeRTOS/tasks.c **** 
 324:lib/FreeRTOS/tasks.c **** 	static void prvDeleteTCB( tskTCB *pxTCB ) PRIVILEGED_FUNCTION;
 325:lib/FreeRTOS/tasks.c **** 
 326:lib/FreeRTOS/tasks.c **** #endif
 327:lib/FreeRTOS/tasks.c **** 
 328:lib/FreeRTOS/tasks.c **** /*
 329:lib/FreeRTOS/tasks.c ****  * Used only by the idle task.  This checks to see if anything has been placed
 330:lib/FreeRTOS/tasks.c ****  * in the list of tasks waiting to be deleted.  If so the task is cleaned up
 331:lib/FreeRTOS/tasks.c ****  * and its TCB deleted.
 332:lib/FreeRTOS/tasks.c ****  */
 333:lib/FreeRTOS/tasks.c **** static void prvCheckTasksWaitingTermination( void ) PRIVILEGED_FUNCTION;
 334:lib/FreeRTOS/tasks.c **** 
 335:lib/FreeRTOS/tasks.c **** /*
 336:lib/FreeRTOS/tasks.c ****  * The currently executing task is entering the Blocked state.  Add the task to
 337:lib/FreeRTOS/tasks.c ****  * either the current or the overflow delayed task list.
 338:lib/FreeRTOS/tasks.c ****  */
 339:lib/FreeRTOS/tasks.c **** static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake ) PRIVILEGED_FUNCTION;
 340:lib/FreeRTOS/tasks.c **** 
 341:lib/FreeRTOS/tasks.c **** /*
 342:lib/FreeRTOS/tasks.c ****  * Allocates memory from the heap for a TCB and associated stack.  Checks the
 343:lib/FreeRTOS/tasks.c ****  * allocation was successful.
 344:lib/FreeRTOS/tasks.c ****  */
 345:lib/FreeRTOS/tasks.c **** static tskTCB *prvAllocateTCBAndStack( unsigned short usStackDepth, portSTACK_TYPE *puxStackBuffer 
 346:lib/FreeRTOS/tasks.c **** 
 347:lib/FreeRTOS/tasks.c **** /*
 348:lib/FreeRTOS/tasks.c ****  * Called from vTaskList.  vListTasks details all the tasks currently under
 349:lib/FreeRTOS/tasks.c ****  * control of the scheduler.  The tasks may be in one of a number of lists.
 350:lib/FreeRTOS/tasks.c ****  * prvListTaskWithinSingleList accepts a list and details the tasks from
 351:lib/FreeRTOS/tasks.c ****  * within just that list.
 352:lib/FreeRTOS/tasks.c ****  *
 353:lib/FreeRTOS/tasks.c ****  * THIS FUNCTION IS INTENDED FOR DEBUGGING ONLY, AND SHOULD NOT BE CALLED FROM
 354:lib/FreeRTOS/tasks.c ****  * NORMAL APPLICATION CODE.
 355:lib/FreeRTOS/tasks.c ****  */
 356:lib/FreeRTOS/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
 357:lib/FreeRTOS/tasks.c **** 
 358:lib/FreeRTOS/tasks.c **** 	static void prvListTaskWithinSingleList( const signed char *pcWriteBuffer, xList *pxList, signed c
 359:lib/FreeRTOS/tasks.c **** 
 360:lib/FreeRTOS/tasks.c **** #endif
 361:lib/FreeRTOS/tasks.c **** 
 362:lib/FreeRTOS/tasks.c **** /*
 363:lib/FreeRTOS/tasks.c ****  * When a task is created, the stack of the task is filled with a known value.
 364:lib/FreeRTOS/tasks.c ****  * This function determines the 'high water mark' of the task stack by
 365:lib/FreeRTOS/tasks.c ****  * determining how much of the stack remains at the original preset value.
 366:lib/FreeRTOS/tasks.c ****  */
 367:lib/FreeRTOS/tasks.c **** #if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )
 368:lib/FreeRTOS/tasks.c **** 
 369:lib/FreeRTOS/tasks.c **** 	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte ) PRIVILEGED_F
 370:lib/FreeRTOS/tasks.c **** 
 371:lib/FreeRTOS/tasks.c **** #endif
 372:lib/FreeRTOS/tasks.c **** 
 373:lib/FreeRTOS/tasks.c **** 
 374:lib/FreeRTOS/tasks.c **** /*lint +e956 */
 375:lib/FreeRTOS/tasks.c **** 
 376:lib/FreeRTOS/tasks.c **** 
 377:lib/FreeRTOS/tasks.c **** 
 378:lib/FreeRTOS/tasks.c **** /*-----------------------------------------------------------
 379:lib/FreeRTOS/tasks.c ****  * TASK CREATION API documented in task.h
 380:lib/FreeRTOS/tasks.c ****  *----------------------------------------------------------*/
 381:lib/FreeRTOS/tasks.c **** 
 382:lib/FreeRTOS/tasks.c **** signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, 
 383:lib/FreeRTOS/tasks.c **** {
 160              		.loc 1 383 0
 161              		.cfi_startproc
 162              		@ args = 16, pretend = 0, frame = 32
 163              		@ frame_needed = 1, uses_anonymous_args = 0
 164 0000 80B5     		push	{r7, lr}
 165              	.LCFI0:
 166              		.cfi_def_cfa_offset 8
 167 0002 8AB0     		sub	sp, sp, #40
 168              	.LCFI1:
 169              		.cfi_def_cfa_offset 48
 170 0004 02AF     		add	r7, sp, #8
 171              		.cfi_offset 14, -4
 172              		.cfi_offset 7, -8
 173              	.LCFI2:
 174              		.cfi_def_cfa 7, 40
 175 0006 F860     		str	r0, [r7, #12]
 176 0008 B960     		str	r1, [r7, #8]
 177 000a 3B60     		str	r3, [r7, #0]
 178 000c 1346     		mov	r3, r2	@ movhi
 179 000e FB80     		strh	r3, [r7, #6]	@ movhi
 384:lib/FreeRTOS/tasks.c **** signed portBASE_TYPE xReturn;
 385:lib/FreeRTOS/tasks.c **** tskTCB * pxNewTCB;
 386:lib/FreeRTOS/tasks.c **** 
 387:lib/FreeRTOS/tasks.c **** 	configASSERT( pxTaskCode );
 180              		.loc 1 387 0
 181 0010 FB68     		ldr	r3, [r7, #12]
 182 0012 002B     		cmp	r3, #0
 183 0014 04D1     		bne	.L2
 184              		.loc 1 387 0 is_stmt 0 discriminator 1
 185              	@ 387 "lib/FreeRTOS/tasks.c" 1
 186 0016 4FF0BF00 			mov r0, #191								
 187 001a 80F31188 		msr basepri, r0							
 188              	
 189              	@ 0 "" 2
 190              		.thumb
 191              	.L3:
 192              		.loc 1 387 0 discriminator 2
 193 001e FEE7     		b	.L3
 194              	.L2:
 388:lib/FreeRTOS/tasks.c **** 	configASSERT( ( uxPriority < configMAX_PRIORITIES ) );
 195              		.loc 1 388 0 is_stmt 1
 196 0020 BB6A     		ldr	r3, [r7, #40]
 197 0022 042B     		cmp	r3, #4
 198 0024 04D9     		bls	.L4
 199              		.loc 1 388 0 is_stmt 0 discriminator 1
 200              	@ 388 "lib/FreeRTOS/tasks.c" 1
 201 0026 4FF0BF00 			mov r0, #191								
 202 002a 80F31188 		msr basepri, r0							
 203              	
 204              	@ 0 "" 2
 205              		.thumb
 206              	.L5:
 207              		.loc 1 388 0 discriminator 2
 208 002e FEE7     		b	.L5
 209              	.L4:
 389:lib/FreeRTOS/tasks.c **** 
 390:lib/FreeRTOS/tasks.c **** 	/* Allocate the memory required by the TCB and stack for the new task,
 391:lib/FreeRTOS/tasks.c **** 	checking that the allocation was successful. */
 392:lib/FreeRTOS/tasks.c **** 	pxNewTCB = prvAllocateTCBAndStack( usStackDepth, puxStackBuffer );
 210              		.loc 1 392 0 is_stmt 1
 211 0030 FB88     		ldrh	r3, [r7, #6]
 212 0032 1846     		mov	r0, r3
 213 0034 396B     		ldr	r1, [r7, #48]
 214 0036 FFF7FEFF 		bl	prvAllocateTCBAndStack
 215 003a B861     		str	r0, [r7, #24]
 393:lib/FreeRTOS/tasks.c **** 
 394:lib/FreeRTOS/tasks.c **** 	if( pxNewTCB != NULL )
 216              		.loc 1 394 0
 217 003c BB69     		ldr	r3, [r7, #24]
 218 003e 002B     		cmp	r3, #0
 219 0040 00F08780 		beq	.L6
 220              	.LBB2:
 395:lib/FreeRTOS/tasks.c **** 	{
 396:lib/FreeRTOS/tasks.c **** 		portSTACK_TYPE *pxTopOfStack;
 397:lib/FreeRTOS/tasks.c **** 
 398:lib/FreeRTOS/tasks.c **** 		#if( portUSING_MPU_WRAPPERS == 1 )
 399:lib/FreeRTOS/tasks.c **** 			/* Should the task be created in privileged mode? */
 400:lib/FreeRTOS/tasks.c **** 			portBASE_TYPE xRunPrivileged;
 401:lib/FreeRTOS/tasks.c **** 			if( ( uxPriority & portPRIVILEGE_BIT ) != 0U )
 402:lib/FreeRTOS/tasks.c **** 			{
 403:lib/FreeRTOS/tasks.c **** 				xRunPrivileged = pdTRUE;
 404:lib/FreeRTOS/tasks.c **** 			}
 405:lib/FreeRTOS/tasks.c **** 			else
 406:lib/FreeRTOS/tasks.c **** 			{
 407:lib/FreeRTOS/tasks.c **** 				xRunPrivileged = pdFALSE;
 408:lib/FreeRTOS/tasks.c **** 			}
 409:lib/FreeRTOS/tasks.c **** 			uxPriority &= ~portPRIVILEGE_BIT;
 410:lib/FreeRTOS/tasks.c **** 		#endif /* portUSING_MPU_WRAPPERS == 1 */
 411:lib/FreeRTOS/tasks.c **** 
 412:lib/FreeRTOS/tasks.c **** 		/* Calculate the top of stack address.  This depends on whether the
 413:lib/FreeRTOS/tasks.c **** 		stack grows from high memory to low (as per the 80x86) or visa versa.
 414:lib/FreeRTOS/tasks.c **** 		portSTACK_GROWTH is used to make the result positive or negative as
 415:lib/FreeRTOS/tasks.c **** 		required by the port. */
 416:lib/FreeRTOS/tasks.c **** 		#if( portSTACK_GROWTH < 0 )
 417:lib/FreeRTOS/tasks.c **** 		{
 418:lib/FreeRTOS/tasks.c **** 			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
 221              		.loc 1 418 0
 222 0044 BB69     		ldr	r3, [r7, #24]
 223 0046 1A6B     		ldr	r2, [r3, #48]
 224 0048 FB88     		ldrh	r3, [r7, #6]
 225 004a 03F1FF33 		add	r3, r3, #-1
 226 004e 4FEA8303 		lsl	r3, r3, #2
 227 0052 D318     		adds	r3, r2, r3
 228 0054 7B61     		str	r3, [r7, #20]
 419:lib/FreeRTOS/tasks.c **** 			pxTopOfStack = ( portSTACK_TYPE * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ( portPOINT
 229              		.loc 1 419 0
 230 0056 7B69     		ldr	r3, [r7, #20]
 231 0058 23F00703 		bic	r3, r3, #7
 232 005c 7B61     		str	r3, [r7, #20]
 420:lib/FreeRTOS/tasks.c **** 
 421:lib/FreeRTOS/tasks.c **** 			/* Check the alignment of the calculated top of stack is correct. */
 422:lib/FreeRTOS/tasks.c **** 			configASSERT( ( ( ( unsigned long ) pxTopOfStack & ( unsigned long ) portBYTE_ALIGNMENT_MASK ) =
 233              		.loc 1 422 0
 234 005e 7B69     		ldr	r3, [r7, #20]
 235 0060 03F00703 		and	r3, r3, #7
 236 0064 002B     		cmp	r3, #0
 237 0066 04D0     		beq	.L7
 238              		.loc 1 422 0 is_stmt 0 discriminator 1
 239              	@ 422 "lib/FreeRTOS/tasks.c" 1
 240 0068 4FF0BF00 			mov r0, #191								
 241 006c 80F31188 		msr basepri, r0							
 242              	
 243              	@ 0 "" 2
 244              		.thumb
 245              	.L8:
 246              		.loc 1 422 0 discriminator 2
 247 0070 FEE7     		b	.L8
 248              	.L7:
 423:lib/FreeRTOS/tasks.c **** 		}
 424:lib/FreeRTOS/tasks.c **** 		#else
 425:lib/FreeRTOS/tasks.c **** 		{
 426:lib/FreeRTOS/tasks.c **** 			pxTopOfStack = pxNewTCB->pxStack;
 427:lib/FreeRTOS/tasks.c **** 			
 428:lib/FreeRTOS/tasks.c **** 			/* Check the alignment of the stack buffer is correct. */
 429:lib/FreeRTOS/tasks.c **** 			configASSERT( ( ( ( unsigned long ) pxNewTCB->pxStack & ( unsigned long ) portBYTE_ALIGNMENT_MAS
 430:lib/FreeRTOS/tasks.c **** 
 431:lib/FreeRTOS/tasks.c **** 			/* If we want to use stack checking on architectures that use
 432:lib/FreeRTOS/tasks.c **** 			a positive stack growth direction then we also need to store the
 433:lib/FreeRTOS/tasks.c **** 			other extreme of the stack space. */
 434:lib/FreeRTOS/tasks.c **** 			pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
 435:lib/FreeRTOS/tasks.c **** 		}
 436:lib/FreeRTOS/tasks.c **** 		#endif
 437:lib/FreeRTOS/tasks.c **** 
 438:lib/FreeRTOS/tasks.c **** 		/* Setup the newly allocated TCB with the initial state of the task. */
 439:lib/FreeRTOS/tasks.c **** 		prvInitialiseTCBVariables( pxNewTCB, pcName, uxPriority, xRegions, usStackDepth );
 249              		.loc 1 439 0 is_stmt 1
 250 0072 FB88     		ldrh	r3, [r7, #6]
 251 0074 0093     		str	r3, [sp, #0]
 252 0076 B869     		ldr	r0, [r7, #24]
 253 0078 B968     		ldr	r1, [r7, #8]
 254 007a BA6A     		ldr	r2, [r7, #40]
 255 007c 7B6B     		ldr	r3, [r7, #52]
 256 007e FFF7FEFF 		bl	prvInitialiseTCBVariables
 440:lib/FreeRTOS/tasks.c **** 
 441:lib/FreeRTOS/tasks.c **** 		/* Initialize the TCB stack to look as if the task was already running,
 442:lib/FreeRTOS/tasks.c **** 		but had been interrupted by the scheduler.  The return address is set
 443:lib/FreeRTOS/tasks.c **** 		to the start of the task function. Once the stack has been initialised
 444:lib/FreeRTOS/tasks.c **** 		the	top of stack variable is updated. */
 445:lib/FreeRTOS/tasks.c **** 		#if( portUSING_MPU_WRAPPERS == 1 )
 446:lib/FreeRTOS/tasks.c **** 		{
 447:lib/FreeRTOS/tasks.c **** 			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPriv
 448:lib/FreeRTOS/tasks.c **** 		}
 449:lib/FreeRTOS/tasks.c **** 		#else
 450:lib/FreeRTOS/tasks.c **** 		{
 451:lib/FreeRTOS/tasks.c **** 			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 257              		.loc 1 451 0
 258 0082 7869     		ldr	r0, [r7, #20]
 259 0084 F968     		ldr	r1, [r7, #12]
 260 0086 3A68     		ldr	r2, [r7, #0]
 261 0088 FFF7FEFF 		bl	pxPortInitialiseStack
 262 008c 0346     		mov	r3, r0
 263 008e 1A46     		mov	r2, r3
 264 0090 BB69     		ldr	r3, [r7, #24]
 265 0092 1A60     		str	r2, [r3, #0]
 452:lib/FreeRTOS/tasks.c **** 		}
 453:lib/FreeRTOS/tasks.c **** 		#endif
 454:lib/FreeRTOS/tasks.c **** 
 455:lib/FreeRTOS/tasks.c **** 		/* Check the alignment of the initialised stack. */
 456:lib/FreeRTOS/tasks.c **** 		portALIGNMENT_ASSERT_pxCurrentTCB( ( ( ( unsigned long ) pxNewTCB->pxTopOfStack & ( unsigned long
 457:lib/FreeRTOS/tasks.c **** 
 458:lib/FreeRTOS/tasks.c **** 		if( ( void * ) pxCreatedTask != NULL )
 266              		.loc 1 458 0
 267 0094 FB6A     		ldr	r3, [r7, #44]
 268 0096 002B     		cmp	r3, #0
 269 0098 02D0     		beq	.L9
 459:lib/FreeRTOS/tasks.c **** 		{
 460:lib/FreeRTOS/tasks.c **** 			/* Pass the TCB out - in an anonymous way.  The calling function/
 461:lib/FreeRTOS/tasks.c **** 			task can use this as a handle to delete the task later if
 462:lib/FreeRTOS/tasks.c **** 			required.*/
 463:lib/FreeRTOS/tasks.c **** 			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
 270              		.loc 1 463 0
 271 009a FB6A     		ldr	r3, [r7, #44]
 272 009c BA69     		ldr	r2, [r7, #24]
 273 009e 1A60     		str	r2, [r3, #0]
 274              	.L9:
 464:lib/FreeRTOS/tasks.c **** 		}
 465:lib/FreeRTOS/tasks.c **** 		
 466:lib/FreeRTOS/tasks.c **** 		/* We are going to manipulate the task queues to add this task to a
 467:lib/FreeRTOS/tasks.c **** 		ready list, so must make sure no interrupts occur. */
 468:lib/FreeRTOS/tasks.c **** 		taskENTER_CRITICAL();
 275              		.loc 1 468 0
 276 00a0 FFF7FEFF 		bl	vPortEnterCritical
 469:lib/FreeRTOS/tasks.c **** 		{
 470:lib/FreeRTOS/tasks.c **** 			uxCurrentNumberOfTasks++;
 277              		.loc 1 470 0
 278 00a4 374B     		ldr	r3, .L16
 279 00a6 1B68     		ldr	r3, [r3, #0]
 280 00a8 03F10102 		add	r2, r3, #1
 281 00ac 354B     		ldr	r3, .L16
 282 00ae 1A60     		str	r2, [r3, #0]
 471:lib/FreeRTOS/tasks.c **** 			if( pxCurrentTCB == NULL )
 283              		.loc 1 471 0
 284 00b0 354B     		ldr	r3, .L16+4
 285 00b2 1B68     		ldr	r3, [r3, #0]
 286 00b4 002B     		cmp	r3, #0
 287 00b6 09D1     		bne	.L10
 472:lib/FreeRTOS/tasks.c **** 			{
 473:lib/FreeRTOS/tasks.c **** 				/* There are no other tasks, or all the other tasks are in
 474:lib/FreeRTOS/tasks.c **** 				the suspended state - make this the current task. */
 475:lib/FreeRTOS/tasks.c **** 				pxCurrentTCB =  pxNewTCB;
 288              		.loc 1 475 0
 289 00b8 334B     		ldr	r3, .L16+4
 290 00ba BA69     		ldr	r2, [r7, #24]
 291 00bc 1A60     		str	r2, [r3, #0]
 476:lib/FreeRTOS/tasks.c **** 
 477:lib/FreeRTOS/tasks.c **** 				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
 292              		.loc 1 477 0
 293 00be 314B     		ldr	r3, .L16
 294 00c0 1B68     		ldr	r3, [r3, #0]
 295 00c2 012B     		cmp	r3, #1
 296 00c4 0FD1     		bne	.L11
 478:lib/FreeRTOS/tasks.c **** 				{
 479:lib/FreeRTOS/tasks.c **** 					/* This is the first task to be created so do the preliminary
 480:lib/FreeRTOS/tasks.c **** 					initialisation required.  We will not recover if this call
 481:lib/FreeRTOS/tasks.c **** 					fails, but we will report the failure. */
 482:lib/FreeRTOS/tasks.c **** 					prvInitialiseTaskLists();
 297              		.loc 1 482 0
 298 00c6 FFF7FEFF 		bl	prvInitialiseTaskLists
 299 00ca 0CE0     		b	.L11
 300              	.L10:
 483:lib/FreeRTOS/tasks.c **** 				}
 484:lib/FreeRTOS/tasks.c **** 			}
 485:lib/FreeRTOS/tasks.c **** 			else
 486:lib/FreeRTOS/tasks.c **** 			{
 487:lib/FreeRTOS/tasks.c **** 				/* If the scheduler is not already running, make this task the
 488:lib/FreeRTOS/tasks.c **** 				current task if it is the highest priority task to be created
 489:lib/FreeRTOS/tasks.c **** 				so far. */
 490:lib/FreeRTOS/tasks.c **** 				if( xSchedulerRunning == pdFALSE )
 301              		.loc 1 490 0
 302 00cc 2F4B     		ldr	r3, .L16+8
 303 00ce 1B68     		ldr	r3, [r3, #0]
 304 00d0 002B     		cmp	r3, #0
 305 00d2 08D1     		bne	.L11
 491:lib/FreeRTOS/tasks.c **** 				{
 492:lib/FreeRTOS/tasks.c **** 					if( pxCurrentTCB->uxPriority <= uxPriority )
 306              		.loc 1 492 0
 307 00d4 2C4B     		ldr	r3, .L16+4
 308 00d6 1B68     		ldr	r3, [r3, #0]
 309 00d8 DA6A     		ldr	r2, [r3, #44]
 310 00da BB6A     		ldr	r3, [r7, #40]
 311 00dc 9A42     		cmp	r2, r3
 312 00de 02D8     		bhi	.L11
 493:lib/FreeRTOS/tasks.c **** 					{
 494:lib/FreeRTOS/tasks.c **** 						pxCurrentTCB = pxNewTCB;
 313              		.loc 1 494 0
 314 00e0 294B     		ldr	r3, .L16+4
 315 00e2 BA69     		ldr	r2, [r7, #24]
 316 00e4 1A60     		str	r2, [r3, #0]
 317              	.L11:
 495:lib/FreeRTOS/tasks.c **** 					}
 496:lib/FreeRTOS/tasks.c **** 				}
 497:lib/FreeRTOS/tasks.c **** 			}
 498:lib/FreeRTOS/tasks.c **** 
 499:lib/FreeRTOS/tasks.c **** 			/* Remember the top priority to make context switching faster.  Use
 500:lib/FreeRTOS/tasks.c **** 			the priority in pxNewTCB as this has been capped to a valid value. */
 501:lib/FreeRTOS/tasks.c **** 			if( pxNewTCB->uxPriority > uxTopUsedPriority )
 318              		.loc 1 501 0
 319 00e6 BB69     		ldr	r3, [r7, #24]
 320 00e8 DA6A     		ldr	r2, [r3, #44]
 321 00ea 294B     		ldr	r3, .L16+12
 322 00ec 1B68     		ldr	r3, [r3, #0]
 323 00ee 9A42     		cmp	r2, r3
 324 00f0 03D9     		bls	.L12
 502:lib/FreeRTOS/tasks.c **** 			{
 503:lib/FreeRTOS/tasks.c **** 				uxTopUsedPriority = pxNewTCB->uxPriority;
 325              		.loc 1 503 0
 326 00f2 BB69     		ldr	r3, [r7, #24]
 327 00f4 DA6A     		ldr	r2, [r3, #44]
 328 00f6 264B     		ldr	r3, .L16+12
 329 00f8 1A60     		str	r2, [r3, #0]
 330              	.L12:
 504:lib/FreeRTOS/tasks.c **** 			}
 505:lib/FreeRTOS/tasks.c **** 
 506:lib/FreeRTOS/tasks.c **** 			#if ( configUSE_TRACE_FACILITY == 1 )
 507:lib/FreeRTOS/tasks.c **** 			{
 508:lib/FreeRTOS/tasks.c **** 				/* Add a counter into the TCB for tracing only. */
 509:lib/FreeRTOS/tasks.c **** 				pxNewTCB->uxTCBNumber = uxTCBNumber;
 331              		.loc 1 509 0
 332 00fa 264B     		ldr	r3, .L16+16
 333 00fc 1A68     		ldr	r2, [r3, #0]
 334 00fe BB69     		ldr	r3, [r7, #24]
 335 0100 1A64     		str	r2, [r3, #64]
 510:lib/FreeRTOS/tasks.c **** 			}
 511:lib/FreeRTOS/tasks.c **** 			#endif
 512:lib/FreeRTOS/tasks.c **** 			uxTCBNumber++;
 336              		.loc 1 512 0
 337 0102 244B     		ldr	r3, .L16+16
 338 0104 1B68     		ldr	r3, [r3, #0]
 339 0106 03F10102 		add	r2, r3, #1
 340 010a 224B     		ldr	r3, .L16+16
 341 010c 1A60     		str	r2, [r3, #0]
 513:lib/FreeRTOS/tasks.c **** 
 514:lib/FreeRTOS/tasks.c **** 			prvAddTaskToReadyQueue( pxNewTCB );
 342              		.loc 1 514 0
 343 010e BB69     		ldr	r3, [r7, #24]
 344 0110 DA6A     		ldr	r2, [r3, #44]
 345 0112 214B     		ldr	r3, .L16+20
 346 0114 1B68     		ldr	r3, [r3, #0]
 347 0116 9A42     		cmp	r2, r3
 348 0118 03D9     		bls	.L13
 349              		.loc 1 514 0 is_stmt 0 discriminator 1
 350 011a BB69     		ldr	r3, [r7, #24]
 351 011c DA6A     		ldr	r2, [r3, #44]
 352 011e 1E4B     		ldr	r3, .L16+20
 353 0120 1A60     		str	r2, [r3, #0]
 354              	.L13:
 355              		.loc 1 514 0 discriminator 2
 356 0122 BB69     		ldr	r3, [r7, #24]
 357 0124 DA6A     		ldr	r2, [r3, #44]
 358 0126 1346     		mov	r3, r2
 359 0128 4FEA8303 		lsl	r3, r3, #2
 360 012c 9B18     		adds	r3, r3, r2
 361 012e 4FEA8303 		lsl	r3, r3, #2
 362 0132 1A46     		mov	r2, r3
 363 0134 194B     		ldr	r3, .L16+24
 364 0136 D218     		adds	r2, r2, r3
 365 0138 BB69     		ldr	r3, [r7, #24]
 366 013a 03F10403 		add	r3, r3, #4
 367 013e 1046     		mov	r0, r2
 368 0140 1946     		mov	r1, r3
 369 0142 FFF7FEFF 		bl	vListInsertEnd
 515:lib/FreeRTOS/tasks.c **** 
 516:lib/FreeRTOS/tasks.c **** 			xReturn = pdPASS;
 370              		.loc 1 516 0 is_stmt 1 discriminator 2
 371 0146 4FF00103 		mov	r3, #1
 372 014a FB61     		str	r3, [r7, #28]
 517:lib/FreeRTOS/tasks.c **** 			traceTASK_CREATE( pxNewTCB );
 518:lib/FreeRTOS/tasks.c **** 		}
 519:lib/FreeRTOS/tasks.c **** 		taskEXIT_CRITICAL();
 373              		.loc 1 519 0 discriminator 2
 374 014c FFF7FEFF 		bl	vPortExitCritical
 375 0150 02E0     		b	.L14
 376              	.L6:
 377              	.LBE2:
 520:lib/FreeRTOS/tasks.c **** 	}
 521:lib/FreeRTOS/tasks.c **** 	else
 522:lib/FreeRTOS/tasks.c **** 	{
 523:lib/FreeRTOS/tasks.c **** 		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 378              		.loc 1 523 0
 379 0152 4FF0FF33 		mov	r3, #-1
 380 0156 FB61     		str	r3, [r7, #28]
 381              	.L14:
 524:lib/FreeRTOS/tasks.c **** 		traceTASK_CREATE_FAILED();
 525:lib/FreeRTOS/tasks.c **** 	}
 526:lib/FreeRTOS/tasks.c **** 
 527:lib/FreeRTOS/tasks.c **** 	if( xReturn == pdPASS )
 382              		.loc 1 527 0
 383 0158 FB69     		ldr	r3, [r7, #28]
 384 015a 012B     		cmp	r3, #1
 385 015c 0BD1     		bne	.L15
 528:lib/FreeRTOS/tasks.c **** 	{
 529:lib/FreeRTOS/tasks.c **** 		if( xSchedulerRunning != pdFALSE )
 386              		.loc 1 529 0
 387 015e 0B4B     		ldr	r3, .L16+8
 388 0160 1B68     		ldr	r3, [r3, #0]
 389 0162 002B     		cmp	r3, #0
 390 0164 07D0     		beq	.L15
 530:lib/FreeRTOS/tasks.c **** 		{
 531:lib/FreeRTOS/tasks.c **** 			/* If the created task is of a higher priority than the current task
 532:lib/FreeRTOS/tasks.c **** 			then it should run now. */
 533:lib/FreeRTOS/tasks.c **** 			if( pxCurrentTCB->uxPriority < uxPriority )
 391              		.loc 1 533 0
 392 0166 084B     		ldr	r3, .L16+4
 393 0168 1B68     		ldr	r3, [r3, #0]
 394 016a DA6A     		ldr	r2, [r3, #44]
 395 016c BB6A     		ldr	r3, [r7, #40]
 396 016e 9A42     		cmp	r2, r3
 397 0170 01D2     		bcs	.L15
 534:lib/FreeRTOS/tasks.c **** 			{
 535:lib/FreeRTOS/tasks.c **** 				portYIELD_WITHIN_API();
 398              		.loc 1 535 0
 399 0172 FFF7FEFF 		bl	vPortYieldFromISR
 400              	.L15:
 536:lib/FreeRTOS/tasks.c **** 			}
 537:lib/FreeRTOS/tasks.c **** 		}
 538:lib/FreeRTOS/tasks.c **** 	}
 539:lib/FreeRTOS/tasks.c **** 
 540:lib/FreeRTOS/tasks.c **** 	return xReturn;
 401              		.loc 1 540 0
 402 0176 FB69     		ldr	r3, [r7, #28]
 541:lib/FreeRTOS/tasks.c **** }
 403              		.loc 1 541 0
 404 0178 1846     		mov	r0, r3
 405 017a 07F12007 		add	r7, r7, #32
 406 017e BD46     		mov	sp, r7
 407 0180 80BD     		pop	{r7, pc}
 408              	.L17:
 409 0182 00BF     		.align	2
 410              	.L16:
 411 0184 00000000 		.word	uxCurrentNumberOfTasks
 412 0188 00000000 		.word	pxCurrentTCB
 413 018c 00000000 		.word	xSchedulerRunning
 414 0190 00000000 		.word	uxTopUsedPriority
 415 0194 00000000 		.word	uxTCBNumber
 416 0198 00000000 		.word	uxTopReadyPriority
 417 019c 00000000 		.word	pxReadyTasksLists
 418              		.cfi_endproc
 419              	.LFE110:
 421              		.section	.text.vTaskDelete,"ax",%progbits
 422              		.align	2
 423              		.global	vTaskDelete
 424              		.thumb
 425              		.thumb_func
 427              	vTaskDelete:
 428              	.LFB111:
 542:lib/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
 543:lib/FreeRTOS/tasks.c **** 
 544:lib/FreeRTOS/tasks.c **** #if ( INCLUDE_vTaskDelete == 1 )
 545:lib/FreeRTOS/tasks.c **** 
 546:lib/FreeRTOS/tasks.c **** 	void vTaskDelete( xTaskHandle pxTaskToDelete )
 547:lib/FreeRTOS/tasks.c **** 	{
 429              		.loc 1 547 0
 430              		.cfi_startproc
 431              		@ args = 0, pretend = 0, frame = 16
 432              		@ frame_needed = 1, uses_anonymous_args = 0
 433 0000 80B5     		push	{r7, lr}
 434              	.LCFI3:
 435              		.cfi_def_cfa_offset 8
 436 0002 84B0     		sub	sp, sp, #16
 437              	.LCFI4:
 438              		.cfi_def_cfa_offset 24
 439 0004 00AF     		add	r7, sp, #0
 440              		.cfi_offset 14, -4
 441              		.cfi_offset 7, -8
 442              	.LCFI5:
 443              		.cfi_def_cfa_register 7
 444 0006 7860     		str	r0, [r7, #4]
 548:lib/FreeRTOS/tasks.c **** 	tskTCB *pxTCB;
 549:lib/FreeRTOS/tasks.c **** 
 550:lib/FreeRTOS/tasks.c **** 		taskENTER_CRITICAL();
 445              		.loc 1 550 0
 446 0008 FFF7FEFF 		bl	vPortEnterCritical
 551:lib/FreeRTOS/tasks.c **** 		{
 552:lib/FreeRTOS/tasks.c **** 			/* Ensure a yield is performed if the current task is being
 553:lib/FreeRTOS/tasks.c **** 			deleted. */
 554:lib/FreeRTOS/tasks.c **** 			if( pxTaskToDelete == pxCurrentTCB )
 447              		.loc 1 554 0
 448 000c 204B     		ldr	r3, .L24
 449 000e 1B68     		ldr	r3, [r3, #0]
 450 0010 7A68     		ldr	r2, [r7, #4]
 451 0012 9A42     		cmp	r2, r3
 452 0014 02D1     		bne	.L19
 555:lib/FreeRTOS/tasks.c **** 			{
 556:lib/FreeRTOS/tasks.c **** 				pxTaskToDelete = NULL;
 453              		.loc 1 556 0
 454 0016 4FF00003 		mov	r3, #0
 455 001a 7B60     		str	r3, [r7, #4]
 456              	.L19:
 557:lib/FreeRTOS/tasks.c **** 			}
 558:lib/FreeRTOS/tasks.c **** 
 559:lib/FreeRTOS/tasks.c **** 			/* If null is passed in here then we are deleting ourselves. */
 560:lib/FreeRTOS/tasks.c **** 			pxTCB = prvGetTCBFromHandle( pxTaskToDelete );
 457              		.loc 1 560 0
 458 001c 7B68     		ldr	r3, [r7, #4]
 459 001e 002B     		cmp	r3, #0
 460 0020 02D1     		bne	.L20
 461              		.loc 1 560 0 is_stmt 0 discriminator 1
 462 0022 1B4B     		ldr	r3, .L24
 463 0024 1B68     		ldr	r3, [r3, #0]
 464 0026 00E0     		b	.L21
 465              	.L20:
 466              		.loc 1 560 0 discriminator 2
 467 0028 7B68     		ldr	r3, [r7, #4]
 468              	.L21:
 469              		.loc 1 560 0 discriminator 3
 470 002a FB60     		str	r3, [r7, #12]
 561:lib/FreeRTOS/tasks.c **** 
 562:lib/FreeRTOS/tasks.c **** 			/* Remove task from the ready list and place in the	termination list.
 563:lib/FreeRTOS/tasks.c **** 			This will stop the task from be scheduled.  The idle task will check
 564:lib/FreeRTOS/tasks.c **** 			the termination list and free up any memory allocated by the
 565:lib/FreeRTOS/tasks.c **** 			scheduler for the TCB and stack. */
 566:lib/FreeRTOS/tasks.c **** 			vListRemove( &( pxTCB->xGenericListItem ) );
 471              		.loc 1 566 0 is_stmt 1 discriminator 3
 472 002c FB68     		ldr	r3, [r7, #12]
 473 002e 03F10403 		add	r3, r3, #4
 474 0032 1846     		mov	r0, r3
 475 0034 FFF7FEFF 		bl	vListRemove
 567:lib/FreeRTOS/tasks.c **** 
 568:lib/FreeRTOS/tasks.c **** 			/* Is the task waiting on an event also? */
 569:lib/FreeRTOS/tasks.c **** 			if( pxTCB->xEventListItem.pvContainer != NULL )
 476              		.loc 1 569 0 discriminator 3
 477 0038 FB68     		ldr	r3, [r7, #12]
 478 003a 9B6A     		ldr	r3, [r3, #40]
 479 003c 002B     		cmp	r3, #0
 480 003e 05D0     		beq	.L22
 570:lib/FreeRTOS/tasks.c **** 			{
 571:lib/FreeRTOS/tasks.c **** 				vListRemove( &( pxTCB->xEventListItem ) );
 481              		.loc 1 571 0
 482 0040 FB68     		ldr	r3, [r7, #12]
 483 0042 03F11803 		add	r3, r3, #24
 484 0046 1846     		mov	r0, r3
 485 0048 FFF7FEFF 		bl	vListRemove
 486              	.L22:
 572:lib/FreeRTOS/tasks.c **** 			}
 573:lib/FreeRTOS/tasks.c **** 
 574:lib/FreeRTOS/tasks.c **** 			vListInsertEnd( ( xList * ) &xTasksWaitingTermination, &( pxTCB->xGenericListItem ) );
 487              		.loc 1 574 0
 488 004c FB68     		ldr	r3, [r7, #12]
 489 004e 03F10403 		add	r3, r3, #4
 490 0052 1048     		ldr	r0, .L24+4
 491 0054 1946     		mov	r1, r3
 492 0056 FFF7FEFF 		bl	vListInsertEnd
 575:lib/FreeRTOS/tasks.c **** 
 576:lib/FreeRTOS/tasks.c **** 			/* Increment the ucTasksDeleted variable so the idle task knows
 577:lib/FreeRTOS/tasks.c **** 			there is a task that has been deleted and that it should therefore
 578:lib/FreeRTOS/tasks.c **** 			check the xTasksWaitingTermination list. */
 579:lib/FreeRTOS/tasks.c **** 			++uxTasksDeleted;
 493              		.loc 1 579 0
 494 005a 0F4B     		ldr	r3, .L24+8
 495 005c 1B68     		ldr	r3, [r3, #0]
 496 005e 03F10102 		add	r2, r3, #1
 497 0062 0D4B     		ldr	r3, .L24+8
 498 0064 1A60     		str	r2, [r3, #0]
 580:lib/FreeRTOS/tasks.c **** 
 581:lib/FreeRTOS/tasks.c **** 			/* Increment the uxTaskNumberVariable also so kernel aware debuggers
 582:lib/FreeRTOS/tasks.c **** 			can detect that the task lists need re-generating. */
 583:lib/FreeRTOS/tasks.c **** 			uxTCBNumber++;
 499              		.loc 1 583 0
 500 0066 0D4B     		ldr	r3, .L24+12
 501 0068 1B68     		ldr	r3, [r3, #0]
 502 006a 03F10102 		add	r2, r3, #1
 503 006e 0B4B     		ldr	r3, .L24+12
 504 0070 1A60     		str	r2, [r3, #0]
 584:lib/FreeRTOS/tasks.c **** 
 585:lib/FreeRTOS/tasks.c **** 			traceTASK_DELETE( pxTCB );
 586:lib/FreeRTOS/tasks.c **** 		}
 587:lib/FreeRTOS/tasks.c **** 		taskEXIT_CRITICAL();
 505              		.loc 1 587 0
 506 0072 FFF7FEFF 		bl	vPortExitCritical
 588:lib/FreeRTOS/tasks.c **** 
 589:lib/FreeRTOS/tasks.c **** 		/* Force a reschedule if we have just deleted the current task. */
 590:lib/FreeRTOS/tasks.c **** 		if( xSchedulerRunning != pdFALSE )
 507              		.loc 1 590 0
 508 0076 0A4B     		ldr	r3, .L24+16
 509 0078 1B68     		ldr	r3, [r3, #0]
 510 007a 002B     		cmp	r3, #0
 511 007c 04D0     		beq	.L18
 591:lib/FreeRTOS/tasks.c **** 		{
 592:lib/FreeRTOS/tasks.c **** 			if( ( void * ) pxTaskToDelete == NULL )
 512              		.loc 1 592 0
 513 007e 7B68     		ldr	r3, [r7, #4]
 514 0080 002B     		cmp	r3, #0
 515 0082 01D1     		bne	.L18
 593:lib/FreeRTOS/tasks.c **** 			{
 594:lib/FreeRTOS/tasks.c **** 				portYIELD_WITHIN_API();
 516              		.loc 1 594 0
 517 0084 FFF7FEFF 		bl	vPortYieldFromISR
 518              	.L18:
 595:lib/FreeRTOS/tasks.c **** 			}
 596:lib/FreeRTOS/tasks.c **** 		}
 597:lib/FreeRTOS/tasks.c **** 	}
 519              		.loc 1 597 0
 520 0088 07F11007 		add	r7, r7, #16
 521 008c BD46     		mov	sp, r7
 522 008e 80BD     		pop	{r7, pc}
 523              	.L25:
 524              		.align	2
 525              	.L24:
 526 0090 00000000 		.word	pxCurrentTCB
 527 0094 00000000 		.word	xTasksWaitingTermination
 528 0098 00000000 		.word	uxTasksDeleted
 529 009c 00000000 		.word	uxTCBNumber
 530 00a0 00000000 		.word	xSchedulerRunning
 531              		.cfi_endproc
 532              	.LFE111:
 534              		.section	.text.vTaskDelayUntil,"ax",%progbits
 535              		.align	2
 536              		.global	vTaskDelayUntil
 537              		.thumb
 538              		.thumb_func
 540              	vTaskDelayUntil:
 541              	.LFB112:
 598:lib/FreeRTOS/tasks.c **** 
 599:lib/FreeRTOS/tasks.c **** #endif
 600:lib/FreeRTOS/tasks.c **** 
 601:lib/FreeRTOS/tasks.c **** 
 602:lib/FreeRTOS/tasks.c **** 
 603:lib/FreeRTOS/tasks.c **** 
 604:lib/FreeRTOS/tasks.c **** 
 605:lib/FreeRTOS/tasks.c **** 
 606:lib/FreeRTOS/tasks.c **** /*-----------------------------------------------------------
 607:lib/FreeRTOS/tasks.c ****  * TASK CONTROL API documented in task.h
 608:lib/FreeRTOS/tasks.c ****  *----------------------------------------------------------*/
 609:lib/FreeRTOS/tasks.c **** 
 610:lib/FreeRTOS/tasks.c **** #if ( INCLUDE_vTaskDelayUntil == 1 )
 611:lib/FreeRTOS/tasks.c **** 
 612:lib/FreeRTOS/tasks.c **** 	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
 613:lib/FreeRTOS/tasks.c **** 	{
 542              		.loc 1 613 0
 543              		.cfi_startproc
 544              		@ args = 0, pretend = 0, frame = 24
 545              		@ frame_needed = 1, uses_anonymous_args = 0
 546 0000 80B5     		push	{r7, lr}
 547              	.LCFI6:
 548              		.cfi_def_cfa_offset 8
 549 0002 86B0     		sub	sp, sp, #24
 550              	.LCFI7:
 551              		.cfi_def_cfa_offset 32
 552 0004 00AF     		add	r7, sp, #0
 553              		.cfi_offset 14, -4
 554              		.cfi_offset 7, -8
 555              	.LCFI8:
 556              		.cfi_def_cfa_register 7
 557 0006 7860     		str	r0, [r7, #4]
 558 0008 3960     		str	r1, [r7, #0]
 614:lib/FreeRTOS/tasks.c **** 	portTickType xTimeToWake;
 615:lib/FreeRTOS/tasks.c **** 	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;
 559              		.loc 1 615 0
 560 000a 4FF00003 		mov	r3, #0
 561 000e 7B61     		str	r3, [r7, #20]
 616:lib/FreeRTOS/tasks.c **** 
 617:lib/FreeRTOS/tasks.c **** 		configASSERT( pxPreviousWakeTime );
 562              		.loc 1 617 0
 563 0010 7B68     		ldr	r3, [r7, #4]
 564 0012 002B     		cmp	r3, #0
 565 0014 04D1     		bne	.L27
 566              		.loc 1 617 0 is_stmt 0 discriminator 1
 567              	@ 617 "lib/FreeRTOS/tasks.c" 1
 568 0016 4FF0BF00 			mov r0, #191								
 569 001a 80F31188 		msr basepri, r0							
 570              	
 571              	@ 0 "" 2
 572              		.thumb
 573              	.L28:
 574              		.loc 1 617 0 discriminator 2
 575 001e FEE7     		b	.L28
 576              	.L27:
 618:lib/FreeRTOS/tasks.c **** 		configASSERT( ( xTimeIncrement > 0U ) );
 577              		.loc 1 618 0 is_stmt 1
 578 0020 3B68     		ldr	r3, [r7, #0]
 579 0022 002B     		cmp	r3, #0
 580 0024 04D1     		bne	.L29
 581              		.loc 1 618 0 is_stmt 0 discriminator 1
 582              	@ 618 "lib/FreeRTOS/tasks.c" 1
 583 0026 4FF0BF00 			mov r0, #191								
 584 002a 80F31188 		msr basepri, r0							
 585              	
 586              	@ 0 "" 2
 587              		.thumb
 588              	.L30:
 589              		.loc 1 618 0 discriminator 2
 590 002e FEE7     		b	.L30
 591              	.L29:
 619:lib/FreeRTOS/tasks.c **** 
 620:lib/FreeRTOS/tasks.c **** 		vTaskSuspendAll();
 592              		.loc 1 620 0 is_stmt 1
 593 0030 FFF7FEFF 		bl	vTaskSuspendAll
 621:lib/FreeRTOS/tasks.c **** 		{
 622:lib/FreeRTOS/tasks.c **** 			/* Generate the tick time at which the task wants to wake. */
 623:lib/FreeRTOS/tasks.c **** 			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
 594              		.loc 1 623 0
 595 0034 7B68     		ldr	r3, [r7, #4]
 596 0036 1A68     		ldr	r2, [r3, #0]
 597 0038 3B68     		ldr	r3, [r7, #0]
 598 003a D318     		adds	r3, r2, r3
 599 003c 3B61     		str	r3, [r7, #16]
 624:lib/FreeRTOS/tasks.c **** 
 625:lib/FreeRTOS/tasks.c **** 			if( xTickCount < *pxPreviousWakeTime )
 600              		.loc 1 625 0
 601 003e 7B68     		ldr	r3, [r7, #4]
 602 0040 1A68     		ldr	r2, [r3, #0]
 603 0042 1D4B     		ldr	r3, .L36
 604 0044 1B68     		ldr	r3, [r3, #0]
 605 0046 9A42     		cmp	r2, r3
 606 0048 0DD9     		bls	.L31
 626:lib/FreeRTOS/tasks.c **** 			{
 627:lib/FreeRTOS/tasks.c **** 				/* The tick count has overflowed since this function was
 628:lib/FreeRTOS/tasks.c **** 				lasted called.  In this case the only time we should ever
 629:lib/FreeRTOS/tasks.c **** 				actually delay is if the wake time has also	overflowed,
 630:lib/FreeRTOS/tasks.c **** 				and the wake time is greater than the tick time.  When this
 631:lib/FreeRTOS/tasks.c **** 				is the case it is as if neither time had overflowed. */
 632:lib/FreeRTOS/tasks.c **** 				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
 607              		.loc 1 632 0
 608 004a 7B68     		ldr	r3, [r7, #4]
 609 004c 1A68     		ldr	r2, [r3, #0]
 610 004e 3B69     		ldr	r3, [r7, #16]
 611 0050 9A42     		cmp	r2, r3
 612 0052 15D9     		bls	.L32
 613              		.loc 1 632 0 is_stmt 0 discriminator 1
 614 0054 184B     		ldr	r3, .L36
 615 0056 1B68     		ldr	r3, [r3, #0]
 616 0058 3A69     		ldr	r2, [r7, #16]
 617 005a 9A42     		cmp	r2, r3
 618 005c 10D9     		bls	.L32
 633:lib/FreeRTOS/tasks.c **** 				{
 634:lib/FreeRTOS/tasks.c **** 					xShouldDelay = pdTRUE;
 619              		.loc 1 634 0 is_stmt 1
 620 005e 4FF00103 		mov	r3, #1
 621 0062 7B61     		str	r3, [r7, #20]
 622 0064 0CE0     		b	.L32
 623              	.L31:
 635:lib/FreeRTOS/tasks.c **** 				}
 636:lib/FreeRTOS/tasks.c **** 			}
 637:lib/FreeRTOS/tasks.c **** 			else
 638:lib/FreeRTOS/tasks.c **** 			{
 639:lib/FreeRTOS/tasks.c **** 				/* The tick time has not overflowed.  In this case we will
 640:lib/FreeRTOS/tasks.c **** 				delay if either the wake time has overflowed, and/or the
 641:lib/FreeRTOS/tasks.c **** 				tick time is less than the wake time. */
 642:lib/FreeRTOS/tasks.c **** 				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
 624              		.loc 1 642 0
 625 0066 7B68     		ldr	r3, [r7, #4]
 626 0068 1A68     		ldr	r2, [r3, #0]
 627 006a 3B69     		ldr	r3, [r7, #16]
 628 006c 9A42     		cmp	r2, r3
 629 006e 04D8     		bhi	.L33
 630              		.loc 1 642 0 is_stmt 0 discriminator 1
 631 0070 114B     		ldr	r3, .L36
 632 0072 1B68     		ldr	r3, [r3, #0]
 633 0074 3A69     		ldr	r2, [r7, #16]
 634 0076 9A42     		cmp	r2, r3
 635 0078 02D9     		bls	.L32
 636              	.L33:
 643:lib/FreeRTOS/tasks.c **** 				{
 644:lib/FreeRTOS/tasks.c **** 					xShouldDelay = pdTRUE;
 637              		.loc 1 644 0 is_stmt 1
 638 007a 4FF00103 		mov	r3, #1
 639 007e 7B61     		str	r3, [r7, #20]
 640              	.L32:
 645:lib/FreeRTOS/tasks.c **** 				}
 646:lib/FreeRTOS/tasks.c **** 			}
 647:lib/FreeRTOS/tasks.c **** 
 648:lib/FreeRTOS/tasks.c **** 			/* Update the wake time ready for the next call. */
 649:lib/FreeRTOS/tasks.c **** 			*pxPreviousWakeTime = xTimeToWake;
 641              		.loc 1 649 0
 642 0080 7B68     		ldr	r3, [r7, #4]
 643 0082 3A69     		ldr	r2, [r7, #16]
 644 0084 1A60     		str	r2, [r3, #0]
 650:lib/FreeRTOS/tasks.c **** 
 651:lib/FreeRTOS/tasks.c **** 			if( xShouldDelay != pdFALSE )
 645              		.loc 1 651 0
 646 0086 7B69     		ldr	r3, [r7, #20]
 647 0088 002B     		cmp	r3, #0
 648 008a 09D0     		beq	.L34
 652:lib/FreeRTOS/tasks.c **** 			{
 653:lib/FreeRTOS/tasks.c **** 				traceTASK_DELAY_UNTIL();
 654:lib/FreeRTOS/tasks.c **** 
 655:lib/FreeRTOS/tasks.c **** 				/* We must remove ourselves from the ready list before adding
 656:lib/FreeRTOS/tasks.c **** 				ourselves to the blocked list as the same list item is used for
 657:lib/FreeRTOS/tasks.c **** 				both lists. */
 658:lib/FreeRTOS/tasks.c **** 				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
 649              		.loc 1 658 0
 650 008c 0B4B     		ldr	r3, .L36+4
 651 008e 1B68     		ldr	r3, [r3, #0]
 652 0090 03F10403 		add	r3, r3, #4
 653 0094 1846     		mov	r0, r3
 654 0096 FFF7FEFF 		bl	vListRemove
 659:lib/FreeRTOS/tasks.c **** 				prvAddCurrentTaskToDelayedList( xTimeToWake );
 655              		.loc 1 659 0
 656 009a 3869     		ldr	r0, [r7, #16]
 657 009c FFF7FEFF 		bl	prvAddCurrentTaskToDelayedList
 658              	.L34:
 660:lib/FreeRTOS/tasks.c **** 			}
 661:lib/FreeRTOS/tasks.c **** 		}
 662:lib/FreeRTOS/tasks.c **** 		xAlreadyYielded = xTaskResumeAll();
 659              		.loc 1 662 0
 660 00a0 FFF7FEFF 		bl	xTaskResumeAll
 661 00a4 F860     		str	r0, [r7, #12]
 663:lib/FreeRTOS/tasks.c **** 
 664:lib/FreeRTOS/tasks.c **** 		/* Force a reschedule if xTaskResumeAll has not already done so, we may
 665:lib/FreeRTOS/tasks.c **** 		have put ourselves to sleep. */
 666:lib/FreeRTOS/tasks.c **** 		if( xAlreadyYielded == pdFALSE )
 662              		.loc 1 666 0
 663 00a6 FB68     		ldr	r3, [r7, #12]
 664 00a8 002B     		cmp	r3, #0
 665 00aa 01D1     		bne	.L26
 667:lib/FreeRTOS/tasks.c **** 		{
 668:lib/FreeRTOS/tasks.c **** 			portYIELD_WITHIN_API();
 666              		.loc 1 668 0
 667 00ac FFF7FEFF 		bl	vPortYieldFromISR
 668              	.L26:
 669:lib/FreeRTOS/tasks.c **** 		}
 670:lib/FreeRTOS/tasks.c **** 	}
 669              		.loc 1 670 0
 670 00b0 07F11807 		add	r7, r7, #24
 671 00b4 BD46     		mov	sp, r7
 672 00b6 80BD     		pop	{r7, pc}
 673              	.L37:
 674              		.align	2
 675              	.L36:
 676 00b8 00000000 		.word	xTickCount
 677 00bc 00000000 		.word	pxCurrentTCB
 678              		.cfi_endproc
 679              	.LFE112:
 681              		.section	.text.vTaskDelay,"ax",%progbits
 682              		.align	2
 683              		.global	vTaskDelay
 684              		.thumb
 685              		.thumb_func
 687              	vTaskDelay:
 688              	.LFB113:
 671:lib/FreeRTOS/tasks.c **** 
 672:lib/FreeRTOS/tasks.c **** #endif
 673:lib/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
 674:lib/FreeRTOS/tasks.c **** 
 675:lib/FreeRTOS/tasks.c **** #if ( INCLUDE_vTaskDelay == 1 )
 676:lib/FreeRTOS/tasks.c **** 
 677:lib/FreeRTOS/tasks.c **** 	void vTaskDelay( portTickType xTicksToDelay )
 678:lib/FreeRTOS/tasks.c **** 	{
 689              		.loc 1 678 0
 690              		.cfi_startproc
 691              		@ args = 0, pretend = 0, frame = 16
 692              		@ frame_needed = 1, uses_anonymous_args = 0
 693 0000 80B5     		push	{r7, lr}
 694              	.LCFI9:
 695              		.cfi_def_cfa_offset 8
 696 0002 84B0     		sub	sp, sp, #16
 697              	.LCFI10:
 698              		.cfi_def_cfa_offset 24
 699 0004 00AF     		add	r7, sp, #0
 700              		.cfi_offset 14, -4
 701              		.cfi_offset 7, -8
 702              	.LCFI11:
 703              		.cfi_def_cfa_register 7
 704 0006 7860     		str	r0, [r7, #4]
 679:lib/FreeRTOS/tasks.c **** 	portTickType xTimeToWake;
 680:lib/FreeRTOS/tasks.c **** 	signed portBASE_TYPE xAlreadyYielded = pdFALSE;
 705              		.loc 1 680 0
 706 0008 4FF00003 		mov	r3, #0
 707 000c FB60     		str	r3, [r7, #12]
 681:lib/FreeRTOS/tasks.c **** 
 682:lib/FreeRTOS/tasks.c **** 		/* A delay time of zero just forces a reschedule. */
 683:lib/FreeRTOS/tasks.c **** 		if( xTicksToDelay > ( portTickType ) 0U )
 708              		.loc 1 683 0
 709 000e 7B68     		ldr	r3, [r7, #4]
 710 0010 002B     		cmp	r3, #0
 711 0012 13D0     		beq	.L39
 684:lib/FreeRTOS/tasks.c **** 		{
 685:lib/FreeRTOS/tasks.c **** 			vTaskSuspendAll();
 712              		.loc 1 685 0
 713 0014 FFF7FEFF 		bl	vTaskSuspendAll
 686:lib/FreeRTOS/tasks.c **** 			{
 687:lib/FreeRTOS/tasks.c **** 				traceTASK_DELAY();
 688:lib/FreeRTOS/tasks.c **** 
 689:lib/FreeRTOS/tasks.c **** 				/* A task that is removed from the event list while the
 690:lib/FreeRTOS/tasks.c **** 				scheduler is suspended will not get placed in the ready
 691:lib/FreeRTOS/tasks.c **** 				list or removed from the blocked list until the scheduler
 692:lib/FreeRTOS/tasks.c **** 				is resumed.
 693:lib/FreeRTOS/tasks.c **** 
 694:lib/FreeRTOS/tasks.c **** 				This task cannot be in an event list as it is the currently
 695:lib/FreeRTOS/tasks.c **** 				executing task. */
 696:lib/FreeRTOS/tasks.c **** 
 697:lib/FreeRTOS/tasks.c **** 				/* Calculate the time to wake - this may overflow but this is
 698:lib/FreeRTOS/tasks.c **** 				not a problem. */
 699:lib/FreeRTOS/tasks.c **** 				xTimeToWake = xTickCount + xTicksToDelay;
 714              		.loc 1 699 0
 715 0018 0D4B     		ldr	r3, .L41
 716 001a 1A68     		ldr	r2, [r3, #0]
 717 001c 7B68     		ldr	r3, [r7, #4]
 718 001e D318     		adds	r3, r2, r3
 719 0020 BB60     		str	r3, [r7, #8]
 700:lib/FreeRTOS/tasks.c **** 
 701:lib/FreeRTOS/tasks.c **** 				/* We must remove ourselves from the ready list before adding
 702:lib/FreeRTOS/tasks.c **** 				ourselves to the blocked list as the same list item is used for
 703:lib/FreeRTOS/tasks.c **** 				both lists. */
 704:lib/FreeRTOS/tasks.c **** 				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
 720              		.loc 1 704 0
 721 0022 0C4B     		ldr	r3, .L41+4
 722 0024 1B68     		ldr	r3, [r3, #0]
 723 0026 03F10403 		add	r3, r3, #4
 724 002a 1846     		mov	r0, r3
 725 002c FFF7FEFF 		bl	vListRemove
 705:lib/FreeRTOS/tasks.c **** 				prvAddCurrentTaskToDelayedList( xTimeToWake );
 726              		.loc 1 705 0
 727 0030 B868     		ldr	r0, [r7, #8]
 728 0032 FFF7FEFF 		bl	prvAddCurrentTaskToDelayedList
 706:lib/FreeRTOS/tasks.c **** 			}
 707:lib/FreeRTOS/tasks.c **** 			xAlreadyYielded = xTaskResumeAll();
 729              		.loc 1 707 0
 730 0036 FFF7FEFF 		bl	xTaskResumeAll
 731 003a F860     		str	r0, [r7, #12]
 732              	.L39:
 708:lib/FreeRTOS/tasks.c **** 		}
 709:lib/FreeRTOS/tasks.c **** 
 710:lib/FreeRTOS/tasks.c **** 		/* Force a reschedule if xTaskResumeAll has not already done so, we may
 711:lib/FreeRTOS/tasks.c **** 		have put ourselves to sleep. */
 712:lib/FreeRTOS/tasks.c **** 		if( xAlreadyYielded == pdFALSE )
 733              		.loc 1 712 0
 734 003c FB68     		ldr	r3, [r7, #12]
 735 003e 002B     		cmp	r3, #0
 736 0040 01D1     		bne	.L38
 713:lib/FreeRTOS/tasks.c **** 		{
 714:lib/FreeRTOS/tasks.c **** 			portYIELD_WITHIN_API();
 737              		.loc 1 714 0
 738 0042 FFF7FEFF 		bl	vPortYieldFromISR
 739              	.L38:
 715:lib/FreeRTOS/tasks.c **** 		}
 716:lib/FreeRTOS/tasks.c **** 	}
 740              		.loc 1 716 0
 741 0046 07F11007 		add	r7, r7, #16
 742 004a BD46     		mov	sp, r7
 743 004c 80BD     		pop	{r7, pc}
 744              	.L42:
 745 004e 00BF     		.align	2
 746              	.L41:
 747 0050 00000000 		.word	xTickCount
 748 0054 00000000 		.word	pxCurrentTCB
 749              		.cfi_endproc
 750              	.LFE113:
 752              		.section	.text.uxTaskPriorityGet,"ax",%progbits
 753              		.align	2
 754              		.global	uxTaskPriorityGet
 755              		.thumb
 756              		.thumb_func
 758              	uxTaskPriorityGet:
 759              	.LFB114:
 717:lib/FreeRTOS/tasks.c **** 
 718:lib/FreeRTOS/tasks.c **** #endif
 719:lib/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
 720:lib/FreeRTOS/tasks.c **** 
 721:lib/FreeRTOS/tasks.c **** #if ( INCLUDE_uxTaskPriorityGet == 1 )
 722:lib/FreeRTOS/tasks.c **** 
 723:lib/FreeRTOS/tasks.c **** 	unsigned portBASE_TYPE uxTaskPriorityGet( xTaskHandle pxTask )
 724:lib/FreeRTOS/tasks.c **** 	{
 760              		.loc 1 724 0
 761              		.cfi_startproc
 762              		@ args = 0, pretend = 0, frame = 16
 763              		@ frame_needed = 1, uses_anonymous_args = 0
 764 0000 80B5     		push	{r7, lr}
 765              	.LCFI12:
 766              		.cfi_def_cfa_offset 8
 767 0002 84B0     		sub	sp, sp, #16
 768              	.LCFI13:
 769              		.cfi_def_cfa_offset 24
 770 0004 00AF     		add	r7, sp, #0
 771              		.cfi_offset 14, -4
 772              		.cfi_offset 7, -8
 773              	.LCFI14:
 774              		.cfi_def_cfa_register 7
 775 0006 7860     		str	r0, [r7, #4]
 725:lib/FreeRTOS/tasks.c **** 	tskTCB *pxTCB;
 726:lib/FreeRTOS/tasks.c **** 	unsigned portBASE_TYPE uxReturn;
 727:lib/FreeRTOS/tasks.c **** 
 728:lib/FreeRTOS/tasks.c **** 		taskENTER_CRITICAL();
 776              		.loc 1 728 0
 777 0008 FFF7FEFF 		bl	vPortEnterCritical
 729:lib/FreeRTOS/tasks.c **** 		{
 730:lib/FreeRTOS/tasks.c **** 			/* If null is passed in here then we are changing the
 731:lib/FreeRTOS/tasks.c **** 			priority of the calling function. */
 732:lib/FreeRTOS/tasks.c **** 			pxTCB = prvGetTCBFromHandle( pxTask );
 778              		.loc 1 732 0
 779 000c 7B68     		ldr	r3, [r7, #4]
 780 000e 002B     		cmp	r3, #0
 781 0010 02D1     		bne	.L44
 782              		.loc 1 732 0 is_stmt 0 discriminator 1
 783 0012 084B     		ldr	r3, .L46
 784 0014 1B68     		ldr	r3, [r3, #0]
 785 0016 00E0     		b	.L45
 786              	.L44:
 787              		.loc 1 732 0 discriminator 2
 788 0018 7B68     		ldr	r3, [r7, #4]
 789              	.L45:
 790              		.loc 1 732 0 discriminator 3
 791 001a FB60     		str	r3, [r7, #12]
 733:lib/FreeRTOS/tasks.c **** 			uxReturn = pxTCB->uxPriority;
 792              		.loc 1 733 0 is_stmt 1 discriminator 3
 793 001c FB68     		ldr	r3, [r7, #12]
 794 001e DB6A     		ldr	r3, [r3, #44]
 795 0020 BB60     		str	r3, [r7, #8]
 734:lib/FreeRTOS/tasks.c **** 		}
 735:lib/FreeRTOS/tasks.c **** 		taskEXIT_CRITICAL();
 796              		.loc 1 735 0 discriminator 3
 797 0022 FFF7FEFF 		bl	vPortExitCritical
 736:lib/FreeRTOS/tasks.c **** 
 737:lib/FreeRTOS/tasks.c **** 		return uxReturn;
 798              		.loc 1 737 0 discriminator 3
 799 0026 BB68     		ldr	r3, [r7, #8]
 738:lib/FreeRTOS/tasks.c **** 	}
 800              		.loc 1 738 0 discriminator 3
 801 0028 1846     		mov	r0, r3
 802 002a 07F11007 		add	r7, r7, #16
 803 002e BD46     		mov	sp, r7
 804 0030 80BD     		pop	{r7, pc}
 805              	.L47:
 806 0032 00BF     		.align	2
 807              	.L46:
 808 0034 00000000 		.word	pxCurrentTCB
 809              		.cfi_endproc
 810              	.LFE114:
 812              		.section	.text.vTaskPrioritySet,"ax",%progbits
 813              		.align	2
 814              		.global	vTaskPrioritySet
 815              		.thumb
 816              		.thumb_func
 818              	vTaskPrioritySet:
 819              	.LFB115:
 739:lib/FreeRTOS/tasks.c **** 
 740:lib/FreeRTOS/tasks.c **** #endif
 741:lib/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
 742:lib/FreeRTOS/tasks.c **** 
 743:lib/FreeRTOS/tasks.c **** #if ( INCLUDE_vTaskPrioritySet == 1 )
 744:lib/FreeRTOS/tasks.c **** 
 745:lib/FreeRTOS/tasks.c **** 	void vTaskPrioritySet( xTaskHandle pxTask, unsigned portBASE_TYPE uxNewPriority )
 746:lib/FreeRTOS/tasks.c **** 	{
 820              		.loc 1 746 0
 821              		.cfi_startproc
 822              		@ args = 0, pretend = 0, frame = 24
 823              		@ frame_needed = 1, uses_anonymous_args = 0
 824 0000 80B5     		push	{r7, lr}
 825              	.LCFI15:
 826              		.cfi_def_cfa_offset 8
 827 0002 86B0     		sub	sp, sp, #24
 828              	.LCFI16:
 829              		.cfi_def_cfa_offset 32
 830 0004 00AF     		add	r7, sp, #0
 831              		.cfi_offset 14, -4
 832              		.cfi_offset 7, -8
 833              	.LCFI17:
 834              		.cfi_def_cfa_register 7
 835 0006 7860     		str	r0, [r7, #4]
 836 0008 3960     		str	r1, [r7, #0]
 747:lib/FreeRTOS/tasks.c **** 	tskTCB *pxTCB;
 748:lib/FreeRTOS/tasks.c **** 	unsigned portBASE_TYPE uxCurrentPriority;
 749:lib/FreeRTOS/tasks.c **** 	portBASE_TYPE xYieldRequired = pdFALSE;
 837              		.loc 1 749 0
 838 000a 4FF00003 		mov	r3, #0
 839 000e 7B61     		str	r3, [r7, #20]
 750:lib/FreeRTOS/tasks.c **** 
 751:lib/FreeRTOS/tasks.c **** 		configASSERT( ( uxNewPriority < configMAX_PRIORITIES ) );
 840              		.loc 1 751 0
 841 0010 3B68     		ldr	r3, [r7, #0]
 842 0012 042B     		cmp	r3, #4
 843 0014 04D9     		bls	.L49
 844              		.loc 1 751 0 is_stmt 0 discriminator 1
 845              	@ 751 "lib/FreeRTOS/tasks.c" 1
 846 0016 4FF0BF00 			mov r0, #191								
 847 001a 80F31188 		msr basepri, r0							
 848              	
 849              	@ 0 "" 2
 850              		.thumb
 851              	.L50:
 852              		.loc 1 751 0 discriminator 2
 853 001e FEE7     		b	.L50
 854              	.L49:
 752:lib/FreeRTOS/tasks.c **** 
 753:lib/FreeRTOS/tasks.c **** 		/* Ensure the new priority is valid. */
 754:lib/FreeRTOS/tasks.c **** 		if( uxNewPriority >= configMAX_PRIORITIES )
 855              		.loc 1 754 0 is_stmt 1
 856 0020 3B68     		ldr	r3, [r7, #0]
 857 0022 042B     		cmp	r3, #4
 858 0024 02D9     		bls	.L51
 755:lib/FreeRTOS/tasks.c **** 		{
 756:lib/FreeRTOS/tasks.c **** 			uxNewPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
 859              		.loc 1 756 0
 860 0026 4FF00403 		mov	r3, #4
 861 002a 3B60     		str	r3, [r7, #0]
 862              	.L51:
 757:lib/FreeRTOS/tasks.c **** 		}
 758:lib/FreeRTOS/tasks.c **** 
 759:lib/FreeRTOS/tasks.c **** 		taskENTER_CRITICAL();
 863              		.loc 1 759 0
 864 002c FFF7FEFF 		bl	vPortEnterCritical
 760:lib/FreeRTOS/tasks.c **** 		{
 761:lib/FreeRTOS/tasks.c **** 			if( pxTask == pxCurrentTCB )
 865              		.loc 1 761 0
 866 0030 394B     		ldr	r3, .L61
 867 0032 1B68     		ldr	r3, [r3, #0]
 868 0034 7A68     		ldr	r2, [r7, #4]
 869 0036 9A42     		cmp	r2, r3
 870 0038 02D1     		bne	.L52
 762:lib/FreeRTOS/tasks.c **** 			{
 763:lib/FreeRTOS/tasks.c **** 				pxTask = NULL;
 871              		.loc 1 763 0
 872 003a 4FF00003 		mov	r3, #0
 873 003e 7B60     		str	r3, [r7, #4]
 874              	.L52:
 764:lib/FreeRTOS/tasks.c **** 			}
 765:lib/FreeRTOS/tasks.c **** 
 766:lib/FreeRTOS/tasks.c **** 			/* If null is passed in here then we are changing the
 767:lib/FreeRTOS/tasks.c **** 			priority of the calling function. */
 768:lib/FreeRTOS/tasks.c **** 			pxTCB = prvGetTCBFromHandle( pxTask );
 875              		.loc 1 768 0
 876 0040 7B68     		ldr	r3, [r7, #4]
 877 0042 002B     		cmp	r3, #0
 878 0044 02D1     		bne	.L53
 879              		.loc 1 768 0 is_stmt 0 discriminator 1
 880 0046 344B     		ldr	r3, .L61
 881 0048 1B68     		ldr	r3, [r3, #0]
 882 004a 00E0     		b	.L54
 883              	.L53:
 884              		.loc 1 768 0 discriminator 2
 885 004c 7B68     		ldr	r3, [r7, #4]
 886              	.L54:
 887              		.loc 1 768 0 discriminator 3
 888 004e 3B61     		str	r3, [r7, #16]
 769:lib/FreeRTOS/tasks.c **** 
 770:lib/FreeRTOS/tasks.c **** 			traceTASK_PRIORITY_SET( pxTCB, uxNewPriority );
 771:lib/FreeRTOS/tasks.c **** 
 772:lib/FreeRTOS/tasks.c **** 			#if ( configUSE_MUTEXES == 1 )
 773:lib/FreeRTOS/tasks.c **** 			{
 774:lib/FreeRTOS/tasks.c **** 				uxCurrentPriority = pxTCB->uxBasePriority;
 889              		.loc 1 774 0 is_stmt 1 discriminator 3
 890 0050 3B69     		ldr	r3, [r7, #16]
 891 0052 9B6C     		ldr	r3, [r3, #72]
 892 0054 FB60     		str	r3, [r7, #12]
 775:lib/FreeRTOS/tasks.c **** 			}
 776:lib/FreeRTOS/tasks.c **** 			#else
 777:lib/FreeRTOS/tasks.c **** 			{
 778:lib/FreeRTOS/tasks.c **** 				uxCurrentPriority = pxTCB->uxPriority;
 779:lib/FreeRTOS/tasks.c **** 			}
 780:lib/FreeRTOS/tasks.c **** 			#endif
 781:lib/FreeRTOS/tasks.c **** 
 782:lib/FreeRTOS/tasks.c **** 			if( uxCurrentPriority != uxNewPriority )
 893              		.loc 1 782 0 discriminator 3
 894 0056 FA68     		ldr	r2, [r7, #12]
 895 0058 3B68     		ldr	r3, [r7, #0]
 896 005a 9A42     		cmp	r2, r3
 897 005c 56D0     		beq	.L55
 783:lib/FreeRTOS/tasks.c **** 			{
 784:lib/FreeRTOS/tasks.c **** 				/* The priority change may have readied a task of higher
 785:lib/FreeRTOS/tasks.c **** 				priority than the calling task. */
 786:lib/FreeRTOS/tasks.c **** 				if( uxNewPriority > uxCurrentPriority )
 898              		.loc 1 786 0
 899 005e 3A68     		ldr	r2, [r7, #0]
 900 0060 FB68     		ldr	r3, [r7, #12]
 901 0062 9A42     		cmp	r2, r3
 902 0064 06D9     		bls	.L56
 787:lib/FreeRTOS/tasks.c **** 				{
 788:lib/FreeRTOS/tasks.c **** 					if( pxTask != NULL )
 903              		.loc 1 788 0
 904 0066 7B68     		ldr	r3, [r7, #4]
 905 0068 002B     		cmp	r3, #0
 906 006a 09D0     		beq	.L57
 789:lib/FreeRTOS/tasks.c **** 					{
 790:lib/FreeRTOS/tasks.c **** 						/* The priority of another task is being raised.  If we
 791:lib/FreeRTOS/tasks.c **** 						were raising the priority of the currently running task
 792:lib/FreeRTOS/tasks.c **** 						there would be no need to switch as it must have already
 793:lib/FreeRTOS/tasks.c **** 						been the highest priority task. */
 794:lib/FreeRTOS/tasks.c **** 						xYieldRequired = pdTRUE;
 907              		.loc 1 794 0
 908 006c 4FF00103 		mov	r3, #1
 909 0070 7B61     		str	r3, [r7, #20]
 910 0072 05E0     		b	.L57
 911              	.L56:
 795:lib/FreeRTOS/tasks.c **** 					}
 796:lib/FreeRTOS/tasks.c **** 				}
 797:lib/FreeRTOS/tasks.c **** 				else if( pxTask == NULL )
 912              		.loc 1 797 0
 913 0074 7B68     		ldr	r3, [r7, #4]
 914 0076 002B     		cmp	r3, #0
 915 0078 02D1     		bne	.L57
 798:lib/FreeRTOS/tasks.c **** 				{
 799:lib/FreeRTOS/tasks.c **** 					/* Setting our own priority down means there may now be another
 800:lib/FreeRTOS/tasks.c **** 					task of higher priority that is ready to execute. */
 801:lib/FreeRTOS/tasks.c **** 					xYieldRequired = pdTRUE;
 916              		.loc 1 801 0
 917 007a 4FF00103 		mov	r3, #1
 918 007e 7B61     		str	r3, [r7, #20]
 919              	.L57:
 802:lib/FreeRTOS/tasks.c **** 				}
 803:lib/FreeRTOS/tasks.c **** 
 804:lib/FreeRTOS/tasks.c **** 
 805:lib/FreeRTOS/tasks.c **** 
 806:lib/FreeRTOS/tasks.c **** 				#if ( configUSE_MUTEXES == 1 )
 807:lib/FreeRTOS/tasks.c **** 				{
 808:lib/FreeRTOS/tasks.c **** 					/* Only change the priority being used if the task is not
 809:lib/FreeRTOS/tasks.c **** 					currently using an inherited priority. */
 810:lib/FreeRTOS/tasks.c **** 					if( pxTCB->uxBasePriority == pxTCB->uxPriority )
 920              		.loc 1 810 0
 921 0080 3B69     		ldr	r3, [r7, #16]
 922 0082 9A6C     		ldr	r2, [r3, #72]
 923 0084 3B69     		ldr	r3, [r7, #16]
 924 0086 DB6A     		ldr	r3, [r3, #44]
 925 0088 9A42     		cmp	r2, r3
 926 008a 02D1     		bne	.L58
 811:lib/FreeRTOS/tasks.c **** 					{
 812:lib/FreeRTOS/tasks.c **** 						pxTCB->uxPriority = uxNewPriority;
 927              		.loc 1 812 0
 928 008c 3B69     		ldr	r3, [r7, #16]
 929 008e 3A68     		ldr	r2, [r7, #0]
 930 0090 DA62     		str	r2, [r3, #44]
 931              	.L58:
 813:lib/FreeRTOS/tasks.c **** 					}
 814:lib/FreeRTOS/tasks.c **** 
 815:lib/FreeRTOS/tasks.c **** 					/* The base priority gets set whatever. */
 816:lib/FreeRTOS/tasks.c **** 					pxTCB->uxBasePriority = uxNewPriority;
 932              		.loc 1 816 0
 933 0092 3B69     		ldr	r3, [r7, #16]
 934 0094 3A68     		ldr	r2, [r7, #0]
 935 0096 9A64     		str	r2, [r3, #72]
 817:lib/FreeRTOS/tasks.c **** 				}
 818:lib/FreeRTOS/tasks.c **** 				#else
 819:lib/FreeRTOS/tasks.c **** 				{
 820:lib/FreeRTOS/tasks.c **** 					pxTCB->uxPriority = uxNewPriority;
 821:lib/FreeRTOS/tasks.c **** 				}
 822:lib/FreeRTOS/tasks.c **** 				#endif
 823:lib/FreeRTOS/tasks.c **** 
 824:lib/FreeRTOS/tasks.c **** 				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( configMAX_PRIORITIES - ( portTickType ) 
 936              		.loc 1 824 0
 937 0098 3B68     		ldr	r3, [r7, #0]
 938 009a C3F10502 		rsb	r2, r3, #5
 939 009e 3B69     		ldr	r3, [r7, #16]
 940 00a0 9A61     		str	r2, [r3, #24]
 825:lib/FreeRTOS/tasks.c **** 
 826:lib/FreeRTOS/tasks.c **** 				/* If the task is in the blocked or suspended list we need do
 827:lib/FreeRTOS/tasks.c **** 				nothing more than change it's priority variable. However, if
 828:lib/FreeRTOS/tasks.c **** 				the task is in a ready list it needs to be removed and placed
 829:lib/FreeRTOS/tasks.c **** 				in the queue appropriate to its new priority. */
 830:lib/FreeRTOS/tasks.c **** 				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxCurrentPriority ] ), &( pxTCB->xGenericLis
 941              		.loc 1 830 0
 942 00a2 3B69     		ldr	r3, [r7, #16]
 943 00a4 5969     		ldr	r1, [r3, #20]
 944 00a6 FA68     		ldr	r2, [r7, #12]
 945 00a8 1346     		mov	r3, r2
 946 00aa 4FEA8303 		lsl	r3, r3, #2
 947 00ae 9B18     		adds	r3, r3, r2
 948 00b0 4FEA8303 		lsl	r3, r3, #2
 949 00b4 1A46     		mov	r2, r3
 950 00b6 194B     		ldr	r3, .L61+4
 951 00b8 D318     		adds	r3, r2, r3
 952 00ba 9942     		cmp	r1, r3
 953 00bc 21D1     		bne	.L59
 831:lib/FreeRTOS/tasks.c **** 				{
 832:lib/FreeRTOS/tasks.c **** 					/* The task is currently in its ready list - remove before adding
 833:lib/FreeRTOS/tasks.c **** 					it to it's new ready list.  As we are in a critical section we
 834:lib/FreeRTOS/tasks.c **** 					can do this even if the scheduler is suspended. */
 835:lib/FreeRTOS/tasks.c **** 					vListRemove( &( pxTCB->xGenericListItem ) );
 954              		.loc 1 835 0
 955 00be 3B69     		ldr	r3, [r7, #16]
 956 00c0 03F10403 		add	r3, r3, #4
 957 00c4 1846     		mov	r0, r3
 958 00c6 FFF7FEFF 		bl	vListRemove
 836:lib/FreeRTOS/tasks.c **** 					prvAddTaskToReadyQueue( pxTCB );
 959              		.loc 1 836 0
 960 00ca 3B69     		ldr	r3, [r7, #16]
 961 00cc DA6A     		ldr	r2, [r3, #44]
 962 00ce 144B     		ldr	r3, .L61+8
 963 00d0 1B68     		ldr	r3, [r3, #0]
 964 00d2 9A42     		cmp	r2, r3
 965 00d4 03D9     		bls	.L60
 966              		.loc 1 836 0 is_stmt 0 discriminator 1
 967 00d6 3B69     		ldr	r3, [r7, #16]
 968 00d8 DA6A     		ldr	r2, [r3, #44]
 969 00da 114B     		ldr	r3, .L61+8
 970 00dc 1A60     		str	r2, [r3, #0]
 971              	.L60:
 972              		.loc 1 836 0 discriminator 2
 973 00de 3B69     		ldr	r3, [r7, #16]
 974 00e0 DA6A     		ldr	r2, [r3, #44]
 975 00e2 1346     		mov	r3, r2
 976 00e4 4FEA8303 		lsl	r3, r3, #2
 977 00e8 9B18     		adds	r3, r3, r2
 978 00ea 4FEA8303 		lsl	r3, r3, #2
 979 00ee 1A46     		mov	r2, r3
 980 00f0 0A4B     		ldr	r3, .L61+4
 981 00f2 D218     		adds	r2, r2, r3
 982 00f4 3B69     		ldr	r3, [r7, #16]
 983 00f6 03F10403 		add	r3, r3, #4
 984 00fa 1046     		mov	r0, r2
 985 00fc 1946     		mov	r1, r3
 986 00fe FFF7FEFF 		bl	vListInsertEnd
 987              	.L59:
 837:lib/FreeRTOS/tasks.c **** 				}
 838:lib/FreeRTOS/tasks.c **** 
 839:lib/FreeRTOS/tasks.c **** 				if( xYieldRequired == pdTRUE )
 988              		.loc 1 839 0 is_stmt 1
 989 0102 7B69     		ldr	r3, [r7, #20]
 990 0104 012B     		cmp	r3, #1
 991 0106 01D1     		bne	.L55
 840:lib/FreeRTOS/tasks.c **** 				{
 841:lib/FreeRTOS/tasks.c **** 					portYIELD_WITHIN_API();
 992              		.loc 1 841 0
 993 0108 FFF7FEFF 		bl	vPortYieldFromISR
 994              	.L55:
 842:lib/FreeRTOS/tasks.c **** 				}
 843:lib/FreeRTOS/tasks.c **** 			}
 844:lib/FreeRTOS/tasks.c **** 		}
 845:lib/FreeRTOS/tasks.c **** 		taskEXIT_CRITICAL();
 995              		.loc 1 845 0
 996 010c FFF7FEFF 		bl	vPortExitCritical
 846:lib/FreeRTOS/tasks.c **** 	}
 997              		.loc 1 846 0
 998 0110 07F11807 		add	r7, r7, #24
 999 0114 BD46     		mov	sp, r7
 1000 0116 80BD     		pop	{r7, pc}
 1001              	.L62:
 1002              		.align	2
 1003              	.L61:
 1004 0118 00000000 		.word	pxCurrentTCB
 1005 011c 00000000 		.word	pxReadyTasksLists
 1006 0120 00000000 		.word	uxTopReadyPriority
 1007              		.cfi_endproc
 1008              	.LFE115:
 1010              		.section	.text.vTaskSuspend,"ax",%progbits
 1011              		.align	2
 1012              		.global	vTaskSuspend
 1013              		.thumb
 1014              		.thumb_func
 1016              	vTaskSuspend:
 1017              	.LFB116:
 847:lib/FreeRTOS/tasks.c **** 
 848:lib/FreeRTOS/tasks.c **** #endif
 849:lib/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
 850:lib/FreeRTOS/tasks.c **** 
 851:lib/FreeRTOS/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
 852:lib/FreeRTOS/tasks.c **** 
 853:lib/FreeRTOS/tasks.c **** 	void vTaskSuspend( xTaskHandle pxTaskToSuspend )
 854:lib/FreeRTOS/tasks.c **** 	{
 1018              		.loc 1 854 0
 1019              		.cfi_startproc
 1020              		@ args = 0, pretend = 0, frame = 16
 1021              		@ frame_needed = 1, uses_anonymous_args = 0
 1022 0000 80B5     		push	{r7, lr}
 1023              	.LCFI18:
 1024              		.cfi_def_cfa_offset 8
 1025 0002 84B0     		sub	sp, sp, #16
 1026              	.LCFI19:
 1027              		.cfi_def_cfa_offset 24
 1028 0004 00AF     		add	r7, sp, #0
 1029              		.cfi_offset 14, -4
 1030              		.cfi_offset 7, -8
 1031              	.LCFI20:
 1032              		.cfi_def_cfa_register 7
 1033 0006 7860     		str	r0, [r7, #4]
 855:lib/FreeRTOS/tasks.c **** 	tskTCB *pxTCB;
 856:lib/FreeRTOS/tasks.c **** 
 857:lib/FreeRTOS/tasks.c **** 		taskENTER_CRITICAL();
 1034              		.loc 1 857 0
 1035 0008 FFF7FEFF 		bl	vPortEnterCritical
 858:lib/FreeRTOS/tasks.c **** 		{
 859:lib/FreeRTOS/tasks.c **** 			/* Ensure a yield is performed if the current task is being
 860:lib/FreeRTOS/tasks.c **** 			suspended. */
 861:lib/FreeRTOS/tasks.c **** 			if( pxTaskToSuspend == pxCurrentTCB )
 1036              		.loc 1 861 0
 1037 000c 214B     		ldr	r3, .L71
 1038 000e 1B68     		ldr	r3, [r3, #0]
 1039 0010 7A68     		ldr	r2, [r7, #4]
 1040 0012 9A42     		cmp	r2, r3
 1041 0014 02D1     		bne	.L64
 862:lib/FreeRTOS/tasks.c **** 			{
 863:lib/FreeRTOS/tasks.c **** 				pxTaskToSuspend = NULL;
 1042              		.loc 1 863 0
 1043 0016 4FF00003 		mov	r3, #0
 1044 001a 7B60     		str	r3, [r7, #4]
 1045              	.L64:
 864:lib/FreeRTOS/tasks.c **** 			}
 865:lib/FreeRTOS/tasks.c **** 
 866:lib/FreeRTOS/tasks.c **** 			/* If null is passed in here then we are suspending ourselves. */
 867:lib/FreeRTOS/tasks.c **** 			pxTCB = prvGetTCBFromHandle( pxTaskToSuspend );
 1046              		.loc 1 867 0
 1047 001c 7B68     		ldr	r3, [r7, #4]
 1048 001e 002B     		cmp	r3, #0
 1049 0020 02D1     		bne	.L65
 1050              		.loc 1 867 0 is_stmt 0 discriminator 1
 1051 0022 1C4B     		ldr	r3, .L71
 1052 0024 1B68     		ldr	r3, [r3, #0]
 1053 0026 00E0     		b	.L66
 1054              	.L65:
 1055              		.loc 1 867 0 discriminator 2
 1056 0028 7B68     		ldr	r3, [r7, #4]
 1057              	.L66:
 1058              		.loc 1 867 0 discriminator 3
 1059 002a FB60     		str	r3, [r7, #12]
 868:lib/FreeRTOS/tasks.c **** 
 869:lib/FreeRTOS/tasks.c **** 			traceTASK_SUSPEND( pxTCB );
 870:lib/FreeRTOS/tasks.c **** 
 871:lib/FreeRTOS/tasks.c **** 			/* Remove task from the ready/delayed list and place in the	suspended list. */
 872:lib/FreeRTOS/tasks.c **** 			vListRemove( &( pxTCB->xGenericListItem ) );
 1060              		.loc 1 872 0 is_stmt 1 discriminator 3
 1061 002c FB68     		ldr	r3, [r7, #12]
 1062 002e 03F10403 		add	r3, r3, #4
 1063 0032 1846     		mov	r0, r3
 1064 0034 FFF7FEFF 		bl	vListRemove
 873:lib/FreeRTOS/tasks.c **** 
 874:lib/FreeRTOS/tasks.c **** 			/* Is the task waiting on an event also? */
 875:lib/FreeRTOS/tasks.c **** 			if( pxTCB->xEventListItem.pvContainer != NULL )
 1065              		.loc 1 875 0 discriminator 3
 1066 0038 FB68     		ldr	r3, [r7, #12]
 1067 003a 9B6A     		ldr	r3, [r3, #40]
 1068 003c 002B     		cmp	r3, #0
 1069 003e 05D0     		beq	.L67
 876:lib/FreeRTOS/tasks.c **** 			{
 877:lib/FreeRTOS/tasks.c **** 				vListRemove( &( pxTCB->xEventListItem ) );
 1070              		.loc 1 877 0
 1071 0040 FB68     		ldr	r3, [r7, #12]
 1072 0042 03F11803 		add	r3, r3, #24
 1073 0046 1846     		mov	r0, r3
 1074 0048 FFF7FEFF 		bl	vListRemove
 1075              	.L67:
 878:lib/FreeRTOS/tasks.c **** 			}
 879:lib/FreeRTOS/tasks.c **** 
 880:lib/FreeRTOS/tasks.c **** 			vListInsertEnd( ( xList * ) &xSuspendedTaskList, &( pxTCB->xGenericListItem ) );
 1076              		.loc 1 880 0
 1077 004c FB68     		ldr	r3, [r7, #12]
 1078 004e 03F10403 		add	r3, r3, #4
 1079 0052 1148     		ldr	r0, .L71+4
 1080 0054 1946     		mov	r1, r3
 1081 0056 FFF7FEFF 		bl	vListInsertEnd
 881:lib/FreeRTOS/tasks.c **** 		}
 882:lib/FreeRTOS/tasks.c **** 		taskEXIT_CRITICAL();
 1082              		.loc 1 882 0
 1083 005a FFF7FEFF 		bl	vPortExitCritical
 883:lib/FreeRTOS/tasks.c **** 
 884:lib/FreeRTOS/tasks.c **** 		if( ( void * ) pxTaskToSuspend == NULL )
 1084              		.loc 1 884 0
 1085 005e 7B68     		ldr	r3, [r7, #4]
 1086 0060 002B     		cmp	r3, #0
 1087 0062 13D1     		bne	.L63
 885:lib/FreeRTOS/tasks.c **** 		{
 886:lib/FreeRTOS/tasks.c **** 			if( xSchedulerRunning != pdFALSE )
 1088              		.loc 1 886 0
 1089 0064 0D4B     		ldr	r3, .L71+8
 1090 0066 1B68     		ldr	r3, [r3, #0]
 1091 0068 002B     		cmp	r3, #0
 1092 006a 02D0     		beq	.L69
 887:lib/FreeRTOS/tasks.c **** 			{
 888:lib/FreeRTOS/tasks.c **** 				/* We have just suspended the current task. */
 889:lib/FreeRTOS/tasks.c **** 				portYIELD_WITHIN_API();
 1093              		.loc 1 889 0
 1094 006c FFF7FEFF 		bl	vPortYieldFromISR
 1095 0070 0CE0     		b	.L63
 1096              	.L69:
 890:lib/FreeRTOS/tasks.c **** 			}
 891:lib/FreeRTOS/tasks.c **** 			else
 892:lib/FreeRTOS/tasks.c **** 			{
 893:lib/FreeRTOS/tasks.c **** 				/* The scheduler is not running, but the task that was pointed
 894:lib/FreeRTOS/tasks.c **** 				to by pxCurrentTCB has just been suspended and pxCurrentTCB
 895:lib/FreeRTOS/tasks.c **** 				must be adjusted to point to a different task. */
 896:lib/FreeRTOS/tasks.c **** 				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks )
 1097              		.loc 1 896 0
 1098 0072 094B     		ldr	r3, .L71+4
 1099 0074 1A68     		ldr	r2, [r3, #0]
 1100 0076 0A4B     		ldr	r3, .L71+12
 1101 0078 1B68     		ldr	r3, [r3, #0]
 1102 007a 9A42     		cmp	r2, r3
 1103 007c 04D1     		bne	.L70
 897:lib/FreeRTOS/tasks.c **** 				{
 898:lib/FreeRTOS/tasks.c **** 					/* No other tasks are ready, so set pxCurrentTCB back to
 899:lib/FreeRTOS/tasks.c **** 					NULL so when the next task is created pxCurrentTCB will
 900:lib/FreeRTOS/tasks.c **** 					be set to point to it no matter what its relative priority
 901:lib/FreeRTOS/tasks.c **** 					is. */
 902:lib/FreeRTOS/tasks.c **** 					pxCurrentTCB = NULL;
 1104              		.loc 1 902 0
 1105 007e 054B     		ldr	r3, .L71
 1106 0080 4FF00002 		mov	r2, #0
 1107 0084 1A60     		str	r2, [r3, #0]
 1108 0086 01E0     		b	.L63
 1109              	.L70:
 903:lib/FreeRTOS/tasks.c **** 				}
 904:lib/FreeRTOS/tasks.c **** 				else
 905:lib/FreeRTOS/tasks.c **** 				{
 906:lib/FreeRTOS/tasks.c **** 					vTaskSwitchContext();
 1110              		.loc 1 906 0
 1111 0088 FFF7FEFF 		bl	vTaskSwitchContext
 1112              	.L63:
 907:lib/FreeRTOS/tasks.c **** 				}
 908:lib/FreeRTOS/tasks.c **** 			}
 909:lib/FreeRTOS/tasks.c **** 		}
 910:lib/FreeRTOS/tasks.c **** 	}
 1113              		.loc 1 910 0
 1114 008c 07F11007 		add	r7, r7, #16
 1115 0090 BD46     		mov	sp, r7
 1116 0092 80BD     		pop	{r7, pc}
 1117              	.L72:
 1118              		.align	2
 1119              	.L71:
 1120 0094 00000000 		.word	pxCurrentTCB
 1121 0098 00000000 		.word	xSuspendedTaskList
 1122 009c 00000000 		.word	xSchedulerRunning
 1123 00a0 00000000 		.word	uxCurrentNumberOfTasks
 1124              		.cfi_endproc
 1125              	.LFE116:
 1127              		.section	.text.xTaskIsTaskSuspended,"ax",%progbits
 1128              		.align	2
 1129              		.global	xTaskIsTaskSuspended
 1130              		.thumb
 1131              		.thumb_func
 1133              	xTaskIsTaskSuspended:
 1134              	.LFB117:
 911:lib/FreeRTOS/tasks.c **** 
 912:lib/FreeRTOS/tasks.c **** #endif
 913:lib/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
 914:lib/FreeRTOS/tasks.c **** 
 915:lib/FreeRTOS/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
 916:lib/FreeRTOS/tasks.c **** 
 917:lib/FreeRTOS/tasks.c **** 	signed portBASE_TYPE xTaskIsTaskSuspended( xTaskHandle xTask )
 918:lib/FreeRTOS/tasks.c **** 	{
 1135              		.loc 1 918 0
 1136              		.cfi_startproc
 1137              		@ args = 0, pretend = 0, frame = 16
 1138              		@ frame_needed = 1, uses_anonymous_args = 0
 1139              		@ link register save eliminated.
 1140 0000 80B4     		push	{r7}
 1141              	.LCFI21:
 1142              		.cfi_def_cfa_offset 4
 1143 0002 85B0     		sub	sp, sp, #20
 1144              	.LCFI22:
 1145              		.cfi_def_cfa_offset 24
 1146 0004 00AF     		add	r7, sp, #0
 1147              		.cfi_offset 7, -4
 1148              	.LCFI23:
 1149              		.cfi_def_cfa_register 7
 1150 0006 7860     		str	r0, [r7, #4]
 919:lib/FreeRTOS/tasks.c **** 	portBASE_TYPE xReturn = pdFALSE;
 1151              		.loc 1 919 0
 1152 0008 4FF00003 		mov	r3, #0
 1153 000c FB60     		str	r3, [r7, #12]
 920:lib/FreeRTOS/tasks.c **** 	const tskTCB * const pxTCB = ( tskTCB * ) xTask;
 1154              		.loc 1 920 0
 1155 000e 7B68     		ldr	r3, [r7, #4]
 1156 0010 BB60     		str	r3, [r7, #8]
 921:lib/FreeRTOS/tasks.c **** 
 922:lib/FreeRTOS/tasks.c **** 		/* It does not make sense to check if the calling task is suspended. */
 923:lib/FreeRTOS/tasks.c **** 		configASSERT( xTask );
 1157              		.loc 1 923 0
 1158 0012 7B68     		ldr	r3, [r7, #4]
 1159 0014 002B     		cmp	r3, #0
 1160 0016 04D1     		bne	.L74
 1161              		.loc 1 923 0 is_stmt 0 discriminator 1
 1162              	@ 923 "lib/FreeRTOS/tasks.c" 1
 1163 0018 4FF0BF00 			mov r0, #191								
 1164 001c 80F31188 		msr basepri, r0							
 1165              	
 1166              	@ 0 "" 2
 1167              		.thumb
 1168              	.L75:
 1169              		.loc 1 923 0 discriminator 2
 1170 0020 FEE7     		b	.L75
 1171              	.L74:
 924:lib/FreeRTOS/tasks.c **** 
 925:lib/FreeRTOS/tasks.c **** 		/* Is the task we are attempting to resume actually in the
 926:lib/FreeRTOS/tasks.c **** 		suspended list? */
 927:lib/FreeRTOS/tasks.c **** 		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xGenericListItem ) ) != pdFALSE )
 1172              		.loc 1 927 0 is_stmt 1
 1173 0022 BB68     		ldr	r3, [r7, #8]
 1174 0024 5A69     		ldr	r2, [r3, #20]
 1175 0026 0B4B     		ldr	r3, .L77
 1176 0028 9A42     		cmp	r2, r3
 1177 002a 0BD1     		bne	.L76
 928:lib/FreeRTOS/tasks.c **** 		{
 929:lib/FreeRTOS/tasks.c **** 			/* Has the task already been resumed from within an ISR? */
 930:lib/FreeRTOS/tasks.c **** 			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) != pdTRUE )
 1178              		.loc 1 930 0
 1179 002c BB68     		ldr	r3, [r7, #8]
 1180 002e 9A6A     		ldr	r2, [r3, #40]
 1181 0030 094B     		ldr	r3, .L77+4
 1182 0032 9A42     		cmp	r2, r3
 1183 0034 06D0     		beq	.L76
 931:lib/FreeRTOS/tasks.c **** 			{
 932:lib/FreeRTOS/tasks.c **** 				/* Is it in the suspended list because it is in the
 933:lib/FreeRTOS/tasks.c **** 				Suspended state?  It is possible to be in the suspended
 934:lib/FreeRTOS/tasks.c **** 				list because it is blocked on a task with no timeout
 935:lib/FreeRTOS/tasks.c **** 				specified. */
 936:lib/FreeRTOS/tasks.c **** 				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) == pdTRUE )
 1184              		.loc 1 936 0
 1185 0036 BB68     		ldr	r3, [r7, #8]
 1186 0038 9B6A     		ldr	r3, [r3, #40]
 1187 003a 002B     		cmp	r3, #0
 1188 003c 02D1     		bne	.L76
 937:lib/FreeRTOS/tasks.c **** 				{
 938:lib/FreeRTOS/tasks.c **** 					xReturn = pdTRUE;
 1189              		.loc 1 938 0
 1190 003e 4FF00103 		mov	r3, #1
 1191 0042 FB60     		str	r3, [r7, #12]
 1192              	.L76:
 939:lib/FreeRTOS/tasks.c **** 				}
 940:lib/FreeRTOS/tasks.c **** 			}
 941:lib/FreeRTOS/tasks.c **** 		}
 942:lib/FreeRTOS/tasks.c **** 
 943:lib/FreeRTOS/tasks.c **** 		return xReturn;
 1193              		.loc 1 943 0
 1194 0044 FB68     		ldr	r3, [r7, #12]
 944:lib/FreeRTOS/tasks.c **** 	}
 1195              		.loc 1 944 0
 1196 0046 1846     		mov	r0, r3
 1197 0048 07F11407 		add	r7, r7, #20
 1198 004c BD46     		mov	sp, r7
 1199 004e 80BC     		pop	{r7}
 1200 0050 7047     		bx	lr
 1201              	.L78:
 1202 0052 00BF     		.align	2
 1203              	.L77:
 1204 0054 00000000 		.word	xSuspendedTaskList
 1205 0058 00000000 		.word	xPendingReadyList
 1206              		.cfi_endproc
 1207              	.LFE117:
 1209              		.section	.text.vTaskResume,"ax",%progbits
 1210              		.align	2
 1211              		.global	vTaskResume
 1212              		.thumb
 1213              		.thumb_func
 1215              	vTaskResume:
 1216              	.LFB118:
 945:lib/FreeRTOS/tasks.c **** 
 946:lib/FreeRTOS/tasks.c **** #endif
 947:lib/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
 948:lib/FreeRTOS/tasks.c **** 
 949:lib/FreeRTOS/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
 950:lib/FreeRTOS/tasks.c **** 
 951:lib/FreeRTOS/tasks.c **** 	void vTaskResume( xTaskHandle pxTaskToResume )
 952:lib/FreeRTOS/tasks.c **** 	{
 1217              		.loc 1 952 0
 1218              		.cfi_startproc
 1219              		@ args = 0, pretend = 0, frame = 16
 1220              		@ frame_needed = 1, uses_anonymous_args = 0
 1221 0000 80B5     		push	{r7, lr}
 1222              	.LCFI24:
 1223              		.cfi_def_cfa_offset 8
 1224 0002 84B0     		sub	sp, sp, #16
 1225              	.LCFI25:
 1226              		.cfi_def_cfa_offset 24
 1227 0004 00AF     		add	r7, sp, #0
 1228              		.cfi_offset 14, -4
 1229              		.cfi_offset 7, -8
 1230              	.LCFI26:
 1231              		.cfi_def_cfa_register 7
 1232 0006 7860     		str	r0, [r7, #4]
 953:lib/FreeRTOS/tasks.c **** 	tskTCB *pxTCB;
 954:lib/FreeRTOS/tasks.c **** 
 955:lib/FreeRTOS/tasks.c **** 		/* It does not make sense to resume the calling task. */
 956:lib/FreeRTOS/tasks.c **** 		configASSERT( pxTaskToResume );
 1233              		.loc 1 956 0
 1234 0008 7B68     		ldr	r3, [r7, #4]
 1235 000a 002B     		cmp	r3, #0
 1236 000c 04D1     		bne	.L80
 1237              		.loc 1 956 0 is_stmt 0 discriminator 1
 1238              	@ 956 "lib/FreeRTOS/tasks.c" 1
 1239 000e 4FF0BF00 			mov r0, #191								
 1240 0012 80F31188 		msr basepri, r0							
 1241              	
 1242              	@ 0 "" 2
 1243              		.thumb
 1244              	.L81:
 1245              		.loc 1 956 0 discriminator 2
 1246 0016 FEE7     		b	.L81
 1247              	.L80:
 957:lib/FreeRTOS/tasks.c **** 
 958:lib/FreeRTOS/tasks.c **** 		/* Remove the task from whichever list it is currently in, and place
 959:lib/FreeRTOS/tasks.c **** 		it in the ready list. */
 960:lib/FreeRTOS/tasks.c **** 		pxTCB = ( tskTCB * ) pxTaskToResume;
 1248              		.loc 1 960 0 is_stmt 1
 1249 0018 7B68     		ldr	r3, [r7, #4]
 1250 001a FB60     		str	r3, [r7, #12]
 961:lib/FreeRTOS/tasks.c **** 
 962:lib/FreeRTOS/tasks.c **** 		/* The parameter cannot be NULL as it is impossible to resume the
 963:lib/FreeRTOS/tasks.c **** 		currently executing task. */
 964:lib/FreeRTOS/tasks.c **** 		if( ( pxTCB != NULL ) && ( pxTCB != pxCurrentTCB ) )
 1251              		.loc 1 964 0
 1252 001c FB68     		ldr	r3, [r7, #12]
 1253 001e 002B     		cmp	r3, #0
 1254 0020 39D0     		beq	.L79
 1255              		.loc 1 964 0 is_stmt 0 discriminator 1
 1256 0022 1F4B     		ldr	r3, .L85
 1257 0024 1B68     		ldr	r3, [r3, #0]
 1258 0026 FA68     		ldr	r2, [r7, #12]
 1259 0028 9A42     		cmp	r2, r3
 1260 002a 34D0     		beq	.L79
 965:lib/FreeRTOS/tasks.c **** 		{
 966:lib/FreeRTOS/tasks.c **** 			taskENTER_CRITICAL();
 1261              		.loc 1 966 0 is_stmt 1
 1262 002c FFF7FEFF 		bl	vPortEnterCritical
 967:lib/FreeRTOS/tasks.c **** 			{
 968:lib/FreeRTOS/tasks.c **** 				if( xTaskIsTaskSuspended( pxTCB ) == pdTRUE )
 1263              		.loc 1 968 0
 1264 0030 F868     		ldr	r0, [r7, #12]
 1265 0032 FFF7FEFF 		bl	xTaskIsTaskSuspended
 1266 0036 0346     		mov	r3, r0
 1267 0038 012B     		cmp	r3, #1
 1268 003a 2AD1     		bne	.L83
 969:lib/FreeRTOS/tasks.c **** 				{
 970:lib/FreeRTOS/tasks.c **** 					traceTASK_RESUME( pxTCB );
 971:lib/FreeRTOS/tasks.c **** 
 972:lib/FreeRTOS/tasks.c **** 					/* As we are in a critical section we can access the ready
 973:lib/FreeRTOS/tasks.c **** 					lists even if the scheduler is suspended. */
 974:lib/FreeRTOS/tasks.c **** 					vListRemove(  &( pxTCB->xGenericListItem ) );
 1269              		.loc 1 974 0
 1270 003c FB68     		ldr	r3, [r7, #12]
 1271 003e 03F10403 		add	r3, r3, #4
 1272 0042 1846     		mov	r0, r3
 1273 0044 FFF7FEFF 		bl	vListRemove
 975:lib/FreeRTOS/tasks.c **** 					prvAddTaskToReadyQueue( pxTCB );
 1274              		.loc 1 975 0
 1275 0048 FB68     		ldr	r3, [r7, #12]
 1276 004a DA6A     		ldr	r2, [r3, #44]
 1277 004c 154B     		ldr	r3, .L85+4
 1278 004e 1B68     		ldr	r3, [r3, #0]
 1279 0050 9A42     		cmp	r2, r3
 1280 0052 03D9     		bls	.L84
 1281              		.loc 1 975 0 is_stmt 0 discriminator 1
 1282 0054 FB68     		ldr	r3, [r7, #12]
 1283 0056 DA6A     		ldr	r2, [r3, #44]
 1284 0058 124B     		ldr	r3, .L85+4
 1285 005a 1A60     		str	r2, [r3, #0]
 1286              	.L84:
 1287              		.loc 1 975 0 discriminator 2
 1288 005c FB68     		ldr	r3, [r7, #12]
 1289 005e DA6A     		ldr	r2, [r3, #44]
 1290 0060 1346     		mov	r3, r2
 1291 0062 4FEA8303 		lsl	r3, r3, #2
 1292 0066 9B18     		adds	r3, r3, r2
 1293 0068 4FEA8303 		lsl	r3, r3, #2
 1294 006c 1A46     		mov	r2, r3
 1295 006e 0E4B     		ldr	r3, .L85+8
 1296 0070 D218     		adds	r2, r2, r3
 1297 0072 FB68     		ldr	r3, [r7, #12]
 1298 0074 03F10403 		add	r3, r3, #4
 1299 0078 1046     		mov	r0, r2
 1300 007a 1946     		mov	r1, r3
 1301 007c FFF7FEFF 		bl	vListInsertEnd
 976:lib/FreeRTOS/tasks.c **** 
 977:lib/FreeRTOS/tasks.c **** 					/* We may have just resumed a higher priority task. */
 978:lib/FreeRTOS/tasks.c **** 					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 1302              		.loc 1 978 0 is_stmt 1 discriminator 2
 1303 0080 FB68     		ldr	r3, [r7, #12]
 1304 0082 DA6A     		ldr	r2, [r3, #44]
 1305 0084 064B     		ldr	r3, .L85
 1306 0086 1B68     		ldr	r3, [r3, #0]
 1307 0088 DB6A     		ldr	r3, [r3, #44]
 1308 008a 9A42     		cmp	r2, r3
 1309 008c 01D3     		bcc	.L83
 979:lib/FreeRTOS/tasks.c **** 					{
 980:lib/FreeRTOS/tasks.c **** 						/* This yield may not cause the task just resumed to run, but
 981:lib/FreeRTOS/tasks.c **** 						will leave the lists in the correct state for the next yield. */
 982:lib/FreeRTOS/tasks.c **** 						portYIELD_WITHIN_API();
 1310              		.loc 1 982 0
 1311 008e FFF7FEFF 		bl	vPortYieldFromISR
 1312              	.L83:
 983:lib/FreeRTOS/tasks.c **** 					}
 984:lib/FreeRTOS/tasks.c **** 				}
 985:lib/FreeRTOS/tasks.c **** 			}
 986:lib/FreeRTOS/tasks.c **** 			taskEXIT_CRITICAL();
 1313              		.loc 1 986 0
 1314 0092 FFF7FEFF 		bl	vPortExitCritical
 1315              	.L79:
 987:lib/FreeRTOS/tasks.c **** 		}
 988:lib/FreeRTOS/tasks.c **** 	}
 1316              		.loc 1 988 0
 1317 0096 07F11007 		add	r7, r7, #16
 1318 009a BD46     		mov	sp, r7
 1319 009c 80BD     		pop	{r7, pc}
 1320              	.L86:
 1321 009e 00BF     		.align	2
 1322              	.L85:
 1323 00a0 00000000 		.word	pxCurrentTCB
 1324 00a4 00000000 		.word	uxTopReadyPriority
 1325 00a8 00000000 		.word	pxReadyTasksLists
 1326              		.cfi_endproc
 1327              	.LFE118:
 1329              		.section	.text.xTaskResumeFromISR,"ax",%progbits
 1330              		.align	2
 1331              		.global	xTaskResumeFromISR
 1332              		.thumb
 1333              		.thumb_func
 1335              	xTaskResumeFromISR:
 1336              	.LFB119:
 989:lib/FreeRTOS/tasks.c **** 
 990:lib/FreeRTOS/tasks.c **** #endif
 991:lib/FreeRTOS/tasks.c **** 
 992:lib/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
 993:lib/FreeRTOS/tasks.c **** 
 994:lib/FreeRTOS/tasks.c **** #if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )
 995:lib/FreeRTOS/tasks.c **** 
 996:lib/FreeRTOS/tasks.c **** 	portBASE_TYPE xTaskResumeFromISR( xTaskHandle pxTaskToResume )
 997:lib/FreeRTOS/tasks.c **** 	{
 1337              		.loc 1 997 0
 1338              		.cfi_startproc
 1339              		@ args = 0, pretend = 0, frame = 24
 1340              		@ frame_needed = 1, uses_anonymous_args = 0
 1341 0000 80B5     		push	{r7, lr}
 1342              	.LCFI27:
 1343              		.cfi_def_cfa_offset 8
 1344 0002 86B0     		sub	sp, sp, #24
 1345              	.LCFI28:
 1346              		.cfi_def_cfa_offset 32
 1347 0004 00AF     		add	r7, sp, #0
 1348              		.cfi_offset 14, -4
 1349              		.cfi_offset 7, -8
 1350              	.LCFI29:
 1351              		.cfi_def_cfa_register 7
 1352 0006 7860     		str	r0, [r7, #4]
 998:lib/FreeRTOS/tasks.c **** 	portBASE_TYPE xYieldRequired = pdFALSE;
 1353              		.loc 1 998 0
 1354 0008 4FF00003 		mov	r3, #0
 1355 000c 7B61     		str	r3, [r7, #20]
 999:lib/FreeRTOS/tasks.c **** 	tskTCB *pxTCB;
1000:lib/FreeRTOS/tasks.c **** 	unsigned portBASE_TYPE uxSavedInterruptStatus;
1001:lib/FreeRTOS/tasks.c **** 
1002:lib/FreeRTOS/tasks.c **** 		configASSERT( pxTaskToResume );
 1356              		.loc 1 1002 0
 1357 000e 7B68     		ldr	r3, [r7, #4]
 1358 0010 002B     		cmp	r3, #0
 1359 0012 04D1     		bne	.L88
 1360              		.loc 1 1002 0 is_stmt 0 discriminator 1
 1361              	@ 1002 "lib/FreeRTOS/tasks.c" 1
 1362 0014 4FF0BF00 			mov r0, #191								
 1363 0018 80F31188 		msr basepri, r0							
 1364              	
 1365              	@ 0 "" 2
 1366              		.thumb
 1367              	.L89:
 1368              		.loc 1 1002 0 discriminator 2
 1369 001c FEE7     		b	.L89
 1370              	.L88:
1003:lib/FreeRTOS/tasks.c **** 
1004:lib/FreeRTOS/tasks.c **** 		pxTCB = ( tskTCB * ) pxTaskToResume;
 1371              		.loc 1 1004 0 is_stmt 1
 1372 001e 7B68     		ldr	r3, [r7, #4]
 1373 0020 3B61     		str	r3, [r7, #16]
1005:lib/FreeRTOS/tasks.c **** 
1006:lib/FreeRTOS/tasks.c **** 		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 1374              		.loc 1 1006 0
 1375 0022 4FF00003 		mov	r3, #0
 1376 0026 FB60     		str	r3, [r7, #12]
 1377              	@ 1006 "lib/FreeRTOS/tasks.c" 1
 1378 0028 4FF0BF00 			mov r0, #191								
 1379 002c 80F31188 		msr basepri, r0							
 1380              	
 1381              	@ 0 "" 2
1007:lib/FreeRTOS/tasks.c **** 		{
1008:lib/FreeRTOS/tasks.c **** 			if( xTaskIsTaskSuspended( pxTCB ) == pdTRUE )
 1382              		.loc 1 1008 0
 1383              		.thumb
 1384 0030 3869     		ldr	r0, [r7, #16]
 1385 0032 FFF7FEFF 		bl	xTaskIsTaskSuspended
 1386 0036 0346     		mov	r3, r0
 1387 0038 012B     		cmp	r3, #1
 1388 003a 37D1     		bne	.L90
1009:lib/FreeRTOS/tasks.c **** 			{
1010:lib/FreeRTOS/tasks.c **** 				traceTASK_RESUME_FROM_ISR( pxTCB );
1011:lib/FreeRTOS/tasks.c **** 
1012:lib/FreeRTOS/tasks.c **** 				if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
 1389              		.loc 1 1012 0
 1390 003c 204B     		ldr	r3, .L93
 1391 003e 1B68     		ldr	r3, [r3, #0]
 1392 0040 002B     		cmp	r3, #0
 1393 0042 2CD1     		bne	.L91
1013:lib/FreeRTOS/tasks.c **** 				{
1014:lib/FreeRTOS/tasks.c **** 					xYieldRequired = ( pxTCB->uxPriority >= pxCurrentTCB->uxPriority );
 1394              		.loc 1 1014 0
 1395 0044 3B69     		ldr	r3, [r7, #16]
 1396 0046 DA6A     		ldr	r2, [r3, #44]
 1397 0048 1E4B     		ldr	r3, .L93+4
 1398 004a 1B68     		ldr	r3, [r3, #0]
 1399 004c DB6A     		ldr	r3, [r3, #44]
 1400 004e 9A42     		cmp	r2, r3
 1401 0050 34BF     		ite	cc
 1402 0052 0023     		movcc	r3, #0
 1403 0054 0123     		movcs	r3, #1
 1404 0056 7B61     		str	r3, [r7, #20]
1015:lib/FreeRTOS/tasks.c **** 					vListRemove(  &( pxTCB->xGenericListItem ) );
 1405              		.loc 1 1015 0
 1406 0058 3B69     		ldr	r3, [r7, #16]
 1407 005a 03F10403 		add	r3, r3, #4
 1408 005e 1846     		mov	r0, r3
 1409 0060 FFF7FEFF 		bl	vListRemove
1016:lib/FreeRTOS/tasks.c **** 					prvAddTaskToReadyQueue( pxTCB );
 1410              		.loc 1 1016 0
 1411 0064 3B69     		ldr	r3, [r7, #16]
 1412 0066 DA6A     		ldr	r2, [r3, #44]
 1413 0068 174B     		ldr	r3, .L93+8
 1414 006a 1B68     		ldr	r3, [r3, #0]
 1415 006c 9A42     		cmp	r2, r3
 1416 006e 03D9     		bls	.L92
 1417              		.loc 1 1016 0 is_stmt 0 discriminator 1
 1418 0070 3B69     		ldr	r3, [r7, #16]
 1419 0072 DA6A     		ldr	r2, [r3, #44]
 1420 0074 144B     		ldr	r3, .L93+8
 1421 0076 1A60     		str	r2, [r3, #0]
 1422              	.L92:
 1423              		.loc 1 1016 0 discriminator 2
 1424 0078 3B69     		ldr	r3, [r7, #16]
 1425 007a DA6A     		ldr	r2, [r3, #44]
 1426 007c 1346     		mov	r3, r2
 1427 007e 4FEA8303 		lsl	r3, r3, #2
 1428 0082 9B18     		adds	r3, r3, r2
 1429 0084 4FEA8303 		lsl	r3, r3, #2
 1430 0088 1A46     		mov	r2, r3
 1431 008a 104B     		ldr	r3, .L93+12
 1432 008c D218     		adds	r2, r2, r3
 1433 008e 3B69     		ldr	r3, [r7, #16]
 1434 0090 03F10403 		add	r3, r3, #4
 1435 0094 1046     		mov	r0, r2
 1436 0096 1946     		mov	r1, r3
 1437 0098 FFF7FEFF 		bl	vListInsertEnd
 1438 009c 06E0     		b	.L90
 1439              	.L91:
1017:lib/FreeRTOS/tasks.c **** 				}
1018:lib/FreeRTOS/tasks.c **** 				else
1019:lib/FreeRTOS/tasks.c **** 				{
1020:lib/FreeRTOS/tasks.c **** 					/* We cannot access the delayed or ready lists, so will hold this
1021:lib/FreeRTOS/tasks.c **** 					task pending until the scheduler is resumed, at which point a
1022:lib/FreeRTOS/tasks.c **** 					yield will be performed if necessary. */
1023:lib/FreeRTOS/tasks.c **** 					vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
 1440              		.loc 1 1023 0 is_stmt 1
 1441 009e 3B69     		ldr	r3, [r7, #16]
 1442 00a0 03F11803 		add	r3, r3, #24
 1443 00a4 0A48     		ldr	r0, .L93+16
 1444 00a6 1946     		mov	r1, r3
 1445 00a8 FFF7FEFF 		bl	vListInsertEnd
 1446              	.L90:
1024:lib/FreeRTOS/tasks.c **** 				}
1025:lib/FreeRTOS/tasks.c **** 			}
1026:lib/FreeRTOS/tasks.c **** 		}
1027:lib/FreeRTOS/tasks.c **** 		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
 1447              		.loc 1 1027 0
 1448              	@ 1027 "lib/FreeRTOS/tasks.c" 1
 1449 00ac 4FF00000 			mov r0, #0					
 1450 00b0 80F31188 		msr basepri, r0				
 1451              	
 1452              	@ 0 "" 2
1028:lib/FreeRTOS/tasks.c **** 
1029:lib/FreeRTOS/tasks.c **** 		return xYieldRequired;
 1453              		.loc 1 1029 0
 1454              		.thumb
 1455 00b4 7B69     		ldr	r3, [r7, #20]
1030:lib/FreeRTOS/tasks.c **** 	}
 1456              		.loc 1 1030 0
 1457 00b6 1846     		mov	r0, r3
 1458 00b8 07F11807 		add	r7, r7, #24
 1459 00bc BD46     		mov	sp, r7
 1460 00be 80BD     		pop	{r7, pc}
 1461              	.L94:
 1462              		.align	2
 1463              	.L93:
 1464 00c0 00000000 		.word	uxSchedulerSuspended
 1465 00c4 00000000 		.word	pxCurrentTCB
 1466 00c8 00000000 		.word	uxTopReadyPriority
 1467 00cc 00000000 		.word	pxReadyTasksLists
 1468 00d0 00000000 		.word	xPendingReadyList
 1469              		.cfi_endproc
 1470              	.LFE119:
 1472              		.section	.rodata
 1473              		.align	2
 1474              	.LC0:
 1475 0000 49444C45 		.ascii	"IDLE\000"
 1475      00
 1476              		.section	.text.vTaskStartScheduler,"ax",%progbits
 1477              		.align	2
 1478              		.global	vTaskStartScheduler
 1479              		.thumb
 1480              		.thumb_func
 1482              	vTaskStartScheduler:
 1483              	.LFB120:
1031:lib/FreeRTOS/tasks.c **** 
1032:lib/FreeRTOS/tasks.c **** #endif
1033:lib/FreeRTOS/tasks.c **** 
1034:lib/FreeRTOS/tasks.c **** 
1035:lib/FreeRTOS/tasks.c **** 
1036:lib/FreeRTOS/tasks.c **** 
1037:lib/FreeRTOS/tasks.c **** /*-----------------------------------------------------------
1038:lib/FreeRTOS/tasks.c ****  * PUBLIC SCHEDULER CONTROL documented in task.h
1039:lib/FreeRTOS/tasks.c ****  *----------------------------------------------------------*/
1040:lib/FreeRTOS/tasks.c **** 
1041:lib/FreeRTOS/tasks.c **** 
1042:lib/FreeRTOS/tasks.c **** void vTaskStartScheduler( void )
1043:lib/FreeRTOS/tasks.c **** {
 1484              		.loc 1 1043 0
 1485              		.cfi_startproc
 1486              		@ args = 0, pretend = 0, frame = 8
 1487              		@ frame_needed = 1, uses_anonymous_args = 0
 1488 0000 80B5     		push	{r7, lr}
 1489              	.LCFI30:
 1490              		.cfi_def_cfa_offset 8
 1491 0002 86B0     		sub	sp, sp, #24
 1492              	.LCFI31:
 1493              		.cfi_def_cfa_offset 32
 1494 0004 04AF     		add	r7, sp, #16
 1495              		.cfi_offset 14, -4
 1496              		.cfi_offset 7, -8
 1497              	.LCFI32:
 1498              		.cfi_def_cfa 7, 16
1044:lib/FreeRTOS/tasks.c **** portBASE_TYPE xReturn;
1045:lib/FreeRTOS/tasks.c **** 
1046:lib/FreeRTOS/tasks.c **** 	/* Add the idle task at the lowest priority. */
1047:lib/FreeRTOS/tasks.c **** 	#if ( INCLUDE_xTaskGetIdleTaskHandle == 1 )
1048:lib/FreeRTOS/tasks.c **** 	{
1049:lib/FreeRTOS/tasks.c **** 		/* Create the idle task, storing its handle in xIdleTaskHandle so it can
1050:lib/FreeRTOS/tasks.c **** 		be returned by the xTaskGetIdleTaskHandle() function. */
1051:lib/FreeRTOS/tasks.c **** 		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL
1052:lib/FreeRTOS/tasks.c **** 	}
1053:lib/FreeRTOS/tasks.c **** 	#else
1054:lib/FreeRTOS/tasks.c **** 	{
1055:lib/FreeRTOS/tasks.c **** 		/* Create the idle task without storing its handle. */
1056:lib/FreeRTOS/tasks.c **** 		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL
 1499              		.loc 1 1056 0
 1500 0006 4FF00003 		mov	r3, #0
 1501 000a 0093     		str	r3, [sp, #0]
 1502 000c 4FF00003 		mov	r3, #0
 1503 0010 0193     		str	r3, [sp, #4]
 1504 0012 4FF00003 		mov	r3, #0
 1505 0016 0293     		str	r3, [sp, #8]
 1506 0018 4FF00003 		mov	r3, #0
 1507 001c 0393     		str	r3, [sp, #12]
 1508 001e 1648     		ldr	r0, .L100
 1509 0020 1649     		ldr	r1, .L100+4
 1510 0022 4FF0C002 		mov	r2, #192
 1511 0026 4FF00003 		mov	r3, #0
 1512 002a FFF7FEFF 		bl	xTaskGenericCreate
 1513 002e 7860     		str	r0, [r7, #4]
1057:lib/FreeRTOS/tasks.c **** 	}
1058:lib/FreeRTOS/tasks.c **** 	#endif
1059:lib/FreeRTOS/tasks.c **** 
1060:lib/FreeRTOS/tasks.c **** 	#if ( configUSE_TIMERS == 1 )
1061:lib/FreeRTOS/tasks.c **** 	{
1062:lib/FreeRTOS/tasks.c **** 		if( xReturn == pdPASS )
 1514              		.loc 1 1062 0
 1515 0030 7B68     		ldr	r3, [r7, #4]
 1516 0032 012B     		cmp	r3, #1
 1517 0034 02D1     		bne	.L96
1063:lib/FreeRTOS/tasks.c **** 		{
1064:lib/FreeRTOS/tasks.c **** 			xReturn = xTimerCreateTimerTask();
 1518              		.loc 1 1064 0
 1519 0036 FFF7FEFF 		bl	xTimerCreateTimerTask
 1520 003a 7860     		str	r0, [r7, #4]
 1521              	.L96:
1065:lib/FreeRTOS/tasks.c **** 		}
1066:lib/FreeRTOS/tasks.c **** 	}
1067:lib/FreeRTOS/tasks.c **** 	#endif
1068:lib/FreeRTOS/tasks.c **** 
1069:lib/FreeRTOS/tasks.c **** 	if( xReturn == pdPASS )
 1522              		.loc 1 1069 0
 1523 003c 7B68     		ldr	r3, [r7, #4]
 1524 003e 012B     		cmp	r3, #1
 1525 0040 0DD1     		bne	.L97
1070:lib/FreeRTOS/tasks.c **** 	{
1071:lib/FreeRTOS/tasks.c **** 		/* Interrupts are turned off here, to ensure a tick does not occur
1072:lib/FreeRTOS/tasks.c **** 		before or during the call to xPortStartScheduler().  The stacks of
1073:lib/FreeRTOS/tasks.c **** 		the created tasks contain a status word with interrupts switched on
1074:lib/FreeRTOS/tasks.c **** 		so interrupts will automatically get re-enabled when the first task
1075:lib/FreeRTOS/tasks.c **** 		starts to run.
1076:lib/FreeRTOS/tasks.c **** 
1077:lib/FreeRTOS/tasks.c **** 		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
1078:lib/FreeRTOS/tasks.c **** 		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
1079:lib/FreeRTOS/tasks.c **** 		portDISABLE_INTERRUPTS();
 1526              		.loc 1 1079 0
 1527              	@ 1079 "lib/FreeRTOS/tasks.c" 1
 1528 0042 4FF0BF00 			mov r0, #191								
 1529 0046 80F31188 		msr basepri, r0							
 1530              	
 1531              	@ 0 "" 2
1080:lib/FreeRTOS/tasks.c **** 
1081:lib/FreeRTOS/tasks.c **** 		xSchedulerRunning = pdTRUE;
 1532              		.loc 1 1081 0
 1533              		.thumb
 1534 004a 0D4B     		ldr	r3, .L100+8
 1535 004c 4FF00102 		mov	r2, #1
 1536 0050 1A60     		str	r2, [r3, #0]
1082:lib/FreeRTOS/tasks.c **** 		xTickCount = ( portTickType ) 0U;
 1537              		.loc 1 1082 0
 1538 0052 0C4B     		ldr	r3, .L100+12
 1539 0054 4FF00002 		mov	r2, #0
 1540 0058 1A60     		str	r2, [r3, #0]
1083:lib/FreeRTOS/tasks.c **** 
1084:lib/FreeRTOS/tasks.c **** 		/* If configGENERATE_RUN_TIME_STATS is defined then the following
1085:lib/FreeRTOS/tasks.c **** 		macro must be defined to configure the timer/counter used to generate
1086:lib/FreeRTOS/tasks.c **** 		the run time counter time base. */
1087:lib/FreeRTOS/tasks.c **** 		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();
1088:lib/FreeRTOS/tasks.c **** 		
1089:lib/FreeRTOS/tasks.c **** 		/* Setting up the timer tick is hardware specific and thus in the
1090:lib/FreeRTOS/tasks.c **** 		portable interface. */
1091:lib/FreeRTOS/tasks.c **** 		if( xPortStartScheduler() != pdFALSE )
 1541              		.loc 1 1091 0
 1542 005a FFF7FEFF 		bl	xPortStartScheduler
 1543              	.L97:
1092:lib/FreeRTOS/tasks.c **** 		{
1093:lib/FreeRTOS/tasks.c **** 			/* Should not reach here as if the scheduler is running the
1094:lib/FreeRTOS/tasks.c **** 			function will not return. */
1095:lib/FreeRTOS/tasks.c **** 		}
1096:lib/FreeRTOS/tasks.c **** 		else
1097:lib/FreeRTOS/tasks.c **** 		{
1098:lib/FreeRTOS/tasks.c **** 			/* Should only reach here if a task calls xTaskEndScheduler(). */
1099:lib/FreeRTOS/tasks.c **** 		}
1100:lib/FreeRTOS/tasks.c **** 	}
1101:lib/FreeRTOS/tasks.c **** 
1102:lib/FreeRTOS/tasks.c **** 	/* This line will only be reached if the kernel could not be started. */
1103:lib/FreeRTOS/tasks.c **** 	configASSERT( xReturn );
 1544              		.loc 1 1103 0
 1545 005e 7B68     		ldr	r3, [r7, #4]
 1546 0060 002B     		cmp	r3, #0
 1547 0062 04D1     		bne	.L95
 1548              		.loc 1 1103 0 is_stmt 0 discriminator 1
 1549              	@ 1103 "lib/FreeRTOS/tasks.c" 1
 1550 0064 4FF0BF00 			mov r0, #191								
 1551 0068 80F31188 		msr basepri, r0							
 1552              	
 1553              	@ 0 "" 2
 1554              		.thumb
 1555              	.L99:
 1556              		.loc 1 1103 0 discriminator 2
 1557 006c FEE7     		b	.L99
 1558              	.L95:
1104:lib/FreeRTOS/tasks.c **** }
 1559              		.loc 1 1104 0 is_stmt 1
 1560 006e 07F10807 		add	r7, r7, #8
 1561 0072 BD46     		mov	sp, r7
 1562 0074 80BD     		pop	{r7, pc}
 1563              	.L101:
 1564 0076 00BF     		.align	2
 1565              	.L100:
 1566 0078 00000000 		.word	prvIdleTask
 1567 007c 00000000 		.word	.LC0
 1568 0080 00000000 		.word	xSchedulerRunning
 1569 0084 00000000 		.word	xTickCount
 1570              		.cfi_endproc
 1571              	.LFE120:
 1573              		.section	.text.vTaskEndScheduler,"ax",%progbits
 1574              		.align	2
 1575              		.global	vTaskEndScheduler
 1576              		.thumb
 1577              		.thumb_func
 1579              	vTaskEndScheduler:
 1580              	.LFB121:
1105:lib/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
1106:lib/FreeRTOS/tasks.c **** 
1107:lib/FreeRTOS/tasks.c **** void vTaskEndScheduler( void )
1108:lib/FreeRTOS/tasks.c **** {
 1581              		.loc 1 1108 0
 1582              		.cfi_startproc
 1583              		@ args = 0, pretend = 0, frame = 0
 1584              		@ frame_needed = 1, uses_anonymous_args = 0
 1585 0000 80B5     		push	{r7, lr}
 1586              	.LCFI33:
 1587              		.cfi_def_cfa_offset 8
 1588 0002 00AF     		add	r7, sp, #0
 1589              		.cfi_offset 14, -4
 1590              		.cfi_offset 7, -8
 1591              	.LCFI34:
 1592              		.cfi_def_cfa_register 7
1109:lib/FreeRTOS/tasks.c **** 	/* Stop the scheduler interrupts and call the portable scheduler end
1110:lib/FreeRTOS/tasks.c **** 	routine so the original ISRs can be restored if necessary.  The port
1111:lib/FreeRTOS/tasks.c **** 	layer must ensure interrupts enable	bit is left in the correct state. */
1112:lib/FreeRTOS/tasks.c **** 	portDISABLE_INTERRUPTS();
 1593              		.loc 1 1112 0
 1594              	@ 1112 "lib/FreeRTOS/tasks.c" 1
 1595 0004 4FF0BF00 			mov r0, #191								
 1596 0008 80F31188 		msr basepri, r0							
 1597              	
 1598              	@ 0 "" 2
1113:lib/FreeRTOS/tasks.c **** 	xSchedulerRunning = pdFALSE;
 1599              		.loc 1 1113 0
 1600              		.thumb
 1601 000c 034B     		ldr	r3, .L103
 1602 000e 4FF00002 		mov	r2, #0
 1603 0012 1A60     		str	r2, [r3, #0]
1114:lib/FreeRTOS/tasks.c **** 	vPortEndScheduler();
 1604              		.loc 1 1114 0
 1605 0014 FFF7FEFF 		bl	vPortEndScheduler
1115:lib/FreeRTOS/tasks.c **** }
 1606              		.loc 1 1115 0
 1607 0018 80BD     		pop	{r7, pc}
 1608              	.L104:
 1609 001a 00BF     		.align	2
 1610              	.L103:
 1611 001c 00000000 		.word	xSchedulerRunning
 1612              		.cfi_endproc
 1613              	.LFE121:
 1615              		.section	.text.vTaskSuspendAll,"ax",%progbits
 1616              		.align	2
 1617              		.global	vTaskSuspendAll
 1618              		.thumb
 1619              		.thumb_func
 1621              	vTaskSuspendAll:
 1622              	.LFB122:
1116:lib/FreeRTOS/tasks.c **** /*----------------------------------------------------------*/
1117:lib/FreeRTOS/tasks.c **** 
1118:lib/FreeRTOS/tasks.c **** void vTaskSuspendAll( void )
1119:lib/FreeRTOS/tasks.c **** {
 1623              		.loc 1 1119 0
 1624              		.cfi_startproc
 1625              		@ args = 0, pretend = 0, frame = 0
 1626              		@ frame_needed = 1, uses_anonymous_args = 0
 1627              		@ link register save eliminated.
 1628 0000 80B4     		push	{r7}
 1629              	.LCFI35:
 1630              		.cfi_def_cfa_offset 4
 1631 0002 00AF     		add	r7, sp, #0
 1632              		.cfi_offset 7, -4
 1633              	.LCFI36:
 1634              		.cfi_def_cfa_register 7
1120:lib/FreeRTOS/tasks.c **** 	/* A critical section is not required as the variable is of type
1121:lib/FreeRTOS/tasks.c **** 	portBASE_TYPE. */
1122:lib/FreeRTOS/tasks.c **** 	++uxSchedulerSuspended;
 1635              		.loc 1 1122 0
 1636 0004 044B     		ldr	r3, .L106
 1637 0006 1B68     		ldr	r3, [r3, #0]
 1638 0008 03F10102 		add	r2, r3, #1
 1639 000c 024B     		ldr	r3, .L106
 1640 000e 1A60     		str	r2, [r3, #0]
1123:lib/FreeRTOS/tasks.c **** }
 1641              		.loc 1 1123 0
 1642 0010 BD46     		mov	sp, r7
 1643 0012 80BC     		pop	{r7}
 1644 0014 7047     		bx	lr
 1645              	.L107:
 1646 0016 00BF     		.align	2
 1647              	.L106:
 1648 0018 00000000 		.word	uxSchedulerSuspended
 1649              		.cfi_endproc
 1650              	.LFE122:
 1652              		.section	.text.xTaskResumeAll,"ax",%progbits
 1653              		.align	2
 1654              		.global	xTaskResumeAll
 1655              		.thumb
 1656              		.thumb_func
 1658              	xTaskResumeAll:
 1659              	.LFB123:
1124:lib/FreeRTOS/tasks.c **** /*----------------------------------------------------------*/
1125:lib/FreeRTOS/tasks.c **** 
1126:lib/FreeRTOS/tasks.c **** signed portBASE_TYPE xTaskResumeAll( void )
1127:lib/FreeRTOS/tasks.c **** {
 1660              		.loc 1 1127 0
 1661              		.cfi_startproc
 1662              		@ args = 0, pretend = 0, frame = 8
 1663              		@ frame_needed = 1, uses_anonymous_args = 0
 1664 0000 90B5     		push	{r4, r7, lr}
 1665              	.LCFI37:
 1666              		.cfi_def_cfa_offset 12
 1667 0002 83B0     		sub	sp, sp, #12
 1668              	.LCFI38:
 1669              		.cfi_def_cfa_offset 24
 1670 0004 00AF     		add	r7, sp, #0
 1671              		.cfi_offset 14, -4
 1672              		.cfi_offset 7, -8
 1673              		.cfi_offset 4, -12
 1674              	.LCFI39:
 1675              		.cfi_def_cfa_register 7
1128:lib/FreeRTOS/tasks.c **** register tskTCB *pxTCB;
1129:lib/FreeRTOS/tasks.c **** signed portBASE_TYPE xAlreadyYielded = pdFALSE;
 1676              		.loc 1 1129 0
 1677 0006 4FF00003 		mov	r3, #0
 1678 000a 7B60     		str	r3, [r7, #4]
1130:lib/FreeRTOS/tasks.c **** 
1131:lib/FreeRTOS/tasks.c **** 	/* If uxSchedulerSuspended is zero then this function does not match a
1132:lib/FreeRTOS/tasks.c **** 	previous call to vTaskSuspendAll(). */
1133:lib/FreeRTOS/tasks.c **** 	configASSERT( uxSchedulerSuspended );
 1679              		.loc 1 1133 0
 1680 000c 3D4B     		ldr	r3, .L119
 1681 000e 1B68     		ldr	r3, [r3, #0]
 1682 0010 002B     		cmp	r3, #0
 1683 0012 04D1     		bne	.L109
 1684              		.loc 1 1133 0 is_stmt 0 discriminator 1
 1685              	@ 1133 "lib/FreeRTOS/tasks.c" 1
 1686 0014 4FF0BF00 			mov r0, #191								
 1687 0018 80F31188 		msr basepri, r0							
 1688              	
 1689              	@ 0 "" 2
 1690              		.thumb
 1691              	.L110:
 1692              		.loc 1 1133 0 discriminator 2
 1693 001c FEE7     		b	.L110
 1694              	.L109:
1134:lib/FreeRTOS/tasks.c **** 
1135:lib/FreeRTOS/tasks.c **** 	/* It is possible that an ISR caused a task to be removed from an event
1136:lib/FreeRTOS/tasks.c **** 	list while the scheduler was suspended.  If this was the case then the
1137:lib/FreeRTOS/tasks.c **** 	removed task will have been added to the xPendingReadyList.  Once the
1138:lib/FreeRTOS/tasks.c **** 	scheduler has been resumed it is safe to move all the pending ready
1139:lib/FreeRTOS/tasks.c **** 	tasks from this list into their appropriate ready list. */
1140:lib/FreeRTOS/tasks.c **** 	taskENTER_CRITICAL();
 1695              		.loc 1 1140 0 is_stmt 1
 1696 001e FFF7FEFF 		bl	vPortEnterCritical
1141:lib/FreeRTOS/tasks.c **** 	{
1142:lib/FreeRTOS/tasks.c **** 		--uxSchedulerSuspended;
 1697              		.loc 1 1142 0
 1698 0022 384B     		ldr	r3, .L119
 1699 0024 1B68     		ldr	r3, [r3, #0]
 1700 0026 03F1FF32 		add	r2, r3, #-1
 1701 002a 364B     		ldr	r3, .L119
 1702 002c 1A60     		str	r2, [r3, #0]
1143:lib/FreeRTOS/tasks.c **** 
1144:lib/FreeRTOS/tasks.c **** 		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
 1703              		.loc 1 1144 0
 1704 002e 354B     		ldr	r3, .L119
 1705 0030 1B68     		ldr	r3, [r3, #0]
 1706 0032 002B     		cmp	r3, #0
 1707 0034 5ED1     		bne	.L111
1145:lib/FreeRTOS/tasks.c **** 		{
1146:lib/FreeRTOS/tasks.c **** 			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
 1708              		.loc 1 1146 0
 1709 0036 344B     		ldr	r3, .L119+4
 1710 0038 1B68     		ldr	r3, [r3, #0]
 1711 003a 002B     		cmp	r3, #0
 1712 003c 5AD0     		beq	.L111
 1713              	.LBB3:
1147:lib/FreeRTOS/tasks.c **** 			{
1148:lib/FreeRTOS/tasks.c **** 				portBASE_TYPE xYieldRequired = pdFALSE;
 1714              		.loc 1 1148 0
 1715 003e 4FF00003 		mov	r3, #0
 1716 0042 3B60     		str	r3, [r7, #0]
1149:lib/FreeRTOS/tasks.c **** 
1150:lib/FreeRTOS/tasks.c **** 				/* Move any readied tasks from the pending list into the
1151:lib/FreeRTOS/tasks.c **** 				appropriate ready list. */
1152:lib/FreeRTOS/tasks.c **** 				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
 1717              		.loc 1 1152 0
 1718 0044 2EE0     		b	.L112
 1719              	.L114:
1153:lib/FreeRTOS/tasks.c **** 				{
1154:lib/FreeRTOS/tasks.c **** 					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
 1720              		.loc 1 1154 0
 1721 0046 314B     		ldr	r3, .L119+8
 1722 0048 DB68     		ldr	r3, [r3, #12]
 1723 004a DB68     		ldr	r3, [r3, #12]
 1724 004c 1C46     		mov	r4, r3
1155:lib/FreeRTOS/tasks.c **** 					vListRemove( &( pxTCB->xEventListItem ) );
 1725              		.loc 1 1155 0
 1726 004e 04F11803 		add	r3, r4, #24
 1727 0052 1846     		mov	r0, r3
 1728 0054 FFF7FEFF 		bl	vListRemove
1156:lib/FreeRTOS/tasks.c **** 					vListRemove( &( pxTCB->xGenericListItem ) );
 1729              		.loc 1 1156 0
 1730 0058 04F10403 		add	r3, r4, #4
 1731 005c 1846     		mov	r0, r3
 1732 005e FFF7FEFF 		bl	vListRemove
1157:lib/FreeRTOS/tasks.c **** 					prvAddTaskToReadyQueue( pxTCB );
 1733              		.loc 1 1157 0
 1734 0062 E26A     		ldr	r2, [r4, #44]
 1735 0064 2A4B     		ldr	r3, .L119+12
 1736 0066 1B68     		ldr	r3, [r3, #0]
 1737 0068 9A42     		cmp	r2, r3
 1738 006a 02D9     		bls	.L113
 1739              		.loc 1 1157 0 is_stmt 0 discriminator 1
 1740 006c E26A     		ldr	r2, [r4, #44]
 1741 006e 284B     		ldr	r3, .L119+12
 1742 0070 1A60     		str	r2, [r3, #0]
 1743              	.L113:
 1744              		.loc 1 1157 0 discriminator 2
 1745 0072 E26A     		ldr	r2, [r4, #44]
 1746 0074 1346     		mov	r3, r2
 1747 0076 4FEA8303 		lsl	r3, r3, #2
 1748 007a 9B18     		adds	r3, r3, r2
 1749 007c 4FEA8303 		lsl	r3, r3, #2
 1750 0080 1A46     		mov	r2, r3
 1751 0082 244B     		ldr	r3, .L119+16
 1752 0084 D218     		adds	r2, r2, r3
 1753 0086 04F10403 		add	r3, r4, #4
 1754 008a 1046     		mov	r0, r2
 1755 008c 1946     		mov	r1, r3
 1756 008e FFF7FEFF 		bl	vListInsertEnd
1158:lib/FreeRTOS/tasks.c **** 
1159:lib/FreeRTOS/tasks.c **** 					/* If we have moved a task that has a priority higher than
1160:lib/FreeRTOS/tasks.c **** 					the current task then we should yield. */
1161:lib/FreeRTOS/tasks.c **** 					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 1757              		.loc 1 1161 0 is_stmt 1 discriminator 2
 1758 0092 E26A     		ldr	r2, [r4, #44]
 1759 0094 204B     		ldr	r3, .L119+20
 1760 0096 1B68     		ldr	r3, [r3, #0]
 1761 0098 DB6A     		ldr	r3, [r3, #44]
 1762 009a 9A42     		cmp	r2, r3
 1763 009c 02D3     		bcc	.L112
1162:lib/FreeRTOS/tasks.c **** 					{
1163:lib/FreeRTOS/tasks.c **** 						xYieldRequired = pdTRUE;
 1764              		.loc 1 1163 0
 1765 009e 4FF00103 		mov	r3, #1
 1766 00a2 3B60     		str	r3, [r7, #0]
 1767              	.L112:
1152:lib/FreeRTOS/tasks.c **** 				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
 1768              		.loc 1 1152 0 discriminator 1
 1769 00a4 194B     		ldr	r3, .L119+8
 1770 00a6 1B68     		ldr	r3, [r3, #0]
 1771 00a8 002B     		cmp	r3, #0
 1772 00aa CCD1     		bne	.L114
1164:lib/FreeRTOS/tasks.c **** 					}
1165:lib/FreeRTOS/tasks.c **** 				}
1166:lib/FreeRTOS/tasks.c **** 
1167:lib/FreeRTOS/tasks.c **** 				/* If any ticks occurred while the scheduler was suspended then
1168:lib/FreeRTOS/tasks.c **** 				they should be processed now.  This ensures the tick count does not
1169:lib/FreeRTOS/tasks.c **** 				slip, and that any delayed tasks are resumed at the correct time. */
1170:lib/FreeRTOS/tasks.c **** 				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
 1773              		.loc 1 1170 0
 1774 00ac 1B4B     		ldr	r3, .L119+24
 1775 00ae 1B68     		ldr	r3, [r3, #0]
 1776 00b0 002B     		cmp	r3, #0
 1777 00b2 0FD0     		beq	.L115
1171:lib/FreeRTOS/tasks.c **** 				{
1172:lib/FreeRTOS/tasks.c **** 					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
 1778              		.loc 1 1172 0
 1779 00b4 07E0     		b	.L116
 1780              	.L117:
1173:lib/FreeRTOS/tasks.c **** 					{
1174:lib/FreeRTOS/tasks.c **** 						vTaskIncrementTick();
 1781              		.loc 1 1174 0
 1782 00b6 FFF7FEFF 		bl	vTaskIncrementTick
1175:lib/FreeRTOS/tasks.c **** 						--uxMissedTicks;
 1783              		.loc 1 1175 0
 1784 00ba 184B     		ldr	r3, .L119+24
 1785 00bc 1B68     		ldr	r3, [r3, #0]
 1786 00be 03F1FF32 		add	r2, r3, #-1
 1787 00c2 164B     		ldr	r3, .L119+24
 1788 00c4 1A60     		str	r2, [r3, #0]
 1789              	.L116:
1172:lib/FreeRTOS/tasks.c **** 					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
 1790              		.loc 1 1172 0 discriminator 1
 1791 00c6 154B     		ldr	r3, .L119+24
 1792 00c8 1B68     		ldr	r3, [r3, #0]
 1793 00ca 002B     		cmp	r3, #0
 1794 00cc F3D1     		bne	.L117
1176:lib/FreeRTOS/tasks.c **** 					}
1177:lib/FreeRTOS/tasks.c **** 
1178:lib/FreeRTOS/tasks.c **** 					/* As we have processed some ticks it is appropriate to yield
1179:lib/FreeRTOS/tasks.c **** 					to ensure the highest priority task that is ready to run is
1180:lib/FreeRTOS/tasks.c **** 					the task actually running. */
1181:lib/FreeRTOS/tasks.c **** 					#if configUSE_PREEMPTION == 1
1182:lib/FreeRTOS/tasks.c **** 					{
1183:lib/FreeRTOS/tasks.c **** 						xYieldRequired = pdTRUE;
 1795              		.loc 1 1183 0
 1796 00ce 4FF00103 		mov	r3, #1
 1797 00d2 3B60     		str	r3, [r7, #0]
 1798              	.L115:
1184:lib/FreeRTOS/tasks.c **** 					}
1185:lib/FreeRTOS/tasks.c **** 					#endif
1186:lib/FreeRTOS/tasks.c **** 				}
1187:lib/FreeRTOS/tasks.c **** 
1188:lib/FreeRTOS/tasks.c **** 				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
 1799              		.loc 1 1188 0
 1800 00d4 3B68     		ldr	r3, [r7, #0]
 1801 00d6 012B     		cmp	r3, #1
 1802 00d8 03D0     		beq	.L118
 1803              		.loc 1 1188 0 is_stmt 0 discriminator 1
 1804 00da 114B     		ldr	r3, .L119+28
 1805 00dc 1B68     		ldr	r3, [r3, #0]
 1806 00de 012B     		cmp	r3, #1
 1807 00e0 08D1     		bne	.L111
 1808              	.L118:
1189:lib/FreeRTOS/tasks.c **** 				{
1190:lib/FreeRTOS/tasks.c **** 					xAlreadyYielded = pdTRUE;
 1809              		.loc 1 1190 0 is_stmt 1
 1810 00e2 4FF00103 		mov	r3, #1
 1811 00e6 7B60     		str	r3, [r7, #4]
1191:lib/FreeRTOS/tasks.c **** 					xMissedYield = pdFALSE;
 1812              		.loc 1 1191 0
 1813 00e8 0D4B     		ldr	r3, .L119+28
 1814 00ea 4FF00002 		mov	r2, #0
 1815 00ee 1A60     		str	r2, [r3, #0]
1192:lib/FreeRTOS/tasks.c **** 					portYIELD_WITHIN_API();
 1816              		.loc 1 1192 0
 1817 00f0 FFF7FEFF 		bl	vPortYieldFromISR
 1818              	.L111:
 1819              	.LBE3:
1193:lib/FreeRTOS/tasks.c **** 				}
1194:lib/FreeRTOS/tasks.c **** 			}
1195:lib/FreeRTOS/tasks.c **** 		}
1196:lib/FreeRTOS/tasks.c **** 	}
1197:lib/FreeRTOS/tasks.c **** 	taskEXIT_CRITICAL();
 1820              		.loc 1 1197 0
 1821 00f4 FFF7FEFF 		bl	vPortExitCritical
1198:lib/FreeRTOS/tasks.c **** 
1199:lib/FreeRTOS/tasks.c **** 	return xAlreadyYielded;
 1822              		.loc 1 1199 0
 1823 00f8 7B68     		ldr	r3, [r7, #4]
1200:lib/FreeRTOS/tasks.c **** }
 1824              		.loc 1 1200 0
 1825 00fa 1846     		mov	r0, r3
 1826 00fc 07F10C07 		add	r7, r7, #12
 1827 0100 BD46     		mov	sp, r7
 1828 0102 90BD     		pop	{r4, r7, pc}
 1829              	.L120:
 1830              		.align	2
 1831              	.L119:
 1832 0104 00000000 		.word	uxSchedulerSuspended
 1833 0108 00000000 		.word	uxCurrentNumberOfTasks
 1834 010c 00000000 		.word	xPendingReadyList
 1835 0110 00000000 		.word	uxTopReadyPriority
 1836 0114 00000000 		.word	pxReadyTasksLists
 1837 0118 00000000 		.word	pxCurrentTCB
 1838 011c 00000000 		.word	uxMissedTicks
 1839 0120 00000000 		.word	xMissedYield
 1840              		.cfi_endproc
 1841              	.LFE123:
 1843              		.section	.text.xTaskGetTickCount,"ax",%progbits
 1844              		.align	2
 1845              		.global	xTaskGetTickCount
 1846              		.thumb
 1847              		.thumb_func
 1849              	xTaskGetTickCount:
 1850              	.LFB124:
1201:lib/FreeRTOS/tasks.c **** 
1202:lib/FreeRTOS/tasks.c **** 
1203:lib/FreeRTOS/tasks.c **** 
1204:lib/FreeRTOS/tasks.c **** 
1205:lib/FreeRTOS/tasks.c **** 
1206:lib/FreeRTOS/tasks.c **** 
1207:lib/FreeRTOS/tasks.c **** /*-----------------------------------------------------------
1208:lib/FreeRTOS/tasks.c ****  * PUBLIC TASK UTILITIES documented in task.h
1209:lib/FreeRTOS/tasks.c ****  *----------------------------------------------------------*/
1210:lib/FreeRTOS/tasks.c **** 
1211:lib/FreeRTOS/tasks.c **** 
1212:lib/FreeRTOS/tasks.c **** 
1213:lib/FreeRTOS/tasks.c **** portTickType xTaskGetTickCount( void )
1214:lib/FreeRTOS/tasks.c **** {
 1851              		.loc 1 1214 0
 1852              		.cfi_startproc
 1853              		@ args = 0, pretend = 0, frame = 8
 1854              		@ frame_needed = 1, uses_anonymous_args = 0
 1855 0000 80B5     		push	{r7, lr}
 1856              	.LCFI40:
 1857              		.cfi_def_cfa_offset 8
 1858 0002 82B0     		sub	sp, sp, #8
 1859              	.LCFI41:
 1860              		.cfi_def_cfa_offset 16
 1861 0004 00AF     		add	r7, sp, #0
 1862              		.cfi_offset 14, -4
 1863              		.cfi_offset 7, -8
 1864              	.LCFI42:
 1865              		.cfi_def_cfa_register 7
1215:lib/FreeRTOS/tasks.c **** portTickType xTicks;
1216:lib/FreeRTOS/tasks.c **** 
1217:lib/FreeRTOS/tasks.c **** 	/* Critical section required if running on a 16 bit processor. */
1218:lib/FreeRTOS/tasks.c **** 	taskENTER_CRITICAL();
 1866              		.loc 1 1218 0
 1867 0006 FFF7FEFF 		bl	vPortEnterCritical
1219:lib/FreeRTOS/tasks.c **** 	{
1220:lib/FreeRTOS/tasks.c **** 		xTicks = xTickCount;
 1868              		.loc 1 1220 0
 1869 000a 054B     		ldr	r3, .L122
 1870 000c 1B68     		ldr	r3, [r3, #0]
 1871 000e 7B60     		str	r3, [r7, #4]
1221:lib/FreeRTOS/tasks.c **** 	}
1222:lib/FreeRTOS/tasks.c **** 	taskEXIT_CRITICAL();
 1872              		.loc 1 1222 0
 1873 0010 FFF7FEFF 		bl	vPortExitCritical
1223:lib/FreeRTOS/tasks.c **** 
1224:lib/FreeRTOS/tasks.c **** 	return xTicks;
 1874              		.loc 1 1224 0
 1875 0014 7B68     		ldr	r3, [r7, #4]
1225:lib/FreeRTOS/tasks.c **** }
 1876              		.loc 1 1225 0
 1877 0016 1846     		mov	r0, r3
 1878 0018 07F10807 		add	r7, r7, #8
 1879 001c BD46     		mov	sp, r7
 1880 001e 80BD     		pop	{r7, pc}
 1881              	.L123:
 1882              		.align	2
 1883              	.L122:
 1884 0020 00000000 		.word	xTickCount
 1885              		.cfi_endproc
 1886              	.LFE124:
 1888              		.section	.text.xTaskGetTickCountFromISR,"ax",%progbits
 1889              		.align	2
 1890              		.global	xTaskGetTickCountFromISR
 1891              		.thumb
 1892              		.thumb_func
 1894              	xTaskGetTickCountFromISR:
 1895              	.LFB125:
1226:lib/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
1227:lib/FreeRTOS/tasks.c **** 
1228:lib/FreeRTOS/tasks.c **** portTickType xTaskGetTickCountFromISR( void )
1229:lib/FreeRTOS/tasks.c **** {
 1896              		.loc 1 1229 0
 1897              		.cfi_startproc
 1898              		@ args = 0, pretend = 0, frame = 8
 1899              		@ frame_needed = 1, uses_anonymous_args = 0
 1900              		@ link register save eliminated.
 1901 0000 80B4     		push	{r7}
 1902              	.LCFI43:
 1903              		.cfi_def_cfa_offset 4
 1904 0002 83B0     		sub	sp, sp, #12
 1905              	.LCFI44:
 1906              		.cfi_def_cfa_offset 16
 1907 0004 00AF     		add	r7, sp, #0
 1908              		.cfi_offset 7, -4
 1909              	.LCFI45:
 1910              		.cfi_def_cfa_register 7
1230:lib/FreeRTOS/tasks.c **** portTickType xReturn;
1231:lib/FreeRTOS/tasks.c **** unsigned portBASE_TYPE uxSavedInterruptStatus;
1232:lib/FreeRTOS/tasks.c **** 
1233:lib/FreeRTOS/tasks.c **** 	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 1911              		.loc 1 1233 0
 1912 0006 4FF00003 		mov	r3, #0
 1913 000a 7B60     		str	r3, [r7, #4]
 1914              	@ 1233 "lib/FreeRTOS/tasks.c" 1
 1915 000c 4FF0BF00 			mov r0, #191								
 1916 0010 80F31188 		msr basepri, r0							
 1917              	
 1918              	@ 0 "" 2
1234:lib/FreeRTOS/tasks.c **** 	xReturn = xTickCount;
 1919              		.loc 1 1234 0
 1920              		.thumb
 1921 0014 064B     		ldr	r3, .L125
 1922 0016 1B68     		ldr	r3, [r3, #0]
 1923 0018 3B60     		str	r3, [r7, #0]
1235:lib/FreeRTOS/tasks.c **** 	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
 1924              		.loc 1 1235 0
 1925              	@ 1235 "lib/FreeRTOS/tasks.c" 1
 1926 001a 4FF00000 			mov r0, #0					
 1927 001e 80F31188 		msr basepri, r0				
 1928              	
 1929              	@ 0 "" 2
1236:lib/FreeRTOS/tasks.c **** 
1237:lib/FreeRTOS/tasks.c **** 	return xReturn;
 1930              		.loc 1 1237 0
 1931              		.thumb
 1932 0022 3B68     		ldr	r3, [r7, #0]
1238:lib/FreeRTOS/tasks.c **** }
 1933              		.loc 1 1238 0
 1934 0024 1846     		mov	r0, r3
 1935 0026 07F10C07 		add	r7, r7, #12
 1936 002a BD46     		mov	sp, r7
 1937 002c 80BC     		pop	{r7}
 1938 002e 7047     		bx	lr
 1939              	.L126:
 1940              		.align	2
 1941              	.L125:
 1942 0030 00000000 		.word	xTickCount
 1943              		.cfi_endproc
 1944              	.LFE125:
 1946              		.section	.text.uxTaskGetNumberOfTasks,"ax",%progbits
 1947              		.align	2
 1948              		.global	uxTaskGetNumberOfTasks
 1949              		.thumb
 1950              		.thumb_func
 1952              	uxTaskGetNumberOfTasks:
 1953              	.LFB126:
1239:lib/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
1240:lib/FreeRTOS/tasks.c **** 
1241:lib/FreeRTOS/tasks.c **** unsigned portBASE_TYPE uxTaskGetNumberOfTasks( void )
1242:lib/FreeRTOS/tasks.c **** {
 1954              		.loc 1 1242 0
 1955              		.cfi_startproc
 1956              		@ args = 0, pretend = 0, frame = 0
 1957              		@ frame_needed = 1, uses_anonymous_args = 0
 1958              		@ link register save eliminated.
 1959 0000 80B4     		push	{r7}
 1960              	.LCFI46:
 1961              		.cfi_def_cfa_offset 4
 1962 0002 00AF     		add	r7, sp, #0
 1963              		.cfi_offset 7, -4
 1964              	.LCFI47:
 1965              		.cfi_def_cfa_register 7
1243:lib/FreeRTOS/tasks.c **** 	/* A critical section is not required because the variables are of type
1244:lib/FreeRTOS/tasks.c **** 	portBASE_TYPE. */
1245:lib/FreeRTOS/tasks.c **** 	return uxCurrentNumberOfTasks;
 1966              		.loc 1 1245 0
 1967 0004 024B     		ldr	r3, .L128
 1968 0006 1B68     		ldr	r3, [r3, #0]
1246:lib/FreeRTOS/tasks.c **** }
 1969              		.loc 1 1246 0
 1970 0008 1846     		mov	r0, r3
 1971 000a BD46     		mov	sp, r7
 1972 000c 80BC     		pop	{r7}
 1973 000e 7047     		bx	lr
 1974              	.L129:
 1975              		.align	2
 1976              	.L128:
 1977 0010 00000000 		.word	uxCurrentNumberOfTasks
 1978              		.cfi_endproc
 1979              	.LFE126:
 1981              		.section	.rodata
 1982 0005 000000   		.align	2
 1983              	.LC1:
 1984 0008 0D0A00   		.ascii	"\015\012\000"
 1985              		.section	.text.vTaskList,"ax",%progbits
 1986              		.align	2
 1987              		.global	vTaskList
 1988              		.thumb
 1989              		.thumb_func
 1991              	vTaskList:
 1992              	.LFB127:
1247:lib/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
1248:lib/FreeRTOS/tasks.c **** 
1249:lib/FreeRTOS/tasks.c **** #if ( INCLUDE_pcTaskGetTaskName == 1 )
1250:lib/FreeRTOS/tasks.c **** 
1251:lib/FreeRTOS/tasks.c **** 	signed char *pcTaskGetTaskName( xTaskHandle xTaskToQuery )
1252:lib/FreeRTOS/tasks.c **** 	{
1253:lib/FreeRTOS/tasks.c **** 	tskTCB *pxTCB;
1254:lib/FreeRTOS/tasks.c **** 
1255:lib/FreeRTOS/tasks.c **** 		/* If null is passed in here then the name of the calling task is being queried. */
1256:lib/FreeRTOS/tasks.c **** 		pxTCB = prvGetTCBFromHandle( xTaskToQuery );
1257:lib/FreeRTOS/tasks.c **** 		configASSERT( pxTCB );
1258:lib/FreeRTOS/tasks.c **** 		return &( pxTCB->pcTaskName[ 0 ] );
1259:lib/FreeRTOS/tasks.c **** 	}
1260:lib/FreeRTOS/tasks.c **** 
1261:lib/FreeRTOS/tasks.c **** #endif
1262:lib/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
1263:lib/FreeRTOS/tasks.c **** 
1264:lib/FreeRTOS/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
1265:lib/FreeRTOS/tasks.c **** 
1266:lib/FreeRTOS/tasks.c **** 	void vTaskList( signed char *pcWriteBuffer )
1267:lib/FreeRTOS/tasks.c **** 	{
 1993              		.loc 1 1267 0
 1994              		.cfi_startproc
 1995              		@ args = 0, pretend = 0, frame = 16
 1996              		@ frame_needed = 1, uses_anonymous_args = 0
 1997 0000 80B5     		push	{r7, lr}
 1998              	.LCFI48:
 1999              		.cfi_def_cfa_offset 8
 2000 0002 84B0     		sub	sp, sp, #16
 2001              	.LCFI49:
 2002              		.cfi_def_cfa_offset 24
 2003 0004 00AF     		add	r7, sp, #0
 2004              		.cfi_offset 14, -4
 2005              		.cfi_offset 7, -8
 2006              	.LCFI50:
 2007              		.cfi_def_cfa_register 7
 2008 0006 7860     		str	r0, [r7, #4]
1268:lib/FreeRTOS/tasks.c **** 	unsigned portBASE_TYPE uxQueue;
1269:lib/FreeRTOS/tasks.c **** 
1270:lib/FreeRTOS/tasks.c **** 		/* This is a VERY costly function that should be used for debug only.
1271:lib/FreeRTOS/tasks.c **** 		It leaves interrupts disabled for a LONG time. */
1272:lib/FreeRTOS/tasks.c **** 
1273:lib/FreeRTOS/tasks.c **** 		vTaskSuspendAll();
 2009              		.loc 1 1273 0
 2010 0008 FFF7FEFF 		bl	vTaskSuspendAll
1274:lib/FreeRTOS/tasks.c **** 		{
1275:lib/FreeRTOS/tasks.c **** 			/* Run through all the lists that could potentially contain a TCB and
1276:lib/FreeRTOS/tasks.c **** 			report the task name, state and stack high water mark. */
1277:lib/FreeRTOS/tasks.c **** 
1278:lib/FreeRTOS/tasks.c **** 			*pcWriteBuffer = ( signed char ) 0x00;
 2011              		.loc 1 1278 0
 2012 000c 7B68     		ldr	r3, [r7, #4]
 2013 000e 4FF00002 		mov	r2, #0
 2014 0012 1A70     		strb	r2, [r3, #0]
1279:lib/FreeRTOS/tasks.c **** 			strcat( ( char * ) pcWriteBuffer, ( const char * ) "\r\n" );
 2015              		.loc 1 1279 0
 2016 0014 7868     		ldr	r0, [r7, #4]
 2017 0016 3049     		ldr	r1, .L137
 2018 0018 FFF7FEFF 		bl	strcat
1280:lib/FreeRTOS/tasks.c **** 
1281:lib/FreeRTOS/tasks.c **** 			uxQueue = uxTopUsedPriority + ( unsigned portBASE_TYPE ) 1U;
 2019              		.loc 1 1281 0
 2020 001c 2F4B     		ldr	r3, .L137+4
 2021 001e 1B68     		ldr	r3, [r3, #0]
 2022 0020 03F10103 		add	r3, r3, #1
 2023 0024 FB60     		str	r3, [r7, #12]
 2024              	.L132:
1282:lib/FreeRTOS/tasks.c **** 
1283:lib/FreeRTOS/tasks.c **** 			do
1284:lib/FreeRTOS/tasks.c **** 			{
1285:lib/FreeRTOS/tasks.c **** 				uxQueue--;
 2025              		.loc 1 1285 0
 2026 0026 FB68     		ldr	r3, [r7, #12]
 2027 0028 03F1FF33 		add	r3, r3, #-1
 2028 002c FB60     		str	r3, [r7, #12]
1286:lib/FreeRTOS/tasks.c **** 
1287:lib/FreeRTOS/tasks.c **** 				if( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxQueue ] ) ) == pdFALSE )
 2029              		.loc 1 1287 0
 2030 002e FA68     		ldr	r2, [r7, #12]
 2031 0030 1346     		mov	r3, r2
 2032 0032 4FEA8303 		lsl	r3, r3, #2
 2033 0036 9B18     		adds	r3, r3, r2
 2034 0038 4FEA8303 		lsl	r3, r3, #2
 2035 003c 1A46     		mov	r2, r3
 2036 003e 284B     		ldr	r3, .L137+8
 2037 0040 D318     		adds	r3, r2, r3
 2038 0042 1B68     		ldr	r3, [r3, #0]
 2039 0044 002B     		cmp	r3, #0
 2040 0046 0FD0     		beq	.L131
1288:lib/FreeRTOS/tasks.c **** 				{
1289:lib/FreeRTOS/tasks.c **** 					prvListTaskWithinSingleList( pcWriteBuffer, ( xList * ) &( pxReadyTasksLists[ uxQueue ] ), tsk
 2041              		.loc 1 1289 0
 2042 0048 FA68     		ldr	r2, [r7, #12]
 2043 004a 1346     		mov	r3, r2
 2044 004c 4FEA8303 		lsl	r3, r3, #2
 2045 0050 9B18     		adds	r3, r3, r2
 2046 0052 4FEA8303 		lsl	r3, r3, #2
 2047 0056 1A46     		mov	r2, r3
 2048 0058 214B     		ldr	r3, .L137+8
 2049 005a D318     		adds	r3, r2, r3
 2050 005c 7868     		ldr	r0, [r7, #4]
 2051 005e 1946     		mov	r1, r3
 2052 0060 4FF05202 		mov	r2, #82
 2053 0064 FFF7FEFF 		bl	prvListTaskWithinSingleList
 2054              	.L131:
1290:lib/FreeRTOS/tasks.c **** 				}
1291:lib/FreeRTOS/tasks.c **** 			}while( uxQueue > ( unsigned short ) tskIDLE_PRIORITY );
 2055              		.loc 1 1291 0
 2056 0068 FB68     		ldr	r3, [r7, #12]
 2057 006a 002B     		cmp	r3, #0
 2058 006c DBD1     		bne	.L132
1292:lib/FreeRTOS/tasks.c **** 
1293:lib/FreeRTOS/tasks.c **** 			if( listLIST_IS_EMPTY( pxDelayedTaskList ) == pdFALSE )
 2059              		.loc 1 1293 0
 2060 006e 1D4B     		ldr	r3, .L137+12
 2061 0070 1B68     		ldr	r3, [r3, #0]
 2062 0072 1B68     		ldr	r3, [r3, #0]
 2063 0074 002B     		cmp	r3, #0
 2064 0076 07D0     		beq	.L133
1294:lib/FreeRTOS/tasks.c **** 			{
1295:lib/FreeRTOS/tasks.c **** 				prvListTaskWithinSingleList( pcWriteBuffer, ( xList * ) pxDelayedTaskList, tskBLOCKED_CHAR );
 2065              		.loc 1 1295 0
 2066 0078 1A4B     		ldr	r3, .L137+12
 2067 007a 1B68     		ldr	r3, [r3, #0]
 2068 007c 7868     		ldr	r0, [r7, #4]
 2069 007e 1946     		mov	r1, r3
 2070 0080 4FF04202 		mov	r2, #66
 2071 0084 FFF7FEFF 		bl	prvListTaskWithinSingleList
 2072              	.L133:
1296:lib/FreeRTOS/tasks.c **** 			}
1297:lib/FreeRTOS/tasks.c **** 
1298:lib/FreeRTOS/tasks.c **** 			if( listLIST_IS_EMPTY( pxOverflowDelayedTaskList ) == pdFALSE )
 2073              		.loc 1 1298 0
 2074 0088 174B     		ldr	r3, .L137+16
 2075 008a 1B68     		ldr	r3, [r3, #0]
 2076 008c 1B68     		ldr	r3, [r3, #0]
 2077 008e 002B     		cmp	r3, #0
 2078 0090 07D0     		beq	.L134
1299:lib/FreeRTOS/tasks.c **** 			{
1300:lib/FreeRTOS/tasks.c **** 				prvListTaskWithinSingleList( pcWriteBuffer, ( xList * ) pxOverflowDelayedTaskList, tskBLOCKED_C
 2079              		.loc 1 1300 0
 2080 0092 154B     		ldr	r3, .L137+16
 2081 0094 1B68     		ldr	r3, [r3, #0]
 2082 0096 7868     		ldr	r0, [r7, #4]
 2083 0098 1946     		mov	r1, r3
 2084 009a 4FF04202 		mov	r2, #66
 2085 009e FFF7FEFF 		bl	prvListTaskWithinSingleList
 2086              	.L134:
1301:lib/FreeRTOS/tasks.c **** 			}
1302:lib/FreeRTOS/tasks.c **** 
1303:lib/FreeRTOS/tasks.c **** 			#if( INCLUDE_vTaskDelete == 1 )
1304:lib/FreeRTOS/tasks.c **** 			{
1305:lib/FreeRTOS/tasks.c **** 				if( listLIST_IS_EMPTY( &xTasksWaitingTermination ) == pdFALSE )
 2087              		.loc 1 1305 0
 2088 00a2 124B     		ldr	r3, .L137+20
 2089 00a4 1B68     		ldr	r3, [r3, #0]
 2090 00a6 002B     		cmp	r3, #0
 2091 00a8 05D0     		beq	.L135
1306:lib/FreeRTOS/tasks.c **** 				{
1307:lib/FreeRTOS/tasks.c **** 					prvListTaskWithinSingleList( pcWriteBuffer, &xTasksWaitingTermination, tskDELETED_CHAR );
 2092              		.loc 1 1307 0
 2093 00aa 7868     		ldr	r0, [r7, #4]
 2094 00ac 0F49     		ldr	r1, .L137+20
 2095 00ae 4FF04402 		mov	r2, #68
 2096 00b2 FFF7FEFF 		bl	prvListTaskWithinSingleList
 2097              	.L135:
1308:lib/FreeRTOS/tasks.c **** 				}
1309:lib/FreeRTOS/tasks.c **** 			}
1310:lib/FreeRTOS/tasks.c **** 			#endif
1311:lib/FreeRTOS/tasks.c **** 
1312:lib/FreeRTOS/tasks.c **** 			#if ( INCLUDE_vTaskSuspend == 1 )
1313:lib/FreeRTOS/tasks.c **** 			{
1314:lib/FreeRTOS/tasks.c **** 				if( listLIST_IS_EMPTY( &xSuspendedTaskList ) == pdFALSE )
 2098              		.loc 1 1314 0
 2099 00b6 0E4B     		ldr	r3, .L137+24
 2100 00b8 1B68     		ldr	r3, [r3, #0]
 2101 00ba 002B     		cmp	r3, #0
 2102 00bc 05D0     		beq	.L136
1315:lib/FreeRTOS/tasks.c **** 				{
1316:lib/FreeRTOS/tasks.c **** 					prvListTaskWithinSingleList( pcWriteBuffer, &xSuspendedTaskList, tskSUSPENDED_CHAR );
 2103              		.loc 1 1316 0
 2104 00be 7868     		ldr	r0, [r7, #4]
 2105 00c0 0B49     		ldr	r1, .L137+24
 2106 00c2 4FF05302 		mov	r2, #83
 2107 00c6 FFF7FEFF 		bl	prvListTaskWithinSingleList
 2108              	.L136:
1317:lib/FreeRTOS/tasks.c **** 				}
1318:lib/FreeRTOS/tasks.c **** 			}
1319:lib/FreeRTOS/tasks.c **** 			#endif
1320:lib/FreeRTOS/tasks.c **** 		}
1321:lib/FreeRTOS/tasks.c **** 		xTaskResumeAll();
 2109              		.loc 1 1321 0
 2110 00ca FFF7FEFF 		bl	xTaskResumeAll
1322:lib/FreeRTOS/tasks.c **** 	}
 2111              		.loc 1 1322 0
 2112 00ce 07F11007 		add	r7, r7, #16
 2113 00d2 BD46     		mov	sp, r7
 2114 00d4 80BD     		pop	{r7, pc}
 2115              	.L138:
 2116 00d6 00BF     		.align	2
 2117              	.L137:
 2118 00d8 08000000 		.word	.LC1
 2119 00dc 00000000 		.word	uxTopUsedPriority
 2120 00e0 00000000 		.word	pxReadyTasksLists
 2121 00e4 00000000 		.word	pxDelayedTaskList
 2122 00e8 00000000 		.word	pxOverflowDelayedTaskList
 2123 00ec 00000000 		.word	xTasksWaitingTermination
 2124 00f0 00000000 		.word	xSuspendedTaskList
 2125              		.cfi_endproc
 2126              	.LFE127:
 2128              		.section	.text.vTaskIncrementTick,"ax",%progbits
 2129              		.align	2
 2130              		.global	vTaskIncrementTick
 2131              		.thumb
 2132              		.thumb_func
 2134              	vTaskIncrementTick:
 2135              	.LFB128:
1323:lib/FreeRTOS/tasks.c **** 
1324:lib/FreeRTOS/tasks.c **** #endif
1325:lib/FreeRTOS/tasks.c **** /*----------------------------------------------------------*/
1326:lib/FreeRTOS/tasks.c **** 
1327:lib/FreeRTOS/tasks.c **** #if ( configGENERATE_RUN_TIME_STATS == 1 )
1328:lib/FreeRTOS/tasks.c **** 
1329:lib/FreeRTOS/tasks.c **** 	void vTaskGetRunTimeStats( signed char *pcWriteBuffer )
1330:lib/FreeRTOS/tasks.c **** 	{
1331:lib/FreeRTOS/tasks.c **** 	unsigned portBASE_TYPE uxQueue;
1332:lib/FreeRTOS/tasks.c **** 	unsigned long ulTotalRunTime;
1333:lib/FreeRTOS/tasks.c **** 
1334:lib/FreeRTOS/tasks.c **** 		/* This is a VERY costly function that should be used for debug only.
1335:lib/FreeRTOS/tasks.c **** 		It leaves interrupts disabled for a LONG time. */
1336:lib/FreeRTOS/tasks.c **** 
1337:lib/FreeRTOS/tasks.c **** 		vTaskSuspendAll();
1338:lib/FreeRTOS/tasks.c **** 		{
1339:lib/FreeRTOS/tasks.c **** 			#ifdef portALT_GET_RUN_TIME_COUNTER_VALUE
1340:lib/FreeRTOS/tasks.c **** 				portALT_GET_RUN_TIME_COUNTER_VALUE( ulTotalRunTime );
1341:lib/FreeRTOS/tasks.c **** 			#else
1342:lib/FreeRTOS/tasks.c **** 				ulTotalRunTime = portGET_RUN_TIME_COUNTER_VALUE();
1343:lib/FreeRTOS/tasks.c **** 			#endif
1344:lib/FreeRTOS/tasks.c **** 
1345:lib/FreeRTOS/tasks.c **** 			/* Divide ulTotalRunTime by 100 to make the percentage caluclations
1346:lib/FreeRTOS/tasks.c **** 			simpler in the prvGenerateRunTimeStatsForTasksInList() function. */
1347:lib/FreeRTOS/tasks.c **** 			ulTotalRunTime /= 100UL;
1348:lib/FreeRTOS/tasks.c **** 			
1349:lib/FreeRTOS/tasks.c **** 			/* Run through all the lists that could potentially contain a TCB,
1350:lib/FreeRTOS/tasks.c **** 			generating a table of run timer percentages in the provided
1351:lib/FreeRTOS/tasks.c **** 			buffer. */
1352:lib/FreeRTOS/tasks.c **** 
1353:lib/FreeRTOS/tasks.c **** 			*pcWriteBuffer = ( signed char ) 0x00;
1354:lib/FreeRTOS/tasks.c **** 			strcat( ( char * ) pcWriteBuffer, ( const char * ) "\r\n" );
1355:lib/FreeRTOS/tasks.c **** 
1356:lib/FreeRTOS/tasks.c **** 			uxQueue = uxTopUsedPriority + ( unsigned portBASE_TYPE ) 1U;
1357:lib/FreeRTOS/tasks.c **** 
1358:lib/FreeRTOS/tasks.c **** 			do
1359:lib/FreeRTOS/tasks.c **** 			{
1360:lib/FreeRTOS/tasks.c **** 				uxQueue--;
1361:lib/FreeRTOS/tasks.c **** 
1362:lib/FreeRTOS/tasks.c **** 				if( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxQueue ] ) ) == pdFALSE )
1363:lib/FreeRTOS/tasks.c **** 				{
1364:lib/FreeRTOS/tasks.c **** 					prvGenerateRunTimeStatsForTasksInList( pcWriteBuffer, ( xList * ) &( pxReadyTasksLists[ uxQueu
1365:lib/FreeRTOS/tasks.c **** 				}
1366:lib/FreeRTOS/tasks.c **** 			}while( uxQueue > ( unsigned short ) tskIDLE_PRIORITY );
1367:lib/FreeRTOS/tasks.c **** 
1368:lib/FreeRTOS/tasks.c **** 			if( listLIST_IS_EMPTY( pxDelayedTaskList ) == pdFALSE )
1369:lib/FreeRTOS/tasks.c **** 			{
1370:lib/FreeRTOS/tasks.c **** 				prvGenerateRunTimeStatsForTasksInList( pcWriteBuffer, ( xList * ) pxDelayedTaskList, ulTotalRun
1371:lib/FreeRTOS/tasks.c **** 			}
1372:lib/FreeRTOS/tasks.c **** 
1373:lib/FreeRTOS/tasks.c **** 			if( listLIST_IS_EMPTY( pxOverflowDelayedTaskList ) == pdFALSE )
1374:lib/FreeRTOS/tasks.c **** 			{
1375:lib/FreeRTOS/tasks.c **** 				prvGenerateRunTimeStatsForTasksInList( pcWriteBuffer, ( xList * ) pxOverflowDelayedTaskList, ul
1376:lib/FreeRTOS/tasks.c **** 			}
1377:lib/FreeRTOS/tasks.c **** 
1378:lib/FreeRTOS/tasks.c **** 			#if ( INCLUDE_vTaskDelete == 1 )
1379:lib/FreeRTOS/tasks.c **** 			{
1380:lib/FreeRTOS/tasks.c **** 				if( listLIST_IS_EMPTY( &xTasksWaitingTermination ) == pdFALSE )
1381:lib/FreeRTOS/tasks.c **** 				{
1382:lib/FreeRTOS/tasks.c **** 					prvGenerateRunTimeStatsForTasksInList( pcWriteBuffer, &xTasksWaitingTermination, ulTotalRunTim
1383:lib/FreeRTOS/tasks.c **** 				}
1384:lib/FreeRTOS/tasks.c **** 			}
1385:lib/FreeRTOS/tasks.c **** 			#endif
1386:lib/FreeRTOS/tasks.c **** 
1387:lib/FreeRTOS/tasks.c **** 			#if ( INCLUDE_vTaskSuspend == 1 )
1388:lib/FreeRTOS/tasks.c **** 			{
1389:lib/FreeRTOS/tasks.c **** 				if( listLIST_IS_EMPTY( &xSuspendedTaskList ) == pdFALSE )
1390:lib/FreeRTOS/tasks.c **** 				{
1391:lib/FreeRTOS/tasks.c **** 					prvGenerateRunTimeStatsForTasksInList( pcWriteBuffer, &xSuspendedTaskList, ulTotalRunTime );
1392:lib/FreeRTOS/tasks.c **** 				}
1393:lib/FreeRTOS/tasks.c **** 			}
1394:lib/FreeRTOS/tasks.c **** 			#endif
1395:lib/FreeRTOS/tasks.c **** 		}
1396:lib/FreeRTOS/tasks.c **** 		xTaskResumeAll();
1397:lib/FreeRTOS/tasks.c **** 	}
1398:lib/FreeRTOS/tasks.c **** 
1399:lib/FreeRTOS/tasks.c **** #endif
1400:lib/FreeRTOS/tasks.c **** /*----------------------------------------------------------*/
1401:lib/FreeRTOS/tasks.c **** 
1402:lib/FreeRTOS/tasks.c **** #if ( INCLUDE_xTaskGetIdleTaskHandle == 1 )
1403:lib/FreeRTOS/tasks.c **** 
1404:lib/FreeRTOS/tasks.c **** 	xTaskHandle xTaskGetIdleTaskHandle( void )
1405:lib/FreeRTOS/tasks.c **** 	{
1406:lib/FreeRTOS/tasks.c **** 		/* If xTaskGetIdleTaskHandle() is called before the scheduler has been
1407:lib/FreeRTOS/tasks.c **** 		started, then xIdleTaskHandle will be NULL. */
1408:lib/FreeRTOS/tasks.c **** 		configASSERT( ( xIdleTaskHandle != NULL ) );
1409:lib/FreeRTOS/tasks.c **** 		return xIdleTaskHandle;
1410:lib/FreeRTOS/tasks.c **** 	}
1411:lib/FreeRTOS/tasks.c **** 	
1412:lib/FreeRTOS/tasks.c **** #endif
1413:lib/FreeRTOS/tasks.c **** 
1414:lib/FreeRTOS/tasks.c **** /*-----------------------------------------------------------
1415:lib/FreeRTOS/tasks.c ****  * SCHEDULER INTERNALS AVAILABLE FOR PORTING PURPOSES
1416:lib/FreeRTOS/tasks.c ****  * documented in task.h
1417:lib/FreeRTOS/tasks.c ****  *----------------------------------------------------------*/
1418:lib/FreeRTOS/tasks.c **** 
1419:lib/FreeRTOS/tasks.c **** void vTaskIncrementTick( void )
1420:lib/FreeRTOS/tasks.c **** {
 2136              		.loc 1 1420 0
 2137              		.cfi_startproc
 2138              		@ args = 0, pretend = 0, frame = 16
 2139              		@ frame_needed = 1, uses_anonymous_args = 0
 2140 0000 80B5     		push	{r7, lr}
 2141              	.LCFI51:
 2142              		.cfi_def_cfa_offset 8
 2143 0002 84B0     		sub	sp, sp, #16
 2144              	.LCFI52:
 2145              		.cfi_def_cfa_offset 24
 2146 0004 00AF     		add	r7, sp, #0
 2147              		.cfi_offset 14, -4
 2148              		.cfi_offset 7, -8
 2149              	.LCFI53:
 2150              		.cfi_def_cfa_register 7
1421:lib/FreeRTOS/tasks.c **** tskTCB * pxTCB;
1422:lib/FreeRTOS/tasks.c **** 
1423:lib/FreeRTOS/tasks.c **** 	/* Called by the portable layer each time a tick interrupt occurs.
1424:lib/FreeRTOS/tasks.c **** 	Increments the tick then checks to see if the new tick value will cause any
1425:lib/FreeRTOS/tasks.c **** 	tasks to be unblocked. */
1426:lib/FreeRTOS/tasks.c **** 	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
 2151              		.loc 1 1426 0
 2152 0006 4E4B     		ldr	r3, .L153
 2153 0008 1B68     		ldr	r3, [r3, #0]
 2154 000a 002B     		cmp	r3, #0
 2155 000c 40F08580 		bne	.L140
1427:lib/FreeRTOS/tasks.c **** 	{
1428:lib/FreeRTOS/tasks.c **** 		++xTickCount;
 2156              		.loc 1 1428 0
 2157 0010 4C4B     		ldr	r3, .L153+4
 2158 0012 1B68     		ldr	r3, [r3, #0]
 2159 0014 03F10102 		add	r2, r3, #1
 2160 0018 4A4B     		ldr	r3, .L153+4
 2161 001a 1A60     		str	r2, [r3, #0]
1429:lib/FreeRTOS/tasks.c **** 		if( xTickCount == ( portTickType ) 0U )
 2162              		.loc 1 1429 0
 2163 001c 494B     		ldr	r3, .L153+4
 2164 001e 1B68     		ldr	r3, [r3, #0]
 2165 0020 002B     		cmp	r3, #0
 2166 0022 2CD1     		bne	.L141
 2167              	.LBB4:
1430:lib/FreeRTOS/tasks.c **** 		{
1431:lib/FreeRTOS/tasks.c **** 			xList *pxTemp;
1432:lib/FreeRTOS/tasks.c **** 
1433:lib/FreeRTOS/tasks.c **** 			/* Tick count has overflowed so we need to swap the delay lists.
1434:lib/FreeRTOS/tasks.c **** 			If there are any items in pxDelayedTaskList here then there is
1435:lib/FreeRTOS/tasks.c **** 			an error! */
1436:lib/FreeRTOS/tasks.c **** 			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );
 2168              		.loc 1 1436 0
 2169 0024 484B     		ldr	r3, .L153+8
 2170 0026 1B68     		ldr	r3, [r3, #0]
 2171 0028 1B68     		ldr	r3, [r3, #0]
 2172 002a 002B     		cmp	r3, #0
 2173 002c 04D0     		beq	.L142
 2174              		.loc 1 1436 0 is_stmt 0 discriminator 1
 2175              	@ 1436 "lib/FreeRTOS/tasks.c" 1
 2176 002e 4FF0BF00 			mov r0, #191								
 2177 0032 80F31188 		msr basepri, r0							
 2178              	
 2179              	@ 0 "" 2
 2180              		.thumb
 2181              	.L143:
 2182              		.loc 1 1436 0 discriminator 2
 2183 0036 FEE7     		b	.L143
 2184              	.L142:
1437:lib/FreeRTOS/tasks.c **** 			
1438:lib/FreeRTOS/tasks.c **** 			pxTemp = pxDelayedTaskList;
 2185              		.loc 1 1438 0 is_stmt 1
 2186 0038 434B     		ldr	r3, .L153+8
 2187 003a 1B68     		ldr	r3, [r3, #0]
 2188 003c FB60     		str	r3, [r7, #12]
1439:lib/FreeRTOS/tasks.c **** 			pxDelayedTaskList = pxOverflowDelayedTaskList;
 2189              		.loc 1 1439 0
 2190 003e 434B     		ldr	r3, .L153+12
 2191 0040 1A68     		ldr	r2, [r3, #0]
 2192 0042 414B     		ldr	r3, .L153+8
 2193 0044 1A60     		str	r2, [r3, #0]
1440:lib/FreeRTOS/tasks.c **** 			pxOverflowDelayedTaskList = pxTemp;
 2194              		.loc 1 1440 0
 2195 0046 414B     		ldr	r3, .L153+12
 2196 0048 FA68     		ldr	r2, [r7, #12]
 2197 004a 1A60     		str	r2, [r3, #0]
1441:lib/FreeRTOS/tasks.c **** 			xNumOfOverflows++;
 2198              		.loc 1 1441 0
 2199 004c 404B     		ldr	r3, .L153+16
 2200 004e 1B68     		ldr	r3, [r3, #0]
 2201 0050 03F10102 		add	r2, r3, #1
 2202 0054 3E4B     		ldr	r3, .L153+16
 2203 0056 1A60     		str	r2, [r3, #0]
1442:lib/FreeRTOS/tasks.c **** 	
1443:lib/FreeRTOS/tasks.c **** 			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 2204              		.loc 1 1443 0
 2205 0058 3B4B     		ldr	r3, .L153+8
 2206 005a 1B68     		ldr	r3, [r3, #0]
 2207 005c 1B68     		ldr	r3, [r3, #0]
 2208 005e 002B     		cmp	r3, #0
 2209 0060 04D1     		bne	.L144
1444:lib/FreeRTOS/tasks.c **** 			{
1445:lib/FreeRTOS/tasks.c **** 				/* The new current delayed list is empty.  Set
1446:lib/FreeRTOS/tasks.c **** 				xNextTaskUnblockTime to the maximum possible value so it is
1447:lib/FreeRTOS/tasks.c **** 				extremely unlikely that the	
1448:lib/FreeRTOS/tasks.c **** 				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
1449:lib/FreeRTOS/tasks.c **** 				there is an item in the delayed list. */
1450:lib/FreeRTOS/tasks.c **** 				xNextTaskUnblockTime = portMAX_DELAY;
 2210              		.loc 1 1450 0
 2211 0062 3C4B     		ldr	r3, .L153+20
 2212 0064 4FF0FF32 		mov	r2, #-1
 2213 0068 1A60     		str	r2, [r3, #0]
 2214 006a 08E0     		b	.L141
 2215              	.L144:
1451:lib/FreeRTOS/tasks.c **** 			}
1452:lib/FreeRTOS/tasks.c **** 			else
1453:lib/FreeRTOS/tasks.c **** 			{
1454:lib/FreeRTOS/tasks.c **** 				/* The new current delayed list is not empty, get the value of
1455:lib/FreeRTOS/tasks.c **** 				the item at the head of the delayed list.  This is the time at
1456:lib/FreeRTOS/tasks.c **** 				which the task at the head of the delayed list should be removed
1457:lib/FreeRTOS/tasks.c **** 				from the Blocked state. */
1458:lib/FreeRTOS/tasks.c **** 				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
 2216              		.loc 1 1458 0
 2217 006c 364B     		ldr	r3, .L153+8
 2218 006e 1B68     		ldr	r3, [r3, #0]
 2219 0070 DB68     		ldr	r3, [r3, #12]
 2220 0072 DB68     		ldr	r3, [r3, #12]
 2221 0074 BB60     		str	r3, [r7, #8]
1459:lib/FreeRTOS/tasks.c **** 				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
 2222              		.loc 1 1459 0
 2223 0076 BB68     		ldr	r3, [r7, #8]
 2224 0078 5A68     		ldr	r2, [r3, #4]
 2225 007a 364B     		ldr	r3, .L153+20
 2226 007c 1A60     		str	r2, [r3, #0]
 2227              	.L141:
 2228              	.LBE4:
 2229              	.LBB5:
1460:lib/FreeRTOS/tasks.c **** 			}
1461:lib/FreeRTOS/tasks.c **** 		}
1462:lib/FreeRTOS/tasks.c **** 
1463:lib/FreeRTOS/tasks.c **** 		/* See if this tick has made a timeout expire. */
1464:lib/FreeRTOS/tasks.c **** 		prvCheckDelayedTasks();
 2230              		.loc 1 1464 0
 2231 007e 314B     		ldr	r3, .L153+4
 2232 0080 1A68     		ldr	r2, [r3, #0]
 2233 0082 344B     		ldr	r3, .L153+20
 2234 0084 1B68     		ldr	r3, [r3, #0]
 2235 0086 9A42     		cmp	r2, r3
 2236 0088 4FD3     		bcc	.L151
 2237              	.L150:
 2238              		.loc 1 1464 0 is_stmt 0 discriminator 1
 2239 008a 2F4B     		ldr	r3, .L153+8
 2240 008c 1B68     		ldr	r3, [r3, #0]
 2241 008e 1B68     		ldr	r3, [r3, #0]
 2242 0090 002B     		cmp	r3, #0
 2243 0092 04D1     		bne	.L146
 2244              		.loc 1 1464 0 discriminator 2
 2245 0094 2F4B     		ldr	r3, .L153+20
 2246 0096 4FF0FF32 		mov	r2, #-1
 2247 009a 1A60     		str	r2, [r3, #0]
 2248 009c 45E0     		b	.L151
 2249              	.L146:
 2250              		.loc 1 1464 0 discriminator 3
 2251 009e 2A4B     		ldr	r3, .L153+8
 2252 00a0 1B68     		ldr	r3, [r3, #0]
 2253 00a2 DB68     		ldr	r3, [r3, #12]
 2254 00a4 DB68     		ldr	r3, [r3, #12]
 2255 00a6 BB60     		str	r3, [r7, #8]
 2256 00a8 BB68     		ldr	r3, [r7, #8]
 2257 00aa 5B68     		ldr	r3, [r3, #4]
 2258 00ac 7B60     		str	r3, [r7, #4]
 2259 00ae 254B     		ldr	r3, .L153+4
 2260 00b0 1A68     		ldr	r2, [r3, #0]
 2261 00b2 7B68     		ldr	r3, [r7, #4]
 2262 00b4 9A42     		cmp	r2, r3
 2263 00b6 03D2     		bcs	.L147
 2264              		.loc 1 1464 0 discriminator 4
 2265 00b8 264B     		ldr	r3, .L153+20
 2266 00ba 7A68     		ldr	r2, [r7, #4]
 2267 00bc 1A60     		str	r2, [r3, #0]
 2268 00be 34E0     		b	.L151
 2269              	.L147:
 2270              		.loc 1 1464 0 discriminator 5
 2271 00c0 BB68     		ldr	r3, [r7, #8]
 2272 00c2 03F10403 		add	r3, r3, #4
 2273 00c6 1846     		mov	r0, r3
 2274 00c8 FFF7FEFF 		bl	vListRemove
 2275 00cc BB68     		ldr	r3, [r7, #8]
 2276 00ce 9B6A     		ldr	r3, [r3, #40]
 2277 00d0 002B     		cmp	r3, #0
 2278 00d2 05D0     		beq	.L148
 2279              		.loc 1 1464 0 discriminator 6
 2280 00d4 BB68     		ldr	r3, [r7, #8]
 2281 00d6 03F11803 		add	r3, r3, #24
 2282 00da 1846     		mov	r0, r3
 2283 00dc FFF7FEFF 		bl	vListRemove
 2284              	.L148:
 2285              		.loc 1 1464 0 discriminator 7
 2286 00e0 BB68     		ldr	r3, [r7, #8]
 2287 00e2 DA6A     		ldr	r2, [r3, #44]
 2288 00e4 1C4B     		ldr	r3, .L153+24
 2289 00e6 1B68     		ldr	r3, [r3, #0]
 2290 00e8 9A42     		cmp	r2, r3
 2291 00ea 03D9     		bls	.L149
 2292              		.loc 1 1464 0 discriminator 8
 2293 00ec BB68     		ldr	r3, [r7, #8]
 2294 00ee DA6A     		ldr	r2, [r3, #44]
 2295 00f0 194B     		ldr	r3, .L153+24
 2296 00f2 1A60     		str	r2, [r3, #0]
 2297              	.L149:
 2298              		.loc 1 1464 0 discriminator 9
 2299 00f4 BB68     		ldr	r3, [r7, #8]
 2300 00f6 DA6A     		ldr	r2, [r3, #44]
 2301 00f8 1346     		mov	r3, r2
 2302 00fa 4FEA8303 		lsl	r3, r3, #2
 2303 00fe 9B18     		adds	r3, r3, r2
 2304 0100 4FEA8303 		lsl	r3, r3, #2
 2305 0104 1A46     		mov	r2, r3
 2306 0106 154B     		ldr	r3, .L153+28
 2307 0108 D218     		adds	r2, r2, r3
 2308 010a BB68     		ldr	r3, [r7, #8]
 2309 010c 03F10403 		add	r3, r3, #4
 2310 0110 1046     		mov	r0, r2
 2311 0112 1946     		mov	r1, r3
 2312 0114 FFF7FEFF 		bl	vListInsertEnd
 2313 0118 B7E7     		b	.L150
 2314              	.L140:
 2315              	.LBE5:
1465:lib/FreeRTOS/tasks.c **** 	}
1466:lib/FreeRTOS/tasks.c **** 	else
1467:lib/FreeRTOS/tasks.c **** 	{
1468:lib/FreeRTOS/tasks.c **** 		++uxMissedTicks;
 2316              		.loc 1 1468 0 is_stmt 1
 2317 011a 114B     		ldr	r3, .L153+32
 2318 011c 1B68     		ldr	r3, [r3, #0]
 2319 011e 03F10102 		add	r2, r3, #1
 2320 0122 0F4B     		ldr	r3, .L153+32
 2321 0124 1A60     		str	r2, [r3, #0]
1469:lib/FreeRTOS/tasks.c **** 
1470:lib/FreeRTOS/tasks.c **** 		/* The tick hook gets called at regular intervals, even if the
1471:lib/FreeRTOS/tasks.c **** 		scheduler is locked. */
1472:lib/FreeRTOS/tasks.c **** 		#if ( configUSE_TICK_HOOK == 1 )
1473:lib/FreeRTOS/tasks.c **** 		{
1474:lib/FreeRTOS/tasks.c **** 			vApplicationTickHook();
 2322              		.loc 1 1474 0
 2323 0126 FFF7FEFF 		bl	vApplicationTickHook
 2324              	.L151:
1475:lib/FreeRTOS/tasks.c **** 		}
1476:lib/FreeRTOS/tasks.c **** 		#endif
1477:lib/FreeRTOS/tasks.c **** 	}
1478:lib/FreeRTOS/tasks.c **** 
1479:lib/FreeRTOS/tasks.c **** 	#if ( configUSE_TICK_HOOK == 1 )
1480:lib/FreeRTOS/tasks.c **** 	{
1481:lib/FreeRTOS/tasks.c **** 		/* Guard against the tick hook being called when the missed tick
1482:lib/FreeRTOS/tasks.c **** 		count is being unwound (when the scheduler is being unlocked. */
1483:lib/FreeRTOS/tasks.c **** 		if( uxMissedTicks == ( unsigned portBASE_TYPE ) 0U )
 2325              		.loc 1 1483 0
 2326 012a 0D4B     		ldr	r3, .L153+32
 2327 012c 1B68     		ldr	r3, [r3, #0]
 2328 012e 002B     		cmp	r3, #0
 2329 0130 01D1     		bne	.L139
1484:lib/FreeRTOS/tasks.c **** 		{
1485:lib/FreeRTOS/tasks.c **** 			vApplicationTickHook();
 2330              		.loc 1 1485 0
 2331 0132 FFF7FEFF 		bl	vApplicationTickHook
 2332              	.L139:
1486:lib/FreeRTOS/tasks.c **** 		}
1487:lib/FreeRTOS/tasks.c **** 	}
1488:lib/FreeRTOS/tasks.c **** 	#endif
1489:lib/FreeRTOS/tasks.c **** 
1490:lib/FreeRTOS/tasks.c **** 	traceTASK_INCREMENT_TICK( xTickCount );
1491:lib/FreeRTOS/tasks.c **** }
 2333              		.loc 1 1491 0
 2334 0136 07F11007 		add	r7, r7, #16
 2335 013a BD46     		mov	sp, r7
 2336 013c 80BD     		pop	{r7, pc}
 2337              	.L154:
 2338 013e 00BF     		.align	2
 2339              	.L153:
 2340 0140 00000000 		.word	uxSchedulerSuspended
 2341 0144 00000000 		.word	xTickCount
 2342 0148 00000000 		.word	pxDelayedTaskList
 2343 014c 00000000 		.word	pxOverflowDelayedTaskList
 2344 0150 00000000 		.word	xNumOfOverflows
 2345 0154 00000000 		.word	xNextTaskUnblockTime
 2346 0158 00000000 		.word	uxTopReadyPriority
 2347 015c 00000000 		.word	pxReadyTasksLists
 2348 0160 00000000 		.word	uxMissedTicks
 2349              		.cfi_endproc
 2350              	.LFE128:
 2352              		.section	.text.vTaskSwitchContext,"ax",%progbits
 2353              		.align	2
 2354              		.global	vTaskSwitchContext
 2355              		.thumb
 2356              		.thumb_func
 2358              	vTaskSwitchContext:
 2359              	.LFB129:
1492:lib/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
1493:lib/FreeRTOS/tasks.c **** 
1494:lib/FreeRTOS/tasks.c **** #if ( configUSE_APPLICATION_TASK_TAG == 1 )
1495:lib/FreeRTOS/tasks.c **** 
1496:lib/FreeRTOS/tasks.c **** 	void vTaskSetApplicationTaskTag( xTaskHandle xTask, pdTASK_HOOK_CODE pxHookFunction )
1497:lib/FreeRTOS/tasks.c **** 	{
1498:lib/FreeRTOS/tasks.c **** 	tskTCB *xTCB;
1499:lib/FreeRTOS/tasks.c **** 
1500:lib/FreeRTOS/tasks.c **** 		/* If xTask is NULL then we are setting our own task hook. */
1501:lib/FreeRTOS/tasks.c **** 		if( xTask == NULL )
1502:lib/FreeRTOS/tasks.c **** 		{
1503:lib/FreeRTOS/tasks.c **** 			xTCB = ( tskTCB * ) pxCurrentTCB;
1504:lib/FreeRTOS/tasks.c **** 		}
1505:lib/FreeRTOS/tasks.c **** 		else
1506:lib/FreeRTOS/tasks.c **** 		{
1507:lib/FreeRTOS/tasks.c **** 			xTCB = ( tskTCB * ) xTask;
1508:lib/FreeRTOS/tasks.c **** 		}
1509:lib/FreeRTOS/tasks.c **** 
1510:lib/FreeRTOS/tasks.c **** 		/* Save the hook function in the TCB.  A critical section is required as
1511:lib/FreeRTOS/tasks.c **** 		the value can be accessed from an interrupt. */
1512:lib/FreeRTOS/tasks.c **** 		taskENTER_CRITICAL();
1513:lib/FreeRTOS/tasks.c **** 			xTCB->pxTaskTag = pxHookFunction;
1514:lib/FreeRTOS/tasks.c **** 		taskEXIT_CRITICAL();
1515:lib/FreeRTOS/tasks.c **** 	}
1516:lib/FreeRTOS/tasks.c **** 
1517:lib/FreeRTOS/tasks.c **** #endif
1518:lib/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
1519:lib/FreeRTOS/tasks.c **** 
1520:lib/FreeRTOS/tasks.c **** #if ( configUSE_APPLICATION_TASK_TAG == 1 )
1521:lib/FreeRTOS/tasks.c **** 
1522:lib/FreeRTOS/tasks.c **** 	pdTASK_HOOK_CODE xTaskGetApplicationTaskTag( xTaskHandle xTask )
1523:lib/FreeRTOS/tasks.c **** 	{
1524:lib/FreeRTOS/tasks.c **** 	tskTCB *xTCB;
1525:lib/FreeRTOS/tasks.c **** 	pdTASK_HOOK_CODE xReturn;
1526:lib/FreeRTOS/tasks.c **** 
1527:lib/FreeRTOS/tasks.c **** 		/* If xTask is NULL then we are setting our own task hook. */
1528:lib/FreeRTOS/tasks.c **** 		if( xTask == NULL )
1529:lib/FreeRTOS/tasks.c **** 		{
1530:lib/FreeRTOS/tasks.c **** 			xTCB = ( tskTCB * ) pxCurrentTCB;
1531:lib/FreeRTOS/tasks.c **** 		}
1532:lib/FreeRTOS/tasks.c **** 		else
1533:lib/FreeRTOS/tasks.c **** 		{
1534:lib/FreeRTOS/tasks.c **** 			xTCB = ( tskTCB * ) xTask;
1535:lib/FreeRTOS/tasks.c **** 		}
1536:lib/FreeRTOS/tasks.c **** 
1537:lib/FreeRTOS/tasks.c **** 		/* Save the hook function in the TCB.  A critical section is required as
1538:lib/FreeRTOS/tasks.c **** 		the value can be accessed from an interrupt. */
1539:lib/FreeRTOS/tasks.c **** 		taskENTER_CRITICAL();
1540:lib/FreeRTOS/tasks.c **** 			xReturn = xTCB->pxTaskTag;
1541:lib/FreeRTOS/tasks.c **** 		taskEXIT_CRITICAL();
1542:lib/FreeRTOS/tasks.c **** 
1543:lib/FreeRTOS/tasks.c **** 		return xReturn;
1544:lib/FreeRTOS/tasks.c **** 	}
1545:lib/FreeRTOS/tasks.c **** 
1546:lib/FreeRTOS/tasks.c **** #endif
1547:lib/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
1548:lib/FreeRTOS/tasks.c **** 
1549:lib/FreeRTOS/tasks.c **** #if ( configUSE_APPLICATION_TASK_TAG == 1 )
1550:lib/FreeRTOS/tasks.c **** 
1551:lib/FreeRTOS/tasks.c **** 	portBASE_TYPE xTaskCallApplicationTaskHook( xTaskHandle xTask, void *pvParameter )
1552:lib/FreeRTOS/tasks.c **** 	{
1553:lib/FreeRTOS/tasks.c **** 	tskTCB *xTCB;
1554:lib/FreeRTOS/tasks.c **** 	portBASE_TYPE xReturn;
1555:lib/FreeRTOS/tasks.c **** 
1556:lib/FreeRTOS/tasks.c **** 		/* If xTask is NULL then we are calling our own task hook. */
1557:lib/FreeRTOS/tasks.c **** 		if( xTask == NULL )
1558:lib/FreeRTOS/tasks.c **** 		{
1559:lib/FreeRTOS/tasks.c **** 			xTCB = ( tskTCB * ) pxCurrentTCB;
1560:lib/FreeRTOS/tasks.c **** 		}
1561:lib/FreeRTOS/tasks.c **** 		else
1562:lib/FreeRTOS/tasks.c **** 		{
1563:lib/FreeRTOS/tasks.c **** 			xTCB = ( tskTCB * ) xTask;
1564:lib/FreeRTOS/tasks.c **** 		}
1565:lib/FreeRTOS/tasks.c **** 
1566:lib/FreeRTOS/tasks.c **** 		if( xTCB->pxTaskTag != NULL )
1567:lib/FreeRTOS/tasks.c **** 		{
1568:lib/FreeRTOS/tasks.c **** 			xReturn = xTCB->pxTaskTag( pvParameter );
1569:lib/FreeRTOS/tasks.c **** 		}
1570:lib/FreeRTOS/tasks.c **** 		else
1571:lib/FreeRTOS/tasks.c **** 		{
1572:lib/FreeRTOS/tasks.c **** 			xReturn = pdFAIL;
1573:lib/FreeRTOS/tasks.c **** 		}
1574:lib/FreeRTOS/tasks.c **** 
1575:lib/FreeRTOS/tasks.c **** 		return xReturn;
1576:lib/FreeRTOS/tasks.c **** 	}
1577:lib/FreeRTOS/tasks.c **** 
1578:lib/FreeRTOS/tasks.c **** #endif
1579:lib/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
1580:lib/FreeRTOS/tasks.c **** 
1581:lib/FreeRTOS/tasks.c **** void vTaskSwitchContext( void )
1582:lib/FreeRTOS/tasks.c **** {
 2360              		.loc 1 1582 0
 2361              		.cfi_startproc
 2362              		@ args = 0, pretend = 0, frame = 8
 2363              		@ frame_needed = 1, uses_anonymous_args = 0
 2364              		@ link register save eliminated.
 2365 0000 80B4     		push	{r7}
 2366              	.LCFI54:
 2367              		.cfi_def_cfa_offset 4
 2368 0002 83B0     		sub	sp, sp, #12
 2369              	.LCFI55:
 2370              		.cfi_def_cfa_offset 16
 2371 0004 00AF     		add	r7, sp, #0
 2372              		.cfi_offset 7, -4
 2373              	.LCFI56:
 2374              		.cfi_def_cfa_register 7
1583:lib/FreeRTOS/tasks.c **** 	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
 2375              		.loc 1 1583 0
 2376 0006 284B     		ldr	r3, .L164
 2377 0008 1B68     		ldr	r3, [r3, #0]
 2378 000a 002B     		cmp	r3, #0
 2379 000c 14D0     		beq	.L163
1584:lib/FreeRTOS/tasks.c **** 	{
1585:lib/FreeRTOS/tasks.c **** 		/* The scheduler is currently suspended - do not allow a context
1586:lib/FreeRTOS/tasks.c **** 		switch. */
1587:lib/FreeRTOS/tasks.c **** 		xMissedYield = pdTRUE;
 2380              		.loc 1 1587 0
 2381 000e 274B     		ldr	r3, .L164+4
 2382 0010 4FF00102 		mov	r2, #1
 2383 0014 1A60     		str	r2, [r3, #0]
 2384 0016 41E0     		b	.L155
 2385              	.L161:
1588:lib/FreeRTOS/tasks.c **** 	}
1589:lib/FreeRTOS/tasks.c **** 	else
1590:lib/FreeRTOS/tasks.c **** 	{
1591:lib/FreeRTOS/tasks.c **** 		traceTASK_SWITCHED_OUT();
1592:lib/FreeRTOS/tasks.c **** 	
1593:lib/FreeRTOS/tasks.c **** 		#if ( configGENERATE_RUN_TIME_STATS == 1 )
1594:lib/FreeRTOS/tasks.c **** 		{
1595:lib/FreeRTOS/tasks.c **** 			unsigned long ulTempCounter;
1596:lib/FreeRTOS/tasks.c **** 			
1597:lib/FreeRTOS/tasks.c **** 				#ifdef portALT_GET_RUN_TIME_COUNTER_VALUE
1598:lib/FreeRTOS/tasks.c **** 					portALT_GET_RUN_TIME_COUNTER_VALUE( ulTempCounter );
1599:lib/FreeRTOS/tasks.c **** 				#else
1600:lib/FreeRTOS/tasks.c **** 					ulTempCounter = portGET_RUN_TIME_COUNTER_VALUE();
1601:lib/FreeRTOS/tasks.c **** 				#endif
1602:lib/FreeRTOS/tasks.c **** 	
1603:lib/FreeRTOS/tasks.c **** 				/* Add the amount of time the task has been running to the accumulated
1604:lib/FreeRTOS/tasks.c **** 				time so far.  The time the task started running was stored in
1605:lib/FreeRTOS/tasks.c **** 				ulTaskSwitchedInTime.  Note that there is no overflow protection here
1606:lib/FreeRTOS/tasks.c **** 				so count values are only valid until the timer overflows.  Generally
1607:lib/FreeRTOS/tasks.c **** 				this will be about 1 hour assuming a 1uS timer increment. */
1608:lib/FreeRTOS/tasks.c **** 				pxCurrentTCB->ulRunTimeCounter += ( ulTempCounter - ulTaskSwitchedInTime );
1609:lib/FreeRTOS/tasks.c **** 				ulTaskSwitchedInTime = ulTempCounter;
1610:lib/FreeRTOS/tasks.c **** 		}
1611:lib/FreeRTOS/tasks.c **** 		#endif
1612:lib/FreeRTOS/tasks.c **** 	
1613:lib/FreeRTOS/tasks.c **** 		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
1614:lib/FreeRTOS/tasks.c **** 		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
1615:lib/FreeRTOS/tasks.c **** 	
1616:lib/FreeRTOS/tasks.c **** 		/* Find the highest priority queue that contains ready tasks. */
1617:lib/FreeRTOS/tasks.c **** 		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
1618:lib/FreeRTOS/tasks.c **** 		{
1619:lib/FreeRTOS/tasks.c **** 			configASSERT( uxTopReadyPriority );
 2386              		.loc 1 1619 0
 2387 0018 254B     		ldr	r3, .L164+8
 2388 001a 1B68     		ldr	r3, [r3, #0]
 2389 001c 002B     		cmp	r3, #0
 2390 001e 04D1     		bne	.L159
 2391              		.loc 1 1619 0 is_stmt 0 discriminator 1
 2392              	@ 1619 "lib/FreeRTOS/tasks.c" 1
 2393 0020 4FF0BF00 			mov r0, #191								
 2394 0024 80F31188 		msr basepri, r0							
 2395              	
 2396              	@ 0 "" 2
 2397              		.thumb
 2398              	.L160:
 2399              		.loc 1 1619 0 discriminator 2
 2400 0028 FEE7     		b	.L160
 2401              	.L159:
1620:lib/FreeRTOS/tasks.c **** 			--uxTopReadyPriority;
 2402              		.loc 1 1620 0 is_stmt 1
 2403 002a 214B     		ldr	r3, .L164+8
 2404 002c 1B68     		ldr	r3, [r3, #0]
 2405 002e 03F1FF32 		add	r2, r3, #-1
 2406 0032 1F4B     		ldr	r3, .L164+8
 2407 0034 1A60     		str	r2, [r3, #0]
 2408 0036 00E0     		b	.L158
 2409              	.L163:
1617:lib/FreeRTOS/tasks.c **** 		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
 2410              		.loc 1 1617 0
 2411 0038 00BF     		nop
 2412              	.L158:
1617:lib/FreeRTOS/tasks.c **** 		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
 2413              		.loc 1 1617 0 is_stmt 0 discriminator 1
 2414 003a 1D4B     		ldr	r3, .L164+8
 2415 003c 1A68     		ldr	r2, [r3, #0]
 2416 003e 1346     		mov	r3, r2
 2417 0040 4FEA8303 		lsl	r3, r3, #2
 2418 0044 9B18     		adds	r3, r3, r2
 2419 0046 4FEA8303 		lsl	r3, r3, #2
 2420 004a 1A46     		mov	r2, r3
 2421 004c 194B     		ldr	r3, .L164+12
 2422 004e D318     		adds	r3, r2, r3
 2423 0050 1B68     		ldr	r3, [r3, #0]
 2424 0052 002B     		cmp	r3, #0
 2425 0054 E0D0     		beq	.L161
 2426              	.LBB6:
1621:lib/FreeRTOS/tasks.c **** 		}
1622:lib/FreeRTOS/tasks.c **** 	
1623:lib/FreeRTOS/tasks.c **** 		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
1624:lib/FreeRTOS/tasks.c **** 		same priority get an equal share of the processor time. */
1625:lib/FreeRTOS/tasks.c **** 		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
 2427              		.loc 1 1625 0 is_stmt 1
 2428 0056 164B     		ldr	r3, .L164+8
 2429 0058 1A68     		ldr	r2, [r3, #0]
 2430 005a 1346     		mov	r3, r2
 2431 005c 4FEA8303 		lsl	r3, r3, #2
 2432 0060 9B18     		adds	r3, r3, r2
 2433 0062 4FEA8303 		lsl	r3, r3, #2
 2434 0066 1A46     		mov	r2, r3
 2435 0068 124B     		ldr	r3, .L164+12
 2436 006a D318     		adds	r3, r2, r3
 2437 006c 7B60     		str	r3, [r7, #4]
 2438 006e 7B68     		ldr	r3, [r7, #4]
 2439 0070 5B68     		ldr	r3, [r3, #4]
 2440 0072 5A68     		ldr	r2, [r3, #4]
 2441 0074 7B68     		ldr	r3, [r7, #4]
 2442 0076 5A60     		str	r2, [r3, #4]
 2443 0078 7B68     		ldr	r3, [r7, #4]
 2444 007a 5A68     		ldr	r2, [r3, #4]
 2445 007c 7B68     		ldr	r3, [r7, #4]
 2446 007e 03F10803 		add	r3, r3, #8
 2447 0082 9A42     		cmp	r2, r3
 2448 0084 04D1     		bne	.L162
 2449              		.loc 1 1625 0 is_stmt 0 discriminator 1
 2450 0086 7B68     		ldr	r3, [r7, #4]
 2451 0088 5B68     		ldr	r3, [r3, #4]
 2452 008a 5A68     		ldr	r2, [r3, #4]
 2453 008c 7B68     		ldr	r3, [r7, #4]
 2454 008e 5A60     		str	r2, [r3, #4]
 2455              	.L162:
 2456              		.loc 1 1625 0 discriminator 2
 2457 0090 7B68     		ldr	r3, [r7, #4]
 2458 0092 5B68     		ldr	r3, [r3, #4]
 2459 0094 DB68     		ldr	r3, [r3, #12]
 2460 0096 1A46     		mov	r2, r3
 2461 0098 074B     		ldr	r3, .L164+16
 2462 009a 1A60     		str	r2, [r3, #0]
 2463              	.L155:
 2464              	.LBE6:
1626:lib/FreeRTOS/tasks.c **** 	
1627:lib/FreeRTOS/tasks.c **** 		traceTASK_SWITCHED_IN();
1628:lib/FreeRTOS/tasks.c **** 	}
1629:lib/FreeRTOS/tasks.c **** }
 2465              		.loc 1 1629 0 is_stmt 1
 2466 009c 07F10C07 		add	r7, r7, #12
 2467 00a0 BD46     		mov	sp, r7
 2468 00a2 80BC     		pop	{r7}
 2469 00a4 7047     		bx	lr
 2470              	.L165:
 2471 00a6 00BF     		.align	2
 2472              	.L164:
 2473 00a8 00000000 		.word	uxSchedulerSuspended
 2474 00ac 00000000 		.word	xMissedYield
 2475 00b0 00000000 		.word	uxTopReadyPriority
 2476 00b4 00000000 		.word	pxReadyTasksLists
 2477 00b8 00000000 		.word	pxCurrentTCB
 2478              		.cfi_endproc
 2479              	.LFE129:
 2481              		.section	.text.vTaskPlaceOnEventList,"ax",%progbits
 2482              		.align	2
 2483              		.global	vTaskPlaceOnEventList
 2484              		.thumb
 2485              		.thumb_func
 2487              	vTaskPlaceOnEventList:
 2488              	.LFB130:
1630:lib/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
1631:lib/FreeRTOS/tasks.c **** 
1632:lib/FreeRTOS/tasks.c **** void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
1633:lib/FreeRTOS/tasks.c **** {
 2489              		.loc 1 1633 0
 2490              		.cfi_startproc
 2491              		@ args = 0, pretend = 0, frame = 16
 2492              		@ frame_needed = 1, uses_anonymous_args = 0
 2493 0000 80B5     		push	{r7, lr}
 2494              	.LCFI57:
 2495              		.cfi_def_cfa_offset 8
 2496 0002 84B0     		sub	sp, sp, #16
 2497              	.LCFI58:
 2498              		.cfi_def_cfa_offset 24
 2499 0004 00AF     		add	r7, sp, #0
 2500              		.cfi_offset 14, -4
 2501              		.cfi_offset 7, -8
 2502              	.LCFI59:
 2503              		.cfi_def_cfa_register 7
 2504 0006 7860     		str	r0, [r7, #4]
 2505 0008 3960     		str	r1, [r7, #0]
1634:lib/FreeRTOS/tasks.c **** portTickType xTimeToWake;
1635:lib/FreeRTOS/tasks.c **** 
1636:lib/FreeRTOS/tasks.c **** 	configASSERT( pxEventList );
 2506              		.loc 1 1636 0
 2507 000a 7B68     		ldr	r3, [r7, #4]
 2508 000c 002B     		cmp	r3, #0
 2509 000e 04D1     		bne	.L167
 2510              		.loc 1 1636 0 is_stmt 0 discriminator 1
 2511              	@ 1636 "lib/FreeRTOS/tasks.c" 1
 2512 0010 4FF0BF00 			mov r0, #191								
 2513 0014 80F31188 		msr basepri, r0							
 2514              	
 2515              	@ 0 "" 2
 2516              		.thumb
 2517              	.L168:
 2518              		.loc 1 1636 0 discriminator 2
 2519 0018 FEE7     		b	.L168
 2520              	.L167:
1637:lib/FreeRTOS/tasks.c **** 
1638:lib/FreeRTOS/tasks.c **** 	/* THIS FUNCTION MUST BE CALLED WITH INTERRUPTS DISABLED OR THE
1639:lib/FreeRTOS/tasks.c **** 	SCHEDULER SUSPENDED. */
1640:lib/FreeRTOS/tasks.c **** 
1641:lib/FreeRTOS/tasks.c **** 	/* Place the event list item of the TCB in the appropriate event list.
1642:lib/FreeRTOS/tasks.c **** 	This is placed in the list in priority order so the highest priority task
1643:lib/FreeRTOS/tasks.c **** 	is the first to be woken by the event. */
1644:lib/FreeRTOS/tasks.c **** 	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
 2521              		.loc 1 1644 0 is_stmt 1
 2522 001a 144B     		ldr	r3, .L171
 2523 001c 1B68     		ldr	r3, [r3, #0]
 2524 001e 03F11803 		add	r3, r3, #24
 2525 0022 7868     		ldr	r0, [r7, #4]
 2526 0024 1946     		mov	r1, r3
 2527 0026 FFF7FEFF 		bl	vListInsert
1645:lib/FreeRTOS/tasks.c **** 
1646:lib/FreeRTOS/tasks.c **** 	/* We must remove ourselves from the ready list before adding ourselves
1647:lib/FreeRTOS/tasks.c **** 	to the blocked list as the same list item is used for both lists.  We have
1648:lib/FreeRTOS/tasks.c **** 	exclusive access to the ready lists as the scheduler is locked. */
1649:lib/FreeRTOS/tasks.c **** 	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
 2528              		.loc 1 1649 0
 2529 002a 104B     		ldr	r3, .L171
 2530 002c 1B68     		ldr	r3, [r3, #0]
 2531 002e 03F10403 		add	r3, r3, #4
 2532 0032 1846     		mov	r0, r3
 2533 0034 FFF7FEFF 		bl	vListRemove
1650:lib/FreeRTOS/tasks.c **** 
1651:lib/FreeRTOS/tasks.c **** 
1652:lib/FreeRTOS/tasks.c **** 	#if ( INCLUDE_vTaskSuspend == 1 )
1653:lib/FreeRTOS/tasks.c **** 	{
1654:lib/FreeRTOS/tasks.c **** 		if( xTicksToWait == portMAX_DELAY )
 2534              		.loc 1 1654 0
 2535 0038 3B68     		ldr	r3, [r7, #0]
 2536 003a B3F1FF3F 		cmp	r3, #-1
 2537 003e 08D1     		bne	.L169
1655:lib/FreeRTOS/tasks.c **** 		{
1656:lib/FreeRTOS/tasks.c **** 			/* Add ourselves to the suspended task list instead of a delayed task
1657:lib/FreeRTOS/tasks.c **** 			list to ensure we are not woken by a timing event.  We will block
1658:lib/FreeRTOS/tasks.c **** 			indefinitely. */
1659:lib/FreeRTOS/tasks.c **** 			vListInsertEnd( ( xList * ) &xSuspendedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListIt
 2538              		.loc 1 1659 0
 2539 0040 0A4B     		ldr	r3, .L171
 2540 0042 1B68     		ldr	r3, [r3, #0]
 2541 0044 03F10403 		add	r3, r3, #4
 2542 0048 0948     		ldr	r0, .L171+4
 2543 004a 1946     		mov	r1, r3
 2544 004c FFF7FEFF 		bl	vListInsertEnd
 2545 0050 07E0     		b	.L166
 2546              	.L169:
1660:lib/FreeRTOS/tasks.c **** 		}
1661:lib/FreeRTOS/tasks.c **** 		else
1662:lib/FreeRTOS/tasks.c **** 		{
1663:lib/FreeRTOS/tasks.c **** 			/* Calculate the time at which the task should be woken if the event does
1664:lib/FreeRTOS/tasks.c **** 			not occur.  This may overflow but this doesn't matter. */
1665:lib/FreeRTOS/tasks.c **** 			xTimeToWake = xTickCount + xTicksToWait;
 2547              		.loc 1 1665 0
 2548 0052 084B     		ldr	r3, .L171+8
 2549 0054 1A68     		ldr	r2, [r3, #0]
 2550 0056 3B68     		ldr	r3, [r7, #0]
 2551 0058 D318     		adds	r3, r2, r3
 2552 005a FB60     		str	r3, [r7, #12]
1666:lib/FreeRTOS/tasks.c **** 			prvAddCurrentTaskToDelayedList( xTimeToWake );
 2553              		.loc 1 1666 0
 2554 005c F868     		ldr	r0, [r7, #12]
 2555 005e FFF7FEFF 		bl	prvAddCurrentTaskToDelayedList
 2556              	.L166:
1667:lib/FreeRTOS/tasks.c **** 		}
1668:lib/FreeRTOS/tasks.c **** 	}
1669:lib/FreeRTOS/tasks.c **** 	#else
1670:lib/FreeRTOS/tasks.c **** 	{
1671:lib/FreeRTOS/tasks.c **** 			/* Calculate the time at which the task should be woken if the event does
1672:lib/FreeRTOS/tasks.c **** 			not occur.  This may overflow but this doesn't matter. */
1673:lib/FreeRTOS/tasks.c **** 			xTimeToWake = xTickCount + xTicksToWait;
1674:lib/FreeRTOS/tasks.c **** 			prvAddCurrentTaskToDelayedList( xTimeToWake );
1675:lib/FreeRTOS/tasks.c **** 	}
1676:lib/FreeRTOS/tasks.c **** 	#endif
1677:lib/FreeRTOS/tasks.c **** }
 2557              		.loc 1 1677 0
 2558 0062 07F11007 		add	r7, r7, #16
 2559 0066 BD46     		mov	sp, r7
 2560 0068 80BD     		pop	{r7, pc}
 2561              	.L172:
 2562 006a 00BF     		.align	2
 2563              	.L171:
 2564 006c 00000000 		.word	pxCurrentTCB
 2565 0070 00000000 		.word	xSuspendedTaskList
 2566 0074 00000000 		.word	xTickCount
 2567              		.cfi_endproc
 2568              	.LFE130:
 2570              		.section	.text.vTaskPlaceOnEventListRestricted,"ax",%progbits
 2571              		.align	2
 2572              		.global	vTaskPlaceOnEventListRestricted
 2573              		.thumb
 2574              		.thumb_func
 2576              	vTaskPlaceOnEventListRestricted:
 2577              	.LFB131:
1678:lib/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
1679:lib/FreeRTOS/tasks.c **** 
1680:lib/FreeRTOS/tasks.c **** #if configUSE_TIMERS == 1
1681:lib/FreeRTOS/tasks.c **** 
1682:lib/FreeRTOS/tasks.c **** 	void vTaskPlaceOnEventListRestricted( const xList * const pxEventList, portTickType xTicksToWait )
1683:lib/FreeRTOS/tasks.c **** 	{
 2578              		.loc 1 1683 0
 2579              		.cfi_startproc
 2580              		@ args = 0, pretend = 0, frame = 16
 2581              		@ frame_needed = 1, uses_anonymous_args = 0
 2582 0000 80B5     		push	{r7, lr}
 2583              	.LCFI60:
 2584              		.cfi_def_cfa_offset 8
 2585 0002 84B0     		sub	sp, sp, #16
 2586              	.LCFI61:
 2587              		.cfi_def_cfa_offset 24
 2588 0004 00AF     		add	r7, sp, #0
 2589              		.cfi_offset 14, -4
 2590              		.cfi_offset 7, -8
 2591              	.LCFI62:
 2592              		.cfi_def_cfa_register 7
 2593 0006 7860     		str	r0, [r7, #4]
 2594 0008 3960     		str	r1, [r7, #0]
1684:lib/FreeRTOS/tasks.c **** 	portTickType xTimeToWake;
1685:lib/FreeRTOS/tasks.c **** 
1686:lib/FreeRTOS/tasks.c **** 		configASSERT( pxEventList );
 2595              		.loc 1 1686 0
 2596 000a 7B68     		ldr	r3, [r7, #4]
 2597 000c 002B     		cmp	r3, #0
 2598 000e 04D1     		bne	.L174
 2599              		.loc 1 1686 0 is_stmt 0 discriminator 1
 2600              	@ 1686 "lib/FreeRTOS/tasks.c" 1
 2601 0010 4FF0BF00 			mov r0, #191								
 2602 0014 80F31188 		msr basepri, r0							
 2603              	
 2604              	@ 0 "" 2
 2605              		.thumb
 2606              	.L175:
 2607              		.loc 1 1686 0 discriminator 2
 2608 0018 FEE7     		b	.L175
 2609              	.L174:
1687:lib/FreeRTOS/tasks.c **** 
1688:lib/FreeRTOS/tasks.c **** 		/* This function should not be called by application code hence the
1689:lib/FreeRTOS/tasks.c **** 		'Restricted' in its name.  It is not part of the public API.  It is
1690:lib/FreeRTOS/tasks.c **** 		designed for use by kernel code, and has special calling requirements -
1691:lib/FreeRTOS/tasks.c **** 		it should be called from a critical section. */
1692:lib/FreeRTOS/tasks.c **** 
1693:lib/FreeRTOS/tasks.c **** 	
1694:lib/FreeRTOS/tasks.c **** 		/* Place the event list item of the TCB in the appropriate event list.
1695:lib/FreeRTOS/tasks.c **** 		In this case it is assume that this is the only task that is going to
1696:lib/FreeRTOS/tasks.c **** 		be waiting on this event list, so the faster vListInsertEnd() function
1697:lib/FreeRTOS/tasks.c **** 		can be used in place of vListInsert. */
1698:lib/FreeRTOS/tasks.c **** 		vListInsertEnd( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
 2610              		.loc 1 1698 0 is_stmt 1
 2611 001a 0D4B     		ldr	r3, .L176
 2612 001c 1B68     		ldr	r3, [r3, #0]
 2613 001e 03F11803 		add	r3, r3, #24
 2614 0022 7868     		ldr	r0, [r7, #4]
 2615 0024 1946     		mov	r1, r3
 2616 0026 FFF7FEFF 		bl	vListInsertEnd
1699:lib/FreeRTOS/tasks.c **** 
1700:lib/FreeRTOS/tasks.c **** 		/* We must remove this task from the ready list before adding it to the
1701:lib/FreeRTOS/tasks.c **** 		blocked list as the same list item is used for both lists.  This
1702:lib/FreeRTOS/tasks.c **** 		function is called form a critical section. */
1703:lib/FreeRTOS/tasks.c **** 		vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
 2617              		.loc 1 1703 0
 2618 002a 094B     		ldr	r3, .L176
 2619 002c 1B68     		ldr	r3, [r3, #0]
 2620 002e 03F10403 		add	r3, r3, #4
 2621 0032 1846     		mov	r0, r3
 2622 0034 FFF7FEFF 		bl	vListRemove
1704:lib/FreeRTOS/tasks.c **** 
1705:lib/FreeRTOS/tasks.c **** 		/* Calculate the time at which the task should be woken if the event does
1706:lib/FreeRTOS/tasks.c **** 		not occur.  This may overflow but this doesn't matter. */
1707:lib/FreeRTOS/tasks.c **** 		xTimeToWake = xTickCount + xTicksToWait;
 2623              		.loc 1 1707 0
 2624 0038 064B     		ldr	r3, .L176+4
 2625 003a 1A68     		ldr	r2, [r3, #0]
 2626 003c 3B68     		ldr	r3, [r7, #0]
 2627 003e D318     		adds	r3, r2, r3
 2628 0040 FB60     		str	r3, [r7, #12]
1708:lib/FreeRTOS/tasks.c **** 		prvAddCurrentTaskToDelayedList( xTimeToWake );
 2629              		.loc 1 1708 0
 2630 0042 F868     		ldr	r0, [r7, #12]
 2631 0044 FFF7FEFF 		bl	prvAddCurrentTaskToDelayedList
1709:lib/FreeRTOS/tasks.c **** 	}
 2632              		.loc 1 1709 0
 2633 0048 07F11007 		add	r7, r7, #16
 2634 004c BD46     		mov	sp, r7
 2635 004e 80BD     		pop	{r7, pc}
 2636              	.L177:
 2637              		.align	2
 2638              	.L176:
 2639 0050 00000000 		.word	pxCurrentTCB
 2640 0054 00000000 		.word	xTickCount
 2641              		.cfi_endproc
 2642              	.LFE131:
 2644              		.section	.text.xTaskRemoveFromEventList,"ax",%progbits
 2645              		.align	2
 2646              		.global	xTaskRemoveFromEventList
 2647              		.thumb
 2648              		.thumb_func
 2650              	xTaskRemoveFromEventList:
 2651              	.LFB132:
1710:lib/FreeRTOS/tasks.c **** 	
1711:lib/FreeRTOS/tasks.c **** #endif /* configUSE_TIMERS */
1712:lib/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
1713:lib/FreeRTOS/tasks.c **** 
1714:lib/FreeRTOS/tasks.c **** signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
1715:lib/FreeRTOS/tasks.c **** {
 2652              		.loc 1 1715 0
 2653              		.cfi_startproc
 2654              		@ args = 0, pretend = 0, frame = 16
 2655              		@ frame_needed = 1, uses_anonymous_args = 0
 2656 0000 80B5     		push	{r7, lr}
 2657              	.LCFI63:
 2658              		.cfi_def_cfa_offset 8
 2659 0002 84B0     		sub	sp, sp, #16
 2660              	.LCFI64:
 2661              		.cfi_def_cfa_offset 24
 2662 0004 00AF     		add	r7, sp, #0
 2663              		.cfi_offset 14, -4
 2664              		.cfi_offset 7, -8
 2665              	.LCFI65:
 2666              		.cfi_def_cfa_register 7
 2667 0006 7860     		str	r0, [r7, #4]
1716:lib/FreeRTOS/tasks.c **** tskTCB *pxUnblockedTCB;
1717:lib/FreeRTOS/tasks.c **** portBASE_TYPE xReturn;
1718:lib/FreeRTOS/tasks.c **** 
1719:lib/FreeRTOS/tasks.c **** 	/* THIS FUNCTION MUST BE CALLED WITH INTERRUPTS DISABLED OR THE
1720:lib/FreeRTOS/tasks.c **** 	SCHEDULER SUSPENDED.  It can also be called from within an ISR. */
1721:lib/FreeRTOS/tasks.c **** 
1722:lib/FreeRTOS/tasks.c **** 	/* The event list is sorted in priority order, so we can remove the
1723:lib/FreeRTOS/tasks.c **** 	first in the list, remove the TCB from the delayed list, and add
1724:lib/FreeRTOS/tasks.c **** 	it to the ready list.
1725:lib/FreeRTOS/tasks.c **** 
1726:lib/FreeRTOS/tasks.c **** 	If an event is for a queue that is locked then this function will never
1727:lib/FreeRTOS/tasks.c **** 	get called - the lock count on the queue will get modified instead.  This
1728:lib/FreeRTOS/tasks.c **** 	means we can always expect exclusive access to the event list here.
1729:lib/FreeRTOS/tasks.c **** 	
1730:lib/FreeRTOS/tasks.c **** 	This function assumes that a check has already been made to ensure that
1731:lib/FreeRTOS/tasks.c **** 	pxEventList is not empty. */
1732:lib/FreeRTOS/tasks.c **** 	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
 2668              		.loc 1 1732 0
 2669 0008 7B68     		ldr	r3, [r7, #4]
 2670 000a DB68     		ldr	r3, [r3, #12]
 2671 000c DB68     		ldr	r3, [r3, #12]
 2672 000e BB60     		str	r3, [r7, #8]
1733:lib/FreeRTOS/tasks.c **** 	configASSERT( pxUnblockedTCB );
 2673              		.loc 1 1733 0
 2674 0010 BB68     		ldr	r3, [r7, #8]
 2675 0012 002B     		cmp	r3, #0
 2676 0014 04D1     		bne	.L179
 2677              		.loc 1 1733 0 is_stmt 0 discriminator 1
 2678              	@ 1733 "lib/FreeRTOS/tasks.c" 1
 2679 0016 4FF0BF00 			mov r0, #191								
 2680 001a 80F31188 		msr basepri, r0							
 2681              	
 2682              	@ 0 "" 2
 2683              		.thumb
 2684              	.L180:
 2685              		.loc 1 1733 0 discriminator 2
 2686 001e FEE7     		b	.L180
 2687              	.L179:
1734:lib/FreeRTOS/tasks.c **** 	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
 2688              		.loc 1 1734 0 is_stmt 1
 2689 0020 BB68     		ldr	r3, [r7, #8]
 2690 0022 03F11803 		add	r3, r3, #24
 2691 0026 1846     		mov	r0, r3
 2692 0028 FFF7FEFF 		bl	vListRemove
1735:lib/FreeRTOS/tasks.c **** 
1736:lib/FreeRTOS/tasks.c **** 	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
 2693              		.loc 1 1736 0
 2694 002c 204B     		ldr	r3, .L186
 2695 002e 1B68     		ldr	r3, [r3, #0]
 2696 0030 002B     		cmp	r3, #0
 2697 0032 22D1     		bne	.L181
1737:lib/FreeRTOS/tasks.c **** 	{
1738:lib/FreeRTOS/tasks.c **** 		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
 2698              		.loc 1 1738 0
 2699 0034 BB68     		ldr	r3, [r7, #8]
 2700 0036 03F10403 		add	r3, r3, #4
 2701 003a 1846     		mov	r0, r3
 2702 003c FFF7FEFF 		bl	vListRemove
1739:lib/FreeRTOS/tasks.c **** 		prvAddTaskToReadyQueue( pxUnblockedTCB );
 2703              		.loc 1 1739 0
 2704 0040 BB68     		ldr	r3, [r7, #8]
 2705 0042 DA6A     		ldr	r2, [r3, #44]
 2706 0044 1B4B     		ldr	r3, .L186+4
 2707 0046 1B68     		ldr	r3, [r3, #0]
 2708 0048 9A42     		cmp	r2, r3
 2709 004a 03D9     		bls	.L182
 2710              		.loc 1 1739 0 is_stmt 0 discriminator 1
 2711 004c BB68     		ldr	r3, [r7, #8]
 2712 004e DA6A     		ldr	r2, [r3, #44]
 2713 0050 184B     		ldr	r3, .L186+4
 2714 0052 1A60     		str	r2, [r3, #0]
 2715              	.L182:
 2716              		.loc 1 1739 0 discriminator 2
 2717 0054 BB68     		ldr	r3, [r7, #8]
 2718 0056 DA6A     		ldr	r2, [r3, #44]
 2719 0058 1346     		mov	r3, r2
 2720 005a 4FEA8303 		lsl	r3, r3, #2
 2721 005e 9B18     		adds	r3, r3, r2
 2722 0060 4FEA8303 		lsl	r3, r3, #2
 2723 0064 1A46     		mov	r2, r3
 2724 0066 144B     		ldr	r3, .L186+8
 2725 0068 D218     		adds	r2, r2, r3
 2726 006a BB68     		ldr	r3, [r7, #8]
 2727 006c 03F10403 		add	r3, r3, #4
 2728 0070 1046     		mov	r0, r2
 2729 0072 1946     		mov	r1, r3
 2730 0074 FFF7FEFF 		bl	vListInsertEnd
 2731 0078 06E0     		b	.L183
 2732              	.L181:
1740:lib/FreeRTOS/tasks.c **** 	}
1741:lib/FreeRTOS/tasks.c **** 	else
1742:lib/FreeRTOS/tasks.c **** 	{
1743:lib/FreeRTOS/tasks.c **** 		/* We cannot access the delayed or ready lists, so will hold this
1744:lib/FreeRTOS/tasks.c **** 		task pending until the scheduler is resumed. */
1745:lib/FreeRTOS/tasks.c **** 		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
 2733              		.loc 1 1745 0 is_stmt 1
 2734 007a BB68     		ldr	r3, [r7, #8]
 2735 007c 03F11803 		add	r3, r3, #24
 2736 0080 0E48     		ldr	r0, .L186+12
 2737 0082 1946     		mov	r1, r3
 2738 0084 FFF7FEFF 		bl	vListInsertEnd
 2739              	.L183:
1746:lib/FreeRTOS/tasks.c **** 	}
1747:lib/FreeRTOS/tasks.c **** 
1748:lib/FreeRTOS/tasks.c **** 	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
 2740              		.loc 1 1748 0
 2741 0088 BB68     		ldr	r3, [r7, #8]
 2742 008a DA6A     		ldr	r2, [r3, #44]
 2743 008c 0C4B     		ldr	r3, .L186+16
 2744 008e 1B68     		ldr	r3, [r3, #0]
 2745 0090 DB6A     		ldr	r3, [r3, #44]
 2746 0092 9A42     		cmp	r2, r3
 2747 0094 03D3     		bcc	.L184
1749:lib/FreeRTOS/tasks.c **** 	{
1750:lib/FreeRTOS/tasks.c **** 		/* Return true if the task removed from the event list has
1751:lib/FreeRTOS/tasks.c **** 		a higher priority than the calling task.  This allows
1752:lib/FreeRTOS/tasks.c **** 		the calling task to know if it should force a context
1753:lib/FreeRTOS/tasks.c **** 		switch now. */
1754:lib/FreeRTOS/tasks.c **** 		xReturn = pdTRUE;
 2748              		.loc 1 1754 0
 2749 0096 4FF00103 		mov	r3, #1
 2750 009a FB60     		str	r3, [r7, #12]
 2751 009c 02E0     		b	.L185
 2752              	.L184:
1755:lib/FreeRTOS/tasks.c **** 	}
1756:lib/FreeRTOS/tasks.c **** 	else
1757:lib/FreeRTOS/tasks.c **** 	{
1758:lib/FreeRTOS/tasks.c **** 		xReturn = pdFALSE;
 2753              		.loc 1 1758 0
 2754 009e 4FF00003 		mov	r3, #0
 2755 00a2 FB60     		str	r3, [r7, #12]
 2756              	.L185:
1759:lib/FreeRTOS/tasks.c **** 	}
1760:lib/FreeRTOS/tasks.c **** 
1761:lib/FreeRTOS/tasks.c **** 	return xReturn;
 2757              		.loc 1 1761 0
 2758 00a4 FB68     		ldr	r3, [r7, #12]
1762:lib/FreeRTOS/tasks.c **** }
 2759              		.loc 1 1762 0
 2760 00a6 1846     		mov	r0, r3
 2761 00a8 07F11007 		add	r7, r7, #16
 2762 00ac BD46     		mov	sp, r7
 2763 00ae 80BD     		pop	{r7, pc}
 2764              	.L187:
 2765              		.align	2
 2766              	.L186:
 2767 00b0 00000000 		.word	uxSchedulerSuspended
 2768 00b4 00000000 		.word	uxTopReadyPriority
 2769 00b8 00000000 		.word	pxReadyTasksLists
 2770 00bc 00000000 		.word	xPendingReadyList
 2771 00c0 00000000 		.word	pxCurrentTCB
 2772              		.cfi_endproc
 2773              	.LFE132:
 2775              		.section	.text.vTaskSetTimeOutState,"ax",%progbits
 2776              		.align	2
 2777              		.global	vTaskSetTimeOutState
 2778              		.thumb
 2779              		.thumb_func
 2781              	vTaskSetTimeOutState:
 2782              	.LFB133:
1763:lib/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
1764:lib/FreeRTOS/tasks.c **** 
1765:lib/FreeRTOS/tasks.c **** void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
1766:lib/FreeRTOS/tasks.c **** {
 2783              		.loc 1 1766 0
 2784              		.cfi_startproc
 2785              		@ args = 0, pretend = 0, frame = 8
 2786              		@ frame_needed = 1, uses_anonymous_args = 0
 2787              		@ link register save eliminated.
 2788 0000 80B4     		push	{r7}
 2789              	.LCFI66:
 2790              		.cfi_def_cfa_offset 4
 2791 0002 83B0     		sub	sp, sp, #12
 2792              	.LCFI67:
 2793              		.cfi_def_cfa_offset 16
 2794 0004 00AF     		add	r7, sp, #0
 2795              		.cfi_offset 7, -4
 2796              	.LCFI68:
 2797              		.cfi_def_cfa_register 7
 2798 0006 7860     		str	r0, [r7, #4]
1767:lib/FreeRTOS/tasks.c **** 	configASSERT( pxTimeOut );
 2799              		.loc 1 1767 0
 2800 0008 7B68     		ldr	r3, [r7, #4]
 2801 000a 002B     		cmp	r3, #0
 2802 000c 04D1     		bne	.L189
 2803              		.loc 1 1767 0 is_stmt 0 discriminator 1
 2804              	@ 1767 "lib/FreeRTOS/tasks.c" 1
 2805 000e 4FF0BF00 			mov r0, #191								
 2806 0012 80F31188 		msr basepri, r0							
 2807              	
 2808              	@ 0 "" 2
 2809              		.thumb
 2810              	.L190:
 2811              		.loc 1 1767 0 discriminator 2
 2812 0016 FEE7     		b	.L190
 2813              	.L189:
1768:lib/FreeRTOS/tasks.c **** 	pxTimeOut->xOverflowCount = xNumOfOverflows;
 2814              		.loc 1 1768 0 is_stmt 1
 2815 0018 064B     		ldr	r3, .L191
 2816 001a 1A68     		ldr	r2, [r3, #0]
 2817 001c 7B68     		ldr	r3, [r7, #4]
 2818 001e 1A60     		str	r2, [r3, #0]
1769:lib/FreeRTOS/tasks.c **** 	pxTimeOut->xTimeOnEntering = xTickCount;
 2819              		.loc 1 1769 0
 2820 0020 054B     		ldr	r3, .L191+4
 2821 0022 1A68     		ldr	r2, [r3, #0]
 2822 0024 7B68     		ldr	r3, [r7, #4]
 2823 0026 5A60     		str	r2, [r3, #4]
1770:lib/FreeRTOS/tasks.c **** }
 2824              		.loc 1 1770 0
 2825 0028 07F10C07 		add	r7, r7, #12
 2826 002c BD46     		mov	sp, r7
 2827 002e 80BC     		pop	{r7}
 2828 0030 7047     		bx	lr
 2829              	.L192:
 2830 0032 00BF     		.align	2
 2831              	.L191:
 2832 0034 00000000 		.word	xNumOfOverflows
 2833 0038 00000000 		.word	xTickCount
 2834              		.cfi_endproc
 2835              	.LFE133:
 2837              		.section	.text.xTaskCheckForTimeOut,"ax",%progbits
 2838              		.align	2
 2839              		.global	xTaskCheckForTimeOut
 2840              		.thumb
 2841              		.thumb_func
 2843              	xTaskCheckForTimeOut:
 2844              	.LFB134:
1771:lib/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
1772:lib/FreeRTOS/tasks.c **** 
1773:lib/FreeRTOS/tasks.c **** portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToW
1774:lib/FreeRTOS/tasks.c **** {
 2845              		.loc 1 1774 0
 2846              		.cfi_startproc
 2847              		@ args = 0, pretend = 0, frame = 16
 2848              		@ frame_needed = 1, uses_anonymous_args = 0
 2849 0000 80B5     		push	{r7, lr}
 2850              	.LCFI69:
 2851              		.cfi_def_cfa_offset 8
 2852 0002 84B0     		sub	sp, sp, #16
 2853              	.LCFI70:
 2854              		.cfi_def_cfa_offset 24
 2855 0004 00AF     		add	r7, sp, #0
 2856              		.cfi_offset 14, -4
 2857              		.cfi_offset 7, -8
 2858              	.LCFI71:
 2859              		.cfi_def_cfa_register 7
 2860 0006 7860     		str	r0, [r7, #4]
 2861 0008 3960     		str	r1, [r7, #0]
1775:lib/FreeRTOS/tasks.c **** portBASE_TYPE xReturn;
1776:lib/FreeRTOS/tasks.c **** 
1777:lib/FreeRTOS/tasks.c **** 	configASSERT( pxTimeOut );
 2862              		.loc 1 1777 0
 2863 000a 7B68     		ldr	r3, [r7, #4]
 2864 000c 002B     		cmp	r3, #0
 2865 000e 04D1     		bne	.L194
 2866              		.loc 1 1777 0 is_stmt 0 discriminator 1
 2867              	@ 1777 "lib/FreeRTOS/tasks.c" 1
 2868 0010 4FF0BF00 			mov r0, #191								
 2869 0014 80F31188 		msr basepri, r0							
 2870              	
 2871              	@ 0 "" 2
 2872              		.thumb
 2873              	.L195:
 2874              		.loc 1 1777 0 discriminator 2
 2875 0018 FEE7     		b	.L195
 2876              	.L194:
1778:lib/FreeRTOS/tasks.c **** 	configASSERT( pxTicksToWait );
 2877              		.loc 1 1778 0 is_stmt 1
 2878 001a 3B68     		ldr	r3, [r7, #0]
 2879 001c 002B     		cmp	r3, #0
 2880 001e 04D1     		bne	.L196
 2881              		.loc 1 1778 0 is_stmt 0 discriminator 1
 2882              	@ 1778 "lib/FreeRTOS/tasks.c" 1
 2883 0020 4FF0BF00 			mov r0, #191								
 2884 0024 80F31188 		msr basepri, r0							
 2885              	
 2886              	@ 0 "" 2
 2887              		.thumb
 2888              	.L197:
 2889              		.loc 1 1778 0 discriminator 2
 2890 0028 FEE7     		b	.L197
 2891              	.L196:
1779:lib/FreeRTOS/tasks.c **** 
1780:lib/FreeRTOS/tasks.c **** 	taskENTER_CRITICAL();
 2892              		.loc 1 1780 0 is_stmt 1
 2893 002a FFF7FEFF 		bl	vPortEnterCritical
1781:lib/FreeRTOS/tasks.c **** 	{
1782:lib/FreeRTOS/tasks.c **** 		#if ( INCLUDE_vTaskSuspend == 1 )
1783:lib/FreeRTOS/tasks.c **** 			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
1784:lib/FreeRTOS/tasks.c **** 			the maximum block time then the task should block indefinitely, and
1785:lib/FreeRTOS/tasks.c **** 			therefore never time out. */
1786:lib/FreeRTOS/tasks.c **** 			if( *pxTicksToWait == portMAX_DELAY )
 2894              		.loc 1 1786 0
 2895 002e 3B68     		ldr	r3, [r7, #0]
 2896 0030 1B68     		ldr	r3, [r3, #0]
 2897 0032 B3F1FF3F 		cmp	r3, #-1
 2898 0036 03D1     		bne	.L198
1787:lib/FreeRTOS/tasks.c **** 			{
1788:lib/FreeRTOS/tasks.c **** 				xReturn = pdFALSE;
 2899              		.loc 1 1788 0
 2900 0038 4FF00003 		mov	r3, #0
 2901 003c FB60     		str	r3, [r7, #12]
 2902 003e 2CE0     		b	.L199
 2903              	.L198:
1789:lib/FreeRTOS/tasks.c **** 			}
1790:lib/FreeRTOS/tasks.c **** 			else /* We are not blocking indefinitely, perform the checks below. */
1791:lib/FreeRTOS/tasks.c **** 		#endif
1792:lib/FreeRTOS/tasks.c **** 
1793:lib/FreeRTOS/tasks.c **** 		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTi
 2904              		.loc 1 1793 0
 2905 0040 7B68     		ldr	r3, [r7, #4]
 2906 0042 1A68     		ldr	r2, [r3, #0]
 2907 0044 194B     		ldr	r3, .L202
 2908 0046 1B68     		ldr	r3, [r3, #0]
 2909 0048 9A42     		cmp	r2, r3
 2910 004a 09D0     		beq	.L200
 2911              		.loc 1 1793 0 is_stmt 0 discriminator 1
 2912 004c 7B68     		ldr	r3, [r7, #4]
 2913 004e 5A68     		ldr	r2, [r3, #4]
 2914 0050 174B     		ldr	r3, .L202+4
 2915 0052 1B68     		ldr	r3, [r3, #0]
 2916 0054 9A42     		cmp	r2, r3
 2917 0056 03D8     		bhi	.L200
1794:lib/FreeRTOS/tasks.c **** 		{
1795:lib/FreeRTOS/tasks.c **** 			/* The tick count is greater than the time at which vTaskSetTimeout()
1796:lib/FreeRTOS/tasks.c **** 			was called, but has also overflowed since vTaskSetTimeOut() was called.
1797:lib/FreeRTOS/tasks.c **** 			It must have wrapped all the way around and gone past us again. This
1798:lib/FreeRTOS/tasks.c **** 			passed since vTaskSetTimeout() was called. */
1799:lib/FreeRTOS/tasks.c **** 			xReturn = pdTRUE;
 2918              		.loc 1 1799 0 is_stmt 1
 2919 0058 4FF00103 		mov	r3, #1
 2920 005c FB60     		str	r3, [r7, #12]
 2921 005e 1CE0     		b	.L199
 2922              	.L200:
1800:lib/FreeRTOS/tasks.c **** 		}
1801:lib/FreeRTOS/tasks.c **** 		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEn
 2923              		.loc 1 1801 0
 2924 0060 134B     		ldr	r3, .L202+4
 2925 0062 1A68     		ldr	r2, [r3, #0]
 2926 0064 7B68     		ldr	r3, [r7, #4]
 2927 0066 5B68     		ldr	r3, [r3, #4]
 2928 0068 D21A     		subs	r2, r2, r3
 2929 006a 3B68     		ldr	r3, [r7, #0]
 2930 006c 1B68     		ldr	r3, [r3, #0]
 2931 006e 9A42     		cmp	r2, r3
 2932 0070 10D2     		bcs	.L201
1802:lib/FreeRTOS/tasks.c **** 		{
1803:lib/FreeRTOS/tasks.c **** 			/* Not a genuine timeout. Adjust parameters for time remaining. */
1804:lib/FreeRTOS/tasks.c **** 			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
 2933              		.loc 1 1804 0
 2934 0072 3B68     		ldr	r3, [r7, #0]
 2935 0074 1A68     		ldr	r2, [r3, #0]
 2936 0076 7B68     		ldr	r3, [r7, #4]
 2937 0078 5968     		ldr	r1, [r3, #4]
 2938 007a 0D4B     		ldr	r3, .L202+4
 2939 007c 1B68     		ldr	r3, [r3, #0]
 2940 007e CB1A     		subs	r3, r1, r3
 2941 0080 D218     		adds	r2, r2, r3
 2942 0082 3B68     		ldr	r3, [r7, #0]
 2943 0084 1A60     		str	r2, [r3, #0]
1805:lib/FreeRTOS/tasks.c **** 			vTaskSetTimeOutState( pxTimeOut );
 2944              		.loc 1 1805 0
 2945 0086 7868     		ldr	r0, [r7, #4]
 2946 0088 FFF7FEFF 		bl	vTaskSetTimeOutState
1806:lib/FreeRTOS/tasks.c **** 			xReturn = pdFALSE;
 2947              		.loc 1 1806 0
 2948 008c 4FF00003 		mov	r3, #0
 2949 0090 FB60     		str	r3, [r7, #12]
 2950 0092 02E0     		b	.L199
 2951              	.L201:
1807:lib/FreeRTOS/tasks.c **** 		}
1808:lib/FreeRTOS/tasks.c **** 		else
1809:lib/FreeRTOS/tasks.c **** 		{
1810:lib/FreeRTOS/tasks.c **** 			xReturn = pdTRUE;
 2952              		.loc 1 1810 0
 2953 0094 4FF00103 		mov	r3, #1
 2954 0098 FB60     		str	r3, [r7, #12]
 2955              	.L199:
1811:lib/FreeRTOS/tasks.c **** 		}
1812:lib/FreeRTOS/tasks.c **** 	}
1813:lib/FreeRTOS/tasks.c **** 	taskEXIT_CRITICAL();
 2956              		.loc 1 1813 0
 2957 009a FFF7FEFF 		bl	vPortExitCritical
1814:lib/FreeRTOS/tasks.c **** 
1815:lib/FreeRTOS/tasks.c **** 	return xReturn;
 2958              		.loc 1 1815 0
 2959 009e FB68     		ldr	r3, [r7, #12]
1816:lib/FreeRTOS/tasks.c **** }
 2960              		.loc 1 1816 0
 2961 00a0 1846     		mov	r0, r3
 2962 00a2 07F11007 		add	r7, r7, #16
 2963 00a6 BD46     		mov	sp, r7
 2964 00a8 80BD     		pop	{r7, pc}
 2965              	.L203:
 2966 00aa 00BF     		.align	2
 2967              	.L202:
 2968 00ac 00000000 		.word	xNumOfOverflows
 2969 00b0 00000000 		.word	xTickCount
 2970              		.cfi_endproc
 2971              	.LFE134:
 2973              		.section	.text.vTaskMissedYield,"ax",%progbits
 2974              		.align	2
 2975              		.global	vTaskMissedYield
 2976              		.thumb
 2977              		.thumb_func
 2979              	vTaskMissedYield:
 2980              	.LFB135:
1817:lib/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
1818:lib/FreeRTOS/tasks.c **** 
1819:lib/FreeRTOS/tasks.c **** void vTaskMissedYield( void )
1820:lib/FreeRTOS/tasks.c **** {
 2981              		.loc 1 1820 0
 2982              		.cfi_startproc
 2983              		@ args = 0, pretend = 0, frame = 0
 2984              		@ frame_needed = 1, uses_anonymous_args = 0
 2985              		@ link register save eliminated.
 2986 0000 80B4     		push	{r7}
 2987              	.LCFI72:
 2988              		.cfi_def_cfa_offset 4
 2989 0002 00AF     		add	r7, sp, #0
 2990              		.cfi_offset 7, -4
 2991              	.LCFI73:
 2992              		.cfi_def_cfa_register 7
1821:lib/FreeRTOS/tasks.c **** 	xMissedYield = pdTRUE;
 2993              		.loc 1 1821 0
 2994 0004 034B     		ldr	r3, .L205
 2995 0006 4FF00102 		mov	r2, #1
 2996 000a 1A60     		str	r2, [r3, #0]
1822:lib/FreeRTOS/tasks.c **** }
 2997              		.loc 1 1822 0
 2998 000c BD46     		mov	sp, r7
 2999 000e 80BC     		pop	{r7}
 3000 0010 7047     		bx	lr
 3001              	.L206:
 3002 0012 00BF     		.align	2
 3003              	.L205:
 3004 0014 00000000 		.word	xMissedYield
 3005              		.cfi_endproc
 3006              	.LFE135:
 3008              		.section	.text.uxTaskGetTaskNumber,"ax",%progbits
 3009              		.align	2
 3010              		.global	uxTaskGetTaskNumber
 3011              		.thumb
 3012              		.thumb_func
 3014              	uxTaskGetTaskNumber:
 3015              	.LFB136:
1823:lib/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
1824:lib/FreeRTOS/tasks.c **** 
1825:lib/FreeRTOS/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
1826:lib/FreeRTOS/tasks.c **** 	unsigned portBASE_TYPE uxTaskGetTaskNumber( xTaskHandle xTask )
1827:lib/FreeRTOS/tasks.c **** 	{
 3016              		.loc 1 1827 0
 3017              		.cfi_startproc
 3018              		@ args = 0, pretend = 0, frame = 16
 3019              		@ frame_needed = 1, uses_anonymous_args = 0
 3020              		@ link register save eliminated.
 3021 0000 80B4     		push	{r7}
 3022              	.LCFI74:
 3023              		.cfi_def_cfa_offset 4
 3024 0002 85B0     		sub	sp, sp, #20
 3025              	.LCFI75:
 3026              		.cfi_def_cfa_offset 24
 3027 0004 00AF     		add	r7, sp, #0
 3028              		.cfi_offset 7, -4
 3029              	.LCFI76:
 3030              		.cfi_def_cfa_register 7
 3031 0006 7860     		str	r0, [r7, #4]
1828:lib/FreeRTOS/tasks.c **** 	unsigned portBASE_TYPE uxReturn;
1829:lib/FreeRTOS/tasks.c **** 	tskTCB *pxTCB;
1830:lib/FreeRTOS/tasks.c **** 	
1831:lib/FreeRTOS/tasks.c **** 		if( xTask != NULL )
 3032              		.loc 1 1831 0
 3033 0008 7B68     		ldr	r3, [r7, #4]
 3034 000a 002B     		cmp	r3, #0
 3035 000c 05D0     		beq	.L208
1832:lib/FreeRTOS/tasks.c **** 		{
1833:lib/FreeRTOS/tasks.c **** 			pxTCB = ( tskTCB * ) xTask;
 3036              		.loc 1 1833 0
 3037 000e 7B68     		ldr	r3, [r7, #4]
 3038 0010 BB60     		str	r3, [r7, #8]
1834:lib/FreeRTOS/tasks.c **** 			uxReturn = pxTCB->uxTaskNumber;
 3039              		.loc 1 1834 0
 3040 0012 BB68     		ldr	r3, [r7, #8]
 3041 0014 5B6C     		ldr	r3, [r3, #68]
 3042 0016 FB60     		str	r3, [r7, #12]
 3043 0018 02E0     		b	.L209
 3044              	.L208:
1835:lib/FreeRTOS/tasks.c **** 		}
1836:lib/FreeRTOS/tasks.c **** 		else
1837:lib/FreeRTOS/tasks.c **** 		{
1838:lib/FreeRTOS/tasks.c **** 			uxReturn = 0U;
 3045              		.loc 1 1838 0
 3046 001a 4FF00003 		mov	r3, #0
 3047 001e FB60     		str	r3, [r7, #12]
 3048              	.L209:
1839:lib/FreeRTOS/tasks.c **** 		}
1840:lib/FreeRTOS/tasks.c **** 		
1841:lib/FreeRTOS/tasks.c **** 		return uxReturn;
 3049              		.loc 1 1841 0
 3050 0020 FB68     		ldr	r3, [r7, #12]
1842:lib/FreeRTOS/tasks.c **** 	}
 3051              		.loc 1 1842 0
 3052 0022 1846     		mov	r0, r3
 3053 0024 07F11407 		add	r7, r7, #20
 3054 0028 BD46     		mov	sp, r7
 3055 002a 80BC     		pop	{r7}
 3056 002c 7047     		bx	lr
 3057              		.cfi_endproc
 3058              	.LFE136:
 3060 002e 00BF     		.section	.text.vTaskSetTaskNumber,"ax",%progbits
 3061              		.align	2
 3062              		.global	vTaskSetTaskNumber
 3063              		.thumb
 3064              		.thumb_func
 3066              	vTaskSetTaskNumber:
 3067              	.LFB137:
1843:lib/FreeRTOS/tasks.c **** #endif
1844:lib/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
1845:lib/FreeRTOS/tasks.c **** 
1846:lib/FreeRTOS/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
1847:lib/FreeRTOS/tasks.c **** 	void vTaskSetTaskNumber( xTaskHandle xTask, unsigned portBASE_TYPE uxHandle )
1848:lib/FreeRTOS/tasks.c **** 	{
 3068              		.loc 1 1848 0
 3069              		.cfi_startproc
 3070              		@ args = 0, pretend = 0, frame = 16
 3071              		@ frame_needed = 1, uses_anonymous_args = 0
 3072              		@ link register save eliminated.
 3073 0000 80B4     		push	{r7}
 3074              	.LCFI77:
 3075              		.cfi_def_cfa_offset 4
 3076 0002 85B0     		sub	sp, sp, #20
 3077              	.LCFI78:
 3078              		.cfi_def_cfa_offset 24
 3079 0004 00AF     		add	r7, sp, #0
 3080              		.cfi_offset 7, -4
 3081              	.LCFI79:
 3082              		.cfi_def_cfa_register 7
 3083 0006 7860     		str	r0, [r7, #4]
 3084 0008 3960     		str	r1, [r7, #0]
1849:lib/FreeRTOS/tasks.c **** 	tskTCB *pxTCB;
1850:lib/FreeRTOS/tasks.c **** 	
1851:lib/FreeRTOS/tasks.c **** 		if( xTask != NULL )
 3085              		.loc 1 1851 0
 3086 000a 7B68     		ldr	r3, [r7, #4]
 3087 000c 002B     		cmp	r3, #0
 3088 000e 04D0     		beq	.L210
1852:lib/FreeRTOS/tasks.c **** 		{
1853:lib/FreeRTOS/tasks.c **** 			pxTCB = ( tskTCB * ) xTask;
 3089              		.loc 1 1853 0
 3090 0010 7B68     		ldr	r3, [r7, #4]
 3091 0012 FB60     		str	r3, [r7, #12]
1854:lib/FreeRTOS/tasks.c **** 			pxTCB->uxTaskNumber = uxHandle;
 3092              		.loc 1 1854 0
 3093 0014 FB68     		ldr	r3, [r7, #12]
 3094 0016 3A68     		ldr	r2, [r7, #0]
 3095 0018 5A64     		str	r2, [r3, #68]
 3096              	.L210:
1855:lib/FreeRTOS/tasks.c **** 		}
1856:lib/FreeRTOS/tasks.c **** 	}
 3097              		.loc 1 1856 0
 3098 001a 07F11407 		add	r7, r7, #20
 3099 001e BD46     		mov	sp, r7
 3100 0020 80BC     		pop	{r7}
 3101 0022 7047     		bx	lr
 3102              		.cfi_endproc
 3103              	.LFE137:
 3105              		.section	.text.prvIdleTask,"ax",%progbits
 3106              		.align	2
 3107              		.thumb
 3108              		.thumb_func
 3110              	prvIdleTask:
 3111              	.LFB138:
1857:lib/FreeRTOS/tasks.c **** #endif
1858:lib/FreeRTOS/tasks.c **** 
1859:lib/FreeRTOS/tasks.c **** 
1860:lib/FreeRTOS/tasks.c **** /*
1861:lib/FreeRTOS/tasks.c ****  * -----------------------------------------------------------
1862:lib/FreeRTOS/tasks.c ****  * The Idle task.
1863:lib/FreeRTOS/tasks.c ****  * ----------------------------------------------------------
1864:lib/FreeRTOS/tasks.c ****  *
1865:lib/FreeRTOS/tasks.c ****  * The portTASK_FUNCTION() macro is used to allow port/compiler specific
1866:lib/FreeRTOS/tasks.c ****  * language extensions.  The equivalent prototype for this function is:
1867:lib/FreeRTOS/tasks.c ****  *
1868:lib/FreeRTOS/tasks.c ****  * void prvIdleTask( void *pvParameters );
1869:lib/FreeRTOS/tasks.c ****  *
1870:lib/FreeRTOS/tasks.c ****  */
1871:lib/FreeRTOS/tasks.c **** static portTASK_FUNCTION( prvIdleTask, pvParameters )
1872:lib/FreeRTOS/tasks.c **** {
 3112              		.loc 1 1872 0
 3113              		.cfi_startproc
 3114              		@ args = 0, pretend = 0, frame = 8
 3115              		@ frame_needed = 1, uses_anonymous_args = 0
 3116 0000 80B5     		push	{r7, lr}
 3117              	.LCFI80:
 3118              		.cfi_def_cfa_offset 8
 3119 0002 82B0     		sub	sp, sp, #8
 3120              	.LCFI81:
 3121              		.cfi_def_cfa_offset 16
 3122 0004 00AF     		add	r7, sp, #0
 3123              		.cfi_offset 14, -4
 3124              		.cfi_offset 7, -8
 3125              	.LCFI82:
 3126              		.cfi_def_cfa_register 7
 3127 0006 7860     		str	r0, [r7, #4]
 3128              	.L214:
1873:lib/FreeRTOS/tasks.c **** 	/* Stop warnings. */
1874:lib/FreeRTOS/tasks.c **** 	( void ) pvParameters;
1875:lib/FreeRTOS/tasks.c **** 
1876:lib/FreeRTOS/tasks.c **** 	for( ;; )
1877:lib/FreeRTOS/tasks.c **** 	{
1878:lib/FreeRTOS/tasks.c **** 		/* See if any tasks have been deleted. */
1879:lib/FreeRTOS/tasks.c **** 		prvCheckTasksWaitingTermination();
 3129              		.loc 1 1879 0
 3130 0008 FFF7FEFF 		bl	prvCheckTasksWaitingTermination
1880:lib/FreeRTOS/tasks.c **** 
1881:lib/FreeRTOS/tasks.c **** 		#if ( configUSE_PREEMPTION == 0 )
1882:lib/FreeRTOS/tasks.c **** 		{
1883:lib/FreeRTOS/tasks.c **** 			/* If we are not using preemption we keep forcing a task switch to
1884:lib/FreeRTOS/tasks.c **** 			see if any other task has become available.  If we are using
1885:lib/FreeRTOS/tasks.c **** 			preemption we don't need to do this as any task becoming available
1886:lib/FreeRTOS/tasks.c **** 			will automatically get the processor anyway. */
1887:lib/FreeRTOS/tasks.c **** 			taskYIELD();
1888:lib/FreeRTOS/tasks.c **** 		}
1889:lib/FreeRTOS/tasks.c **** 		#endif
1890:lib/FreeRTOS/tasks.c **** 
1891:lib/FreeRTOS/tasks.c **** 		#if ( ( configUSE_PREEMPTION == 1 ) && ( configIDLE_SHOULD_YIELD == 1 ) )
1892:lib/FreeRTOS/tasks.c **** 		{
1893:lib/FreeRTOS/tasks.c **** 			/* When using preemption tasks of equal priority will be
1894:lib/FreeRTOS/tasks.c **** 			timesliced.  If a task that is sharing the idle priority is ready
1895:lib/FreeRTOS/tasks.c **** 			to run then the idle task should yield before the end of the
1896:lib/FreeRTOS/tasks.c **** 			timeslice.
1897:lib/FreeRTOS/tasks.c **** 
1898:lib/FreeRTOS/tasks.c **** 			A critical region is not required here as we are just reading from
1899:lib/FreeRTOS/tasks.c **** 			the list, and an occasional incorrect value will not matter.  If
1900:lib/FreeRTOS/tasks.c **** 			the ready list at the idle priority contains more than one task
1901:lib/FreeRTOS/tasks.c **** 			then a task other than the idle task is ready to execute. */
1902:lib/FreeRTOS/tasks.c **** 			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_
 3131              		.loc 1 1902 0
 3132 000c 044B     		ldr	r3, .L215
 3133 000e 1B68     		ldr	r3, [r3, #0]
 3134 0010 012B     		cmp	r3, #1
 3135 0012 01D9     		bls	.L213
1903:lib/FreeRTOS/tasks.c **** 			{
1904:lib/FreeRTOS/tasks.c **** 				taskYIELD();
 3136              		.loc 1 1904 0
 3137 0014 FFF7FEFF 		bl	vPortYieldFromISR
 3138              	.L213:
 3139              	.LBB7:
1905:lib/FreeRTOS/tasks.c **** 			}
1906:lib/FreeRTOS/tasks.c **** 		}
1907:lib/FreeRTOS/tasks.c **** 		#endif
1908:lib/FreeRTOS/tasks.c **** 
1909:lib/FreeRTOS/tasks.c **** 		#if ( configUSE_IDLE_HOOK == 1 )
1910:lib/FreeRTOS/tasks.c **** 		{
1911:lib/FreeRTOS/tasks.c **** 			extern void vApplicationIdleHook( void );
1912:lib/FreeRTOS/tasks.c **** 
1913:lib/FreeRTOS/tasks.c **** 			/* Call the user defined function from within the idle task.  This
1914:lib/FreeRTOS/tasks.c **** 			allows the application designer to add background functionality
1915:lib/FreeRTOS/tasks.c **** 			without the overhead of a separate task.
1916:lib/FreeRTOS/tasks.c **** 			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
1917:lib/FreeRTOS/tasks.c **** 			CALL A FUNCTION THAT MIGHT BLOCK. */
1918:lib/FreeRTOS/tasks.c **** 			vApplicationIdleHook();
 3140              		.loc 1 1918 0
 3141 0018 FFF7FEFF 		bl	vApplicationIdleHook
 3142              	.LBE7:
1919:lib/FreeRTOS/tasks.c **** 		}
1920:lib/FreeRTOS/tasks.c **** 		#endif
1921:lib/FreeRTOS/tasks.c **** 	}
 3143              		.loc 1 1921 0
 3144 001c F4E7     		b	.L214
 3145              	.L216:
 3146 001e 00BF     		.align	2
 3147              	.L215:
 3148 0020 00000000 		.word	pxReadyTasksLists
 3149              		.cfi_endproc
 3150              	.LFE138:
 3152              		.section	.text.prvInitialiseTCBVariables,"ax",%progbits
 3153              		.align	2
 3154              		.thumb
 3155              		.thumb_func
 3157              	prvInitialiseTCBVariables:
 3158              	.LFB139:
1922:lib/FreeRTOS/tasks.c **** } /*lint !e715 pvParameters is not accessed but all task functions require the same prototype. */
1923:lib/FreeRTOS/tasks.c **** 
1924:lib/FreeRTOS/tasks.c **** 
1925:lib/FreeRTOS/tasks.c **** 
1926:lib/FreeRTOS/tasks.c **** 
1927:lib/FreeRTOS/tasks.c **** 
1928:lib/FreeRTOS/tasks.c **** 
1929:lib/FreeRTOS/tasks.c **** 
1930:lib/FreeRTOS/tasks.c **** /*-----------------------------------------------------------
1931:lib/FreeRTOS/tasks.c ****  * File private functions documented at the top of the file.
1932:lib/FreeRTOS/tasks.c ****  *----------------------------------------------------------*/
1933:lib/FreeRTOS/tasks.c **** 
1934:lib/FreeRTOS/tasks.c **** 
1935:lib/FreeRTOS/tasks.c **** 
1936:lib/FreeRTOS/tasks.c **** static void prvInitialiseTCBVariables( tskTCB *pxTCB, const signed char * const pcName, unsigned po
1937:lib/FreeRTOS/tasks.c **** {
 3159              		.loc 1 1937 0
 3160              		.cfi_startproc
 3161              		@ args = 4, pretend = 0, frame = 16
 3162              		@ frame_needed = 1, uses_anonymous_args = 0
 3163 0000 80B5     		push	{r7, lr}
 3164              	.LCFI83:
 3165              		.cfi_def_cfa_offset 8
 3166 0002 84B0     		sub	sp, sp, #16
 3167              	.LCFI84:
 3168              		.cfi_def_cfa_offset 24
 3169 0004 00AF     		add	r7, sp, #0
 3170              		.cfi_offset 14, -4
 3171              		.cfi_offset 7, -8
 3172              	.LCFI85:
 3173              		.cfi_def_cfa_register 7
 3174 0006 F860     		str	r0, [r7, #12]
 3175 0008 B960     		str	r1, [r7, #8]
 3176 000a 7A60     		str	r2, [r7, #4]
 3177 000c 3B60     		str	r3, [r7, #0]
1938:lib/FreeRTOS/tasks.c **** 	/* Store the function name in the TCB. */
1939:lib/FreeRTOS/tasks.c **** 	#if configMAX_TASK_NAME_LEN > 1
1940:lib/FreeRTOS/tasks.c **** 	{
1941:lib/FreeRTOS/tasks.c **** 		/* Don't bring strncpy into the build unnecessarily. */
1942:lib/FreeRTOS/tasks.c **** 		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK
 3178              		.loc 1 1942 0
 3179 000e FB68     		ldr	r3, [r7, #12]
 3180 0010 03F13403 		add	r3, r3, #52
 3181 0014 1846     		mov	r0, r3
 3182 0016 B968     		ldr	r1, [r7, #8]
 3183 0018 4FF00A02 		mov	r2, #10
 3184 001c FFF7FEFF 		bl	strncpy
1943:lib/FreeRTOS/tasks.c **** 	}
1944:lib/FreeRTOS/tasks.c **** 	#endif
1945:lib/FreeRTOS/tasks.c **** 	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed 
 3185              		.loc 1 1945 0
 3186 0020 FB68     		ldr	r3, [r7, #12]
 3187 0022 4FF00002 		mov	r2, #0
 3188 0026 83F83D20 		strb	r2, [r3, #61]
1946:lib/FreeRTOS/tasks.c **** 
1947:lib/FreeRTOS/tasks.c **** 	/* This is used as an array index so must ensure it's not too large.  First
1948:lib/FreeRTOS/tasks.c **** 	remove the privilege bit if one is present. */
1949:lib/FreeRTOS/tasks.c **** 	if( uxPriority >= configMAX_PRIORITIES )
 3189              		.loc 1 1949 0
 3190 002a 7B68     		ldr	r3, [r7, #4]
 3191 002c 042B     		cmp	r3, #4
 3192 002e 02D9     		bls	.L218
1950:lib/FreeRTOS/tasks.c **** 	{
1951:lib/FreeRTOS/tasks.c **** 		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
 3193              		.loc 1 1951 0
 3194 0030 4FF00403 		mov	r3, #4
 3195 0034 7B60     		str	r3, [r7, #4]
 3196              	.L218:
1952:lib/FreeRTOS/tasks.c **** 	}
1953:lib/FreeRTOS/tasks.c **** 
1954:lib/FreeRTOS/tasks.c **** 	pxTCB->uxPriority = uxPriority;
 3197              		.loc 1 1954 0
 3198 0036 FB68     		ldr	r3, [r7, #12]
 3199 0038 7A68     		ldr	r2, [r7, #4]
 3200 003a DA62     		str	r2, [r3, #44]
1955:lib/FreeRTOS/tasks.c **** 	#if ( configUSE_MUTEXES == 1 )
1956:lib/FreeRTOS/tasks.c **** 	{
1957:lib/FreeRTOS/tasks.c **** 		pxTCB->uxBasePriority = uxPriority;
 3201              		.loc 1 1957 0
 3202 003c FB68     		ldr	r3, [r7, #12]
 3203 003e 7A68     		ldr	r2, [r7, #4]
 3204 0040 9A64     		str	r2, [r3, #72]
1958:lib/FreeRTOS/tasks.c **** 	}
1959:lib/FreeRTOS/tasks.c **** 	#endif
1960:lib/FreeRTOS/tasks.c **** 
1961:lib/FreeRTOS/tasks.c **** 	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
 3205              		.loc 1 1961 0
 3206 0042 FB68     		ldr	r3, [r7, #12]
 3207 0044 03F10403 		add	r3, r3, #4
 3208 0048 1846     		mov	r0, r3
 3209 004a FFF7FEFF 		bl	vListInitialiseItem
1962:lib/FreeRTOS/tasks.c **** 	vListInitialiseItem( &( pxTCB->xEventListItem ) );
 3210              		.loc 1 1962 0
 3211 004e FB68     		ldr	r3, [r7, #12]
 3212 0050 03F11803 		add	r3, r3, #24
 3213 0054 1846     		mov	r0, r3
 3214 0056 FFF7FEFF 		bl	vListInitialiseItem
1963:lib/FreeRTOS/tasks.c **** 
1964:lib/FreeRTOS/tasks.c **** 	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
1965:lib/FreeRTOS/tasks.c **** 	back to	the containing TCB from a generic item in a list. */
1966:lib/FreeRTOS/tasks.c **** 	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
 3215              		.loc 1 1966 0
 3216 005a FB68     		ldr	r3, [r7, #12]
 3217 005c FA68     		ldr	r2, [r7, #12]
 3218 005e 1A61     		str	r2, [r3, #16]
1967:lib/FreeRTOS/tasks.c **** 
1968:lib/FreeRTOS/tasks.c **** 	/* Event lists are always in priority order. */
1969:lib/FreeRTOS/tasks.c **** 	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPri
 3219              		.loc 1 1969 0
 3220 0060 7B68     		ldr	r3, [r7, #4]
 3221 0062 C3F10502 		rsb	r2, r3, #5
 3222 0066 FB68     		ldr	r3, [r7, #12]
 3223 0068 9A61     		str	r2, [r3, #24]
1970:lib/FreeRTOS/tasks.c **** 	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
 3224              		.loc 1 1970 0
 3225 006a FB68     		ldr	r3, [r7, #12]
 3226 006c FA68     		ldr	r2, [r7, #12]
 3227 006e 5A62     		str	r2, [r3, #36]
1971:lib/FreeRTOS/tasks.c **** 
1972:lib/FreeRTOS/tasks.c **** 	#if ( portCRITICAL_NESTING_IN_TCB == 1 )
1973:lib/FreeRTOS/tasks.c **** 	{
1974:lib/FreeRTOS/tasks.c **** 		pxTCB->uxCriticalNesting = ( unsigned portBASE_TYPE ) 0U;
1975:lib/FreeRTOS/tasks.c **** 	}
1976:lib/FreeRTOS/tasks.c **** 	#endif
1977:lib/FreeRTOS/tasks.c **** 
1978:lib/FreeRTOS/tasks.c **** 	#if ( configUSE_APPLICATION_TASK_TAG == 1 )
1979:lib/FreeRTOS/tasks.c **** 	{
1980:lib/FreeRTOS/tasks.c **** 		pxTCB->pxTaskTag = NULL;
1981:lib/FreeRTOS/tasks.c **** 	}
1982:lib/FreeRTOS/tasks.c **** 	#endif
1983:lib/FreeRTOS/tasks.c **** 
1984:lib/FreeRTOS/tasks.c **** 	#if ( configGENERATE_RUN_TIME_STATS == 1 )
1985:lib/FreeRTOS/tasks.c **** 	{
1986:lib/FreeRTOS/tasks.c **** 		pxTCB->ulRunTimeCounter = 0UL;
1987:lib/FreeRTOS/tasks.c **** 	}
1988:lib/FreeRTOS/tasks.c **** 	#endif
1989:lib/FreeRTOS/tasks.c **** 
1990:lib/FreeRTOS/tasks.c **** 	#if ( portUSING_MPU_WRAPPERS == 1 )
1991:lib/FreeRTOS/tasks.c **** 	{
1992:lib/FreeRTOS/tasks.c **** 		vPortStoreTaskMPUSettings( &( pxTCB->xMPUSettings ), xRegions, pxTCB->pxStack, usStackDepth );
1993:lib/FreeRTOS/tasks.c **** 	}
1994:lib/FreeRTOS/tasks.c **** 	#else
1995:lib/FreeRTOS/tasks.c **** 	{
1996:lib/FreeRTOS/tasks.c **** 		( void ) xRegions;
1997:lib/FreeRTOS/tasks.c **** 		( void ) usStackDepth;
1998:lib/FreeRTOS/tasks.c **** 	}
1999:lib/FreeRTOS/tasks.c **** 	#endif
2000:lib/FreeRTOS/tasks.c **** }
 3228              		.loc 1 2000 0
 3229 0070 07F11007 		add	r7, r7, #16
 3230 0074 BD46     		mov	sp, r7
 3231 0076 80BD     		pop	{r7, pc}
 3232              		.cfi_endproc
 3233              	.LFE139:
 3235              		.section	.text.prvInitialiseTaskLists,"ax",%progbits
 3236              		.align	2
 3237              		.thumb
 3238              		.thumb_func
 3240              	prvInitialiseTaskLists:
 3241              	.LFB140:
2001:lib/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
2002:lib/FreeRTOS/tasks.c **** 
2003:lib/FreeRTOS/tasks.c **** #if ( portUSING_MPU_WRAPPERS == 1 )
2004:lib/FreeRTOS/tasks.c **** 
2005:lib/FreeRTOS/tasks.c **** 	void vTaskAllocateMPURegions( xTaskHandle xTaskToModify, const xMemoryRegion * const xRegions )
2006:lib/FreeRTOS/tasks.c **** 	{
2007:lib/FreeRTOS/tasks.c **** 	tskTCB *pxTCB;
2008:lib/FreeRTOS/tasks.c **** 	
2009:lib/FreeRTOS/tasks.c **** 		if( xTaskToModify == pxCurrentTCB )
2010:lib/FreeRTOS/tasks.c **** 		{
2011:lib/FreeRTOS/tasks.c **** 			xTaskToModify = NULL;
2012:lib/FreeRTOS/tasks.c **** 		}
2013:lib/FreeRTOS/tasks.c **** 
2014:lib/FreeRTOS/tasks.c **** 		/* If null is passed in here then we are deleting ourselves. */
2015:lib/FreeRTOS/tasks.c **** 		pxTCB = prvGetTCBFromHandle( xTaskToModify );
2016:lib/FreeRTOS/tasks.c **** 
2017:lib/FreeRTOS/tasks.c ****         vPortStoreTaskMPUSettings( &( pxTCB->xMPUSettings ), xRegions, NULL, 0 );
2018:lib/FreeRTOS/tasks.c **** 	}
2019:lib/FreeRTOS/tasks.c **** 	/*-----------------------------------------------------------*/
2020:lib/FreeRTOS/tasks.c **** #endif
2021:lib/FreeRTOS/tasks.c **** 
2022:lib/FreeRTOS/tasks.c **** static void prvInitialiseTaskLists( void )
2023:lib/FreeRTOS/tasks.c **** {
 3242              		.loc 1 2023 0
 3243              		.cfi_startproc
 3244              		@ args = 0, pretend = 0, frame = 8
 3245              		@ frame_needed = 1, uses_anonymous_args = 0
 3246 0000 80B5     		push	{r7, lr}
 3247              	.LCFI86:
 3248              		.cfi_def_cfa_offset 8
 3249 0002 82B0     		sub	sp, sp, #8
 3250              	.LCFI87:
 3251              		.cfi_def_cfa_offset 16
 3252 0004 00AF     		add	r7, sp, #0
 3253              		.cfi_offset 14, -4
 3254              		.cfi_offset 7, -8
 3255              	.LCFI88:
 3256              		.cfi_def_cfa_register 7
2024:lib/FreeRTOS/tasks.c **** unsigned portBASE_TYPE uxPriority;
2025:lib/FreeRTOS/tasks.c **** 
2026:lib/FreeRTOS/tasks.c **** 	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
 3257              		.loc 1 2026 0
 3258 0006 4FF00003 		mov	r3, #0
 3259 000a 7B60     		str	r3, [r7, #4]
 3260 000c 10E0     		b	.L220
 3261              	.L221:
2027:lib/FreeRTOS/tasks.c **** 	{
2028:lib/FreeRTOS/tasks.c **** 		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
 3262              		.loc 1 2028 0 discriminator 2
 3263 000e 7A68     		ldr	r2, [r7, #4]
 3264 0010 1346     		mov	r3, r2
 3265 0012 4FEA8303 		lsl	r3, r3, #2
 3266 0016 9B18     		adds	r3, r3, r2
 3267 0018 4FEA8303 		lsl	r3, r3, #2
 3268 001c 1A46     		mov	r2, r3
 3269 001e 124B     		ldr	r3, .L222
 3270 0020 D318     		adds	r3, r2, r3
 3271 0022 1846     		mov	r0, r3
 3272 0024 FFF7FEFF 		bl	vListInitialise
2026:lib/FreeRTOS/tasks.c **** 	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
 3273              		.loc 1 2026 0 discriminator 2
 3274 0028 7B68     		ldr	r3, [r7, #4]
 3275 002a 03F10103 		add	r3, r3, #1
 3276 002e 7B60     		str	r3, [r7, #4]
 3277              	.L220:
2026:lib/FreeRTOS/tasks.c **** 	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
 3278              		.loc 1 2026 0 is_stmt 0 discriminator 1
 3279 0030 7B68     		ldr	r3, [r7, #4]
 3280 0032 042B     		cmp	r3, #4
 3281 0034 EBD9     		bls	.L221
2029:lib/FreeRTOS/tasks.c **** 	}
2030:lib/FreeRTOS/tasks.c **** 
2031:lib/FreeRTOS/tasks.c **** 	vListInitialise( ( xList * ) &xDelayedTaskList1 );
 3282              		.loc 1 2031 0 is_stmt 1
 3283 0036 0D48     		ldr	r0, .L222+4
 3284 0038 FFF7FEFF 		bl	vListInitialise
2032:lib/FreeRTOS/tasks.c **** 	vListInitialise( ( xList * ) &xDelayedTaskList2 );
 3285              		.loc 1 2032 0
 3286 003c 0C48     		ldr	r0, .L222+8
 3287 003e FFF7FEFF 		bl	vListInitialise
2033:lib/FreeRTOS/tasks.c **** 	vListInitialise( ( xList * ) &xPendingReadyList );
 3288              		.loc 1 2033 0
 3289 0042 0C48     		ldr	r0, .L222+12
 3290 0044 FFF7FEFF 		bl	vListInitialise
2034:lib/FreeRTOS/tasks.c **** 
2035:lib/FreeRTOS/tasks.c **** 	#if ( INCLUDE_vTaskDelete == 1 )
2036:lib/FreeRTOS/tasks.c **** 	{
2037:lib/FreeRTOS/tasks.c **** 		vListInitialise( ( xList * ) &xTasksWaitingTermination );
 3291              		.loc 1 2037 0
 3292 0048 0B48     		ldr	r0, .L222+16
 3293 004a FFF7FEFF 		bl	vListInitialise
2038:lib/FreeRTOS/tasks.c **** 	}
2039:lib/FreeRTOS/tasks.c **** 	#endif
2040:lib/FreeRTOS/tasks.c **** 
2041:lib/FreeRTOS/tasks.c **** 	#if ( INCLUDE_vTaskSuspend == 1 )
2042:lib/FreeRTOS/tasks.c **** 	{
2043:lib/FreeRTOS/tasks.c **** 		vListInitialise( ( xList * ) &xSuspendedTaskList );
 3294              		.loc 1 2043 0
 3295 004e 0B48     		ldr	r0, .L222+20
 3296 0050 FFF7FEFF 		bl	vListInitialise
2044:lib/FreeRTOS/tasks.c **** 	}
2045:lib/FreeRTOS/tasks.c **** 	#endif
2046:lib/FreeRTOS/tasks.c **** 
2047:lib/FreeRTOS/tasks.c **** 	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
2048:lib/FreeRTOS/tasks.c **** 	using list2. */
2049:lib/FreeRTOS/tasks.c **** 	pxDelayedTaskList = &xDelayedTaskList1;
 3297              		.loc 1 2049 0
 3298 0054 0A4B     		ldr	r3, .L222+24
 3299 0056 054A     		ldr	r2, .L222+4
 3300 0058 1A60     		str	r2, [r3, #0]
2050:lib/FreeRTOS/tasks.c **** 	pxOverflowDelayedTaskList = &xDelayedTaskList2;
 3301              		.loc 1 2050 0
 3302 005a 0A4B     		ldr	r3, .L222+28
 3303 005c 044A     		ldr	r2, .L222+8
 3304 005e 1A60     		str	r2, [r3, #0]
2051:lib/FreeRTOS/tasks.c **** }
 3305              		.loc 1 2051 0
 3306 0060 07F10807 		add	r7, r7, #8
 3307 0064 BD46     		mov	sp, r7
 3308 0066 80BD     		pop	{r7, pc}
 3309              	.L223:
 3310              		.align	2
 3311              	.L222:
 3312 0068 00000000 		.word	pxReadyTasksLists
 3313 006c 00000000 		.word	xDelayedTaskList1
 3314 0070 00000000 		.word	xDelayedTaskList2
 3315 0074 00000000 		.word	xPendingReadyList
 3316 0078 00000000 		.word	xTasksWaitingTermination
 3317 007c 00000000 		.word	xSuspendedTaskList
 3318 0080 00000000 		.word	pxDelayedTaskList
 3319 0084 00000000 		.word	pxOverflowDelayedTaskList
 3320              		.cfi_endproc
 3321              	.LFE140:
 3323              		.section	.text.prvCheckTasksWaitingTermination,"ax",%progbits
 3324              		.align	2
 3325              		.thumb
 3326              		.thumb_func
 3328              	prvCheckTasksWaitingTermination:
 3329              	.LFB141:
2052:lib/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
2053:lib/FreeRTOS/tasks.c **** 
2054:lib/FreeRTOS/tasks.c **** static void prvCheckTasksWaitingTermination( void )
2055:lib/FreeRTOS/tasks.c **** {
 3330              		.loc 1 2055 0
 3331              		.cfi_startproc
 3332              		@ args = 0, pretend = 0, frame = 8
 3333              		@ frame_needed = 1, uses_anonymous_args = 0
 3334 0000 80B5     		push	{r7, lr}
 3335              	.LCFI89:
 3336              		.cfi_def_cfa_offset 8
 3337 0002 82B0     		sub	sp, sp, #8
 3338              	.LCFI90:
 3339              		.cfi_def_cfa_offset 16
 3340 0004 00AF     		add	r7, sp, #0
 3341              		.cfi_offset 14, -4
 3342              		.cfi_offset 7, -8
 3343              	.LCFI91:
 3344              		.cfi_def_cfa_register 7
 3345              	.LBB8:
2056:lib/FreeRTOS/tasks.c **** 	#if ( INCLUDE_vTaskDelete == 1 )
2057:lib/FreeRTOS/tasks.c **** 	{
2058:lib/FreeRTOS/tasks.c **** 		portBASE_TYPE xListIsEmpty;
2059:lib/FreeRTOS/tasks.c **** 
2060:lib/FreeRTOS/tasks.c **** 		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
2061:lib/FreeRTOS/tasks.c **** 		too often in the idle task. */
2062:lib/FreeRTOS/tasks.c **** 		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0U )
 3346              		.loc 1 2062 0
 3347 0006 194B     		ldr	r3, .L226
 3348 0008 1B68     		ldr	r3, [r3, #0]
 3349 000a 002B     		cmp	r3, #0
 3350 000c 2AD0     		beq	.L224
2063:lib/FreeRTOS/tasks.c **** 		{
2064:lib/FreeRTOS/tasks.c **** 			vTaskSuspendAll();
 3351              		.loc 1 2064 0
 3352 000e FFF7FEFF 		bl	vTaskSuspendAll
2065:lib/FreeRTOS/tasks.c **** 				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
 3353              		.loc 1 2065 0
 3354 0012 174B     		ldr	r3, .L226+4
 3355 0014 1B68     		ldr	r3, [r3, #0]
 3356 0016 002B     		cmp	r3, #0
 3357 0018 14BF     		ite	ne
 3358 001a 0023     		movne	r3, #0
 3359 001c 0123     		moveq	r3, #1
 3360 001e 7B60     		str	r3, [r7, #4]
2066:lib/FreeRTOS/tasks.c **** 			xTaskResumeAll();
 3361              		.loc 1 2066 0
 3362 0020 FFF7FEFF 		bl	xTaskResumeAll
2067:lib/FreeRTOS/tasks.c **** 
2068:lib/FreeRTOS/tasks.c **** 			if( xListIsEmpty == pdFALSE )
 3363              		.loc 1 2068 0
 3364 0024 7B68     		ldr	r3, [r7, #4]
 3365 0026 002B     		cmp	r3, #0
 3366 0028 1CD1     		bne	.L224
 3367              	.LBB9:
2069:lib/FreeRTOS/tasks.c **** 			{
2070:lib/FreeRTOS/tasks.c **** 				tskTCB *pxTCB;
2071:lib/FreeRTOS/tasks.c **** 
2072:lib/FreeRTOS/tasks.c **** 				taskENTER_CRITICAL();
 3368              		.loc 1 2072 0
 3369 002a FFF7FEFF 		bl	vPortEnterCritical
2073:lib/FreeRTOS/tasks.c **** 				{
2074:lib/FreeRTOS/tasks.c **** 					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
 3370              		.loc 1 2074 0
 3371 002e 104B     		ldr	r3, .L226+4
 3372 0030 DB68     		ldr	r3, [r3, #12]
 3373 0032 DB68     		ldr	r3, [r3, #12]
 3374 0034 3B60     		str	r3, [r7, #0]
2075:lib/FreeRTOS/tasks.c **** 					vListRemove( &( pxTCB->xGenericListItem ) );
 3375              		.loc 1 2075 0
 3376 0036 3B68     		ldr	r3, [r7, #0]
 3377 0038 03F10403 		add	r3, r3, #4
 3378 003c 1846     		mov	r0, r3
 3379 003e FFF7FEFF 		bl	vListRemove
2076:lib/FreeRTOS/tasks.c **** 					--uxCurrentNumberOfTasks;
 3380              		.loc 1 2076 0
 3381 0042 0C4B     		ldr	r3, .L226+8
 3382 0044 1B68     		ldr	r3, [r3, #0]
 3383 0046 03F1FF32 		add	r2, r3, #-1
 3384 004a 0A4B     		ldr	r3, .L226+8
 3385 004c 1A60     		str	r2, [r3, #0]
2077:lib/FreeRTOS/tasks.c **** 					--uxTasksDeleted;
 3386              		.loc 1 2077 0
 3387 004e 074B     		ldr	r3, .L226
 3388 0050 1B68     		ldr	r3, [r3, #0]
 3389 0052 03F1FF32 		add	r2, r3, #-1
 3390 0056 054B     		ldr	r3, .L226
 3391 0058 1A60     		str	r2, [r3, #0]
2078:lib/FreeRTOS/tasks.c **** 				}
2079:lib/FreeRTOS/tasks.c **** 				taskEXIT_CRITICAL();
 3392              		.loc 1 2079 0
 3393 005a FFF7FEFF 		bl	vPortExitCritical
2080:lib/FreeRTOS/tasks.c **** 
2081:lib/FreeRTOS/tasks.c **** 				prvDeleteTCB( pxTCB );
 3394              		.loc 1 2081 0
 3395 005e 3868     		ldr	r0, [r7, #0]
 3396 0060 FFF7FEFF 		bl	prvDeleteTCB
 3397              	.L224:
 3398              	.LBE9:
 3399              	.LBE8:
2082:lib/FreeRTOS/tasks.c **** 			}
2083:lib/FreeRTOS/tasks.c **** 		}
2084:lib/FreeRTOS/tasks.c **** 	}
2085:lib/FreeRTOS/tasks.c **** 	#endif
2086:lib/FreeRTOS/tasks.c **** }
 3400              		.loc 1 2086 0
 3401 0064 07F10807 		add	r7, r7, #8
 3402 0068 BD46     		mov	sp, r7
 3403 006a 80BD     		pop	{r7, pc}
 3404              	.L227:
 3405              		.align	2
 3406              	.L226:
 3407 006c 00000000 		.word	uxTasksDeleted
 3408 0070 00000000 		.word	xTasksWaitingTermination
 3409 0074 00000000 		.word	uxCurrentNumberOfTasks
 3410              		.cfi_endproc
 3411              	.LFE141:
 3413              		.section	.text.prvAddCurrentTaskToDelayedList,"ax",%progbits
 3414              		.align	2
 3415              		.thumb
 3416              		.thumb_func
 3418              	prvAddCurrentTaskToDelayedList:
 3419              	.LFB142:
2087:lib/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
2088:lib/FreeRTOS/tasks.c **** 
2089:lib/FreeRTOS/tasks.c **** static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
2090:lib/FreeRTOS/tasks.c **** {
 3420              		.loc 1 2090 0
 3421              		.cfi_startproc
 3422              		@ args = 0, pretend = 0, frame = 8
 3423              		@ frame_needed = 1, uses_anonymous_args = 0
 3424 0000 80B5     		push	{r7, lr}
 3425              	.LCFI92:
 3426              		.cfi_def_cfa_offset 8
 3427 0002 82B0     		sub	sp, sp, #8
 3428              	.LCFI93:
 3429              		.cfi_def_cfa_offset 16
 3430 0004 00AF     		add	r7, sp, #0
 3431              		.cfi_offset 14, -4
 3432              		.cfi_offset 7, -8
 3433              	.LCFI94:
 3434              		.cfi_def_cfa_register 7
 3435 0006 7860     		str	r0, [r7, #4]
2091:lib/FreeRTOS/tasks.c **** 	/* The list item will be inserted in wake time order. */
2092:lib/FreeRTOS/tasks.c **** 	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
 3436              		.loc 1 2092 0
 3437 0008 144B     		ldr	r3, .L231
 3438 000a 1B68     		ldr	r3, [r3, #0]
 3439 000c 7A68     		ldr	r2, [r7, #4]
 3440 000e 5A60     		str	r2, [r3, #4]
2093:lib/FreeRTOS/tasks.c **** 
2094:lib/FreeRTOS/tasks.c **** 	if( xTimeToWake < xTickCount )
 3441              		.loc 1 2094 0
 3442 0010 134B     		ldr	r3, .L231+4
 3443 0012 1B68     		ldr	r3, [r3, #0]
 3444 0014 7A68     		ldr	r2, [r7, #4]
 3445 0016 9A42     		cmp	r2, r3
 3446 0018 0AD2     		bcs	.L229
2095:lib/FreeRTOS/tasks.c **** 	{
2096:lib/FreeRTOS/tasks.c **** 		/* Wake time has overflowed.  Place this item in the overflow list. */
2097:lib/FreeRTOS/tasks.c **** 		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericList
 3447              		.loc 1 2097 0
 3448 001a 124B     		ldr	r3, .L231+8
 3449 001c 1A68     		ldr	r2, [r3, #0]
 3450 001e 0F4B     		ldr	r3, .L231
 3451 0020 1B68     		ldr	r3, [r3, #0]
 3452 0022 03F10403 		add	r3, r3, #4
 3453 0026 1046     		mov	r0, r2
 3454 0028 1946     		mov	r1, r3
 3455 002a FFF7FEFF 		bl	vListInsert
 3456 002e 11E0     		b	.L228
 3457              	.L229:
2098:lib/FreeRTOS/tasks.c **** 	}
2099:lib/FreeRTOS/tasks.c **** 	else
2100:lib/FreeRTOS/tasks.c **** 	{
2101:lib/FreeRTOS/tasks.c **** 		/* The wake time has not overflowed, so we can use the current block list. */
2102:lib/FreeRTOS/tasks.c **** 		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) )
 3458              		.loc 1 2102 0
 3459 0030 0D4B     		ldr	r3, .L231+12
 3460 0032 1A68     		ldr	r2, [r3, #0]
 3461 0034 094B     		ldr	r3, .L231
 3462 0036 1B68     		ldr	r3, [r3, #0]
 3463 0038 03F10403 		add	r3, r3, #4
 3464 003c 1046     		mov	r0, r2
 3465 003e 1946     		mov	r1, r3
 3466 0040 FFF7FEFF 		bl	vListInsert
2103:lib/FreeRTOS/tasks.c **** 
2104:lib/FreeRTOS/tasks.c **** 		/* If the task entering the blocked state was placed at the head of the
2105:lib/FreeRTOS/tasks.c **** 		list of blocked tasks then xNextTaskUnblockTime needs to be updated
2106:lib/FreeRTOS/tasks.c **** 		too. */
2107:lib/FreeRTOS/tasks.c **** 		if( xTimeToWake < xNextTaskUnblockTime )
 3467              		.loc 1 2107 0
 3468 0044 094B     		ldr	r3, .L231+16
 3469 0046 1B68     		ldr	r3, [r3, #0]
 3470 0048 7A68     		ldr	r2, [r7, #4]
 3471 004a 9A42     		cmp	r2, r3
 3472 004c 02D2     		bcs	.L228
2108:lib/FreeRTOS/tasks.c **** 		{
2109:lib/FreeRTOS/tasks.c **** 			xNextTaskUnblockTime = xTimeToWake;
 3473              		.loc 1 2109 0
 3474 004e 074B     		ldr	r3, .L231+16
 3475 0050 7A68     		ldr	r2, [r7, #4]
 3476 0052 1A60     		str	r2, [r3, #0]
 3477              	.L228:
2110:lib/FreeRTOS/tasks.c **** 		}
2111:lib/FreeRTOS/tasks.c **** 	}
2112:lib/FreeRTOS/tasks.c **** }
 3478              		.loc 1 2112 0
 3479 0054 07F10807 		add	r7, r7, #8
 3480 0058 BD46     		mov	sp, r7
 3481 005a 80BD     		pop	{r7, pc}
 3482              	.L232:
 3483              		.align	2
 3484              	.L231:
 3485 005c 00000000 		.word	pxCurrentTCB
 3486 0060 00000000 		.word	xTickCount
 3487 0064 00000000 		.word	pxOverflowDelayedTaskList
 3488 0068 00000000 		.word	pxDelayedTaskList
 3489 006c 00000000 		.word	xNextTaskUnblockTime
 3490              		.cfi_endproc
 3491              	.LFE142:
 3493              		.section	.text.prvAllocateTCBAndStack,"ax",%progbits
 3494              		.align	2
 3495              		.thumb
 3496              		.thumb_func
 3498              	prvAllocateTCBAndStack:
 3499              	.LFB143:
2113:lib/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
2114:lib/FreeRTOS/tasks.c **** 
2115:lib/FreeRTOS/tasks.c **** static tskTCB *prvAllocateTCBAndStack( unsigned short usStackDepth, portSTACK_TYPE *puxStackBuffer 
2116:lib/FreeRTOS/tasks.c **** {
 3500              		.loc 1 2116 0
 3501              		.cfi_startproc
 3502              		@ args = 0, pretend = 0, frame = 16
 3503              		@ frame_needed = 1, uses_anonymous_args = 0
 3504 0000 80B5     		push	{r7, lr}
 3505              	.LCFI95:
 3506              		.cfi_def_cfa_offset 8
 3507 0002 84B0     		sub	sp, sp, #16
 3508              	.LCFI96:
 3509              		.cfi_def_cfa_offset 24
 3510 0004 00AF     		add	r7, sp, #0
 3511              		.cfi_offset 14, -4
 3512              		.cfi_offset 7, -8
 3513              	.LCFI97:
 3514              		.cfi_def_cfa_register 7
 3515 0006 0346     		mov	r3, r0
 3516 0008 3960     		str	r1, [r7, #0]
 3517 000a FB80     		strh	r3, [r7, #6]	@ movhi
2117:lib/FreeRTOS/tasks.c **** tskTCB *pxNewTCB;
2118:lib/FreeRTOS/tasks.c **** 
2119:lib/FreeRTOS/tasks.c **** 	/* Allocate space for the TCB.  Where the memory comes from depends on
2120:lib/FreeRTOS/tasks.c **** 	the implementation of the port malloc function. */
2121:lib/FreeRTOS/tasks.c **** 	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
 3518              		.loc 1 2121 0
 3519 000c 4FF04C00 		mov	r0, #76
 3520 0010 FFF7FEFF 		bl	pvPortMalloc
 3521 0014 0346     		mov	r3, r0
 3522 0016 FB60     		str	r3, [r7, #12]
2122:lib/FreeRTOS/tasks.c **** 
2123:lib/FreeRTOS/tasks.c **** 	if( pxNewTCB != NULL )
 3523              		.loc 1 2123 0
 3524 0018 FB68     		ldr	r3, [r7, #12]
 3525 001a 002B     		cmp	r3, #0
 3526 001c 23D0     		beq	.L234
2124:lib/FreeRTOS/tasks.c **** 	{
2125:lib/FreeRTOS/tasks.c **** 		/* Allocate space for the stack used by the task being created.
2126:lib/FreeRTOS/tasks.c **** 		The base of the stack memory stored in the TCB so the task can
2127:lib/FreeRTOS/tasks.c **** 		be deleted later if required. */
2128:lib/FreeRTOS/tasks.c **** 		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * size
 3527              		.loc 1 2128 0
 3528 001e 3B68     		ldr	r3, [r7, #0]
 3529 0020 002B     		cmp	r3, #0
 3530 0022 07D1     		bne	.L235
 3531              		.loc 1 2128 0 is_stmt 0 discriminator 1
 3532 0024 FB88     		ldrh	r3, [r7, #6]
 3533 0026 4FEA8303 		lsl	r3, r3, #2
 3534 002a 1846     		mov	r0, r3
 3535 002c FFF7FEFF 		bl	pvPortMalloc
 3536 0030 0346     		mov	r3, r0
 3537 0032 00E0     		b	.L236
 3538              	.L235:
 3539              		.loc 1 2128 0 discriminator 2
 3540 0034 3B68     		ldr	r3, [r7, #0]
 3541              	.L236:
 3542              		.loc 1 2128 0 discriminator 3
 3543 0036 FA68     		ldr	r2, [r7, #12]
 3544 0038 1363     		str	r3, [r2, #48]
2129:lib/FreeRTOS/tasks.c **** 
2130:lib/FreeRTOS/tasks.c **** 		if( pxNewTCB->pxStack == NULL )
 3545              		.loc 1 2130 0 is_stmt 1 discriminator 3
 3546 003a FB68     		ldr	r3, [r7, #12]
 3547 003c 1B6B     		ldr	r3, [r3, #48]
 3548 003e 002B     		cmp	r3, #0
 3549 0040 06D1     		bne	.L237
2131:lib/FreeRTOS/tasks.c **** 		{
2132:lib/FreeRTOS/tasks.c **** 			/* Could not allocate the stack.  Delete the allocated TCB. */
2133:lib/FreeRTOS/tasks.c **** 			vPortFree( pxNewTCB );
 3550              		.loc 1 2133 0
 3551 0042 F868     		ldr	r0, [r7, #12]
 3552 0044 FFF7FEFF 		bl	vPortFree
2134:lib/FreeRTOS/tasks.c **** 			pxNewTCB = NULL;
 3553              		.loc 1 2134 0
 3554 0048 4FF00003 		mov	r3, #0
 3555 004c FB60     		str	r3, [r7, #12]
 3556 004e 0AE0     		b	.L234
 3557              	.L237:
2135:lib/FreeRTOS/tasks.c **** 		}
2136:lib/FreeRTOS/tasks.c **** 		else
2137:lib/FreeRTOS/tasks.c **** 		{
2138:lib/FreeRTOS/tasks.c **** 			/* Just to help debugging. */
2139:lib/FreeRTOS/tasks.c **** 			memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) usStackDepth * sizeof( portSTA
 3558              		.loc 1 2139 0
 3559 0050 FB68     		ldr	r3, [r7, #12]
 3560 0052 1A6B     		ldr	r2, [r3, #48]
 3561 0054 FB88     		ldrh	r3, [r7, #6]
 3562 0056 4FEA8303 		lsl	r3, r3, #2
 3563 005a 1046     		mov	r0, r2
 3564 005c 4FF0A501 		mov	r1, #165
 3565 0060 1A46     		mov	r2, r3
 3566 0062 FFF7FEFF 		bl	memset
 3567              	.L234:
2140:lib/FreeRTOS/tasks.c **** 		}
2141:lib/FreeRTOS/tasks.c **** 	}
2142:lib/FreeRTOS/tasks.c **** 
2143:lib/FreeRTOS/tasks.c **** 	return pxNewTCB;
 3568              		.loc 1 2143 0
 3569 0066 FB68     		ldr	r3, [r7, #12]
2144:lib/FreeRTOS/tasks.c **** }
 3570              		.loc 1 2144 0
 3571 0068 1846     		mov	r0, r3
 3572 006a 07F11007 		add	r7, r7, #16
 3573 006e BD46     		mov	sp, r7
 3574 0070 80BD     		pop	{r7, pc}
 3575              		.cfi_endproc
 3576              	.LFE143:
 3578 0072 00BF     		.section	.rodata
 3579 000b 00       		.align	2
 3580              	.LC2:
 3581 000c 25730909 		.ascii	"%s\011\011%c\011%u\011%u\011%u\015\012\000"
 3581      25630925 
 3581      75092575 
 3581      0925750D 
 3581      0A00
 3582 001e 0000     		.section	.text.prvListTaskWithinSingleList,"ax",%progbits
 3583              		.align	2
 3584              		.thumb
 3585              		.thumb_func
 3587              	prvListTaskWithinSingleList:
 3588              	.LFB144:
2145:lib/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
2146:lib/FreeRTOS/tasks.c **** 
2147:lib/FreeRTOS/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
2148:lib/FreeRTOS/tasks.c **** 
2149:lib/FreeRTOS/tasks.c **** 	static void prvListTaskWithinSingleList( const signed char *pcWriteBuffer, xList *pxList, signed c
2150:lib/FreeRTOS/tasks.c **** 	{
 3589              		.loc 1 2150 0
 3590              		.cfi_startproc
 3591              		@ args = 0, pretend = 0, frame = 40
 3592              		@ frame_needed = 1, uses_anonymous_args = 0
 3593 0000 90B5     		push	{r4, r7, lr}
 3594              	.LCFI98:
 3595              		.cfi_def_cfa_offset 12
 3596 0002 8FB0     		sub	sp, sp, #60
 3597              	.LCFI99:
 3598              		.cfi_def_cfa_offset 72
 3599 0004 04AF     		add	r7, sp, #16
 3600              		.cfi_offset 14, -4
 3601              		.cfi_offset 7, -8
 3602              		.cfi_offset 4, -12
 3603              	.LCFI100:
 3604              		.cfi_def_cfa 7, 56
 3605 0006 F860     		str	r0, [r7, #12]
 3606 0008 B960     		str	r1, [r7, #8]
 3607 000a 1346     		mov	r3, r2
 3608 000c FB71     		strb	r3, [r7, #7]
 3609              	.LBB10:
2151:lib/FreeRTOS/tasks.c **** 	volatile tskTCB *pxNextTCB, *pxFirstTCB;
2152:lib/FreeRTOS/tasks.c **** 	unsigned short usStackRemaining;
2153:lib/FreeRTOS/tasks.c **** 	PRIVILEGED_DATA static char pcStatusString[ 50 ];
2154:lib/FreeRTOS/tasks.c **** 
2155:lib/FreeRTOS/tasks.c **** 		/* Write the details of all the TCB's in pxList into the buffer. */
2156:lib/FreeRTOS/tasks.c **** 		listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList );
 3610              		.loc 1 2156 0
 3611 000e BB68     		ldr	r3, [r7, #8]
 3612 0010 7B62     		str	r3, [r7, #36]
 3613 0012 7B6A     		ldr	r3, [r7, #36]
 3614 0014 5B68     		ldr	r3, [r3, #4]
 3615 0016 5A68     		ldr	r2, [r3, #4]
 3616 0018 7B6A     		ldr	r3, [r7, #36]
 3617 001a 5A60     		str	r2, [r3, #4]
 3618 001c 7B6A     		ldr	r3, [r7, #36]
 3619 001e 5A68     		ldr	r2, [r3, #4]
 3620 0020 7B6A     		ldr	r3, [r7, #36]
 3621 0022 03F10803 		add	r3, r3, #8
 3622 0026 9A42     		cmp	r2, r3
 3623 0028 04D1     		bne	.L239
 3624              		.loc 1 2156 0 is_stmt 0 discriminator 1
 3625 002a 7B6A     		ldr	r3, [r7, #36]
 3626 002c 5B68     		ldr	r3, [r3, #4]
 3627 002e 5A68     		ldr	r2, [r3, #4]
 3628 0030 7B6A     		ldr	r3, [r7, #36]
 3629 0032 5A60     		str	r2, [r3, #4]
 3630              	.L239:
 3631              		.loc 1 2156 0 discriminator 2
 3632 0034 7B6A     		ldr	r3, [r7, #36]
 3633 0036 5B68     		ldr	r3, [r3, #4]
 3634 0038 DB68     		ldr	r3, [r3, #12]
 3635 003a 3B62     		str	r3, [r7, #32]
 3636              	.L241:
 3637              	.LBE10:
 3638              	.LBB11:
2157:lib/FreeRTOS/tasks.c **** 		do
2158:lib/FreeRTOS/tasks.c **** 		{
2159:lib/FreeRTOS/tasks.c **** 			listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList );
 3639              		.loc 1 2159 0 is_stmt 1
 3640 003c BB68     		ldr	r3, [r7, #8]
 3641 003e FB61     		str	r3, [r7, #28]
 3642 0040 FB69     		ldr	r3, [r7, #28]
 3643 0042 5B68     		ldr	r3, [r3, #4]
 3644 0044 5A68     		ldr	r2, [r3, #4]
 3645 0046 FB69     		ldr	r3, [r7, #28]
 3646 0048 5A60     		str	r2, [r3, #4]
 3647 004a FB69     		ldr	r3, [r7, #28]
 3648 004c 5A68     		ldr	r2, [r3, #4]
 3649 004e FB69     		ldr	r3, [r7, #28]
 3650 0050 03F10803 		add	r3, r3, #8
 3651 0054 9A42     		cmp	r2, r3
 3652 0056 04D1     		bne	.L240
 3653              		.loc 1 2159 0 is_stmt 0 discriminator 1
 3654 0058 FB69     		ldr	r3, [r7, #28]
 3655 005a 5B68     		ldr	r3, [r3, #4]
 3656 005c 5A68     		ldr	r2, [r3, #4]
 3657 005e FB69     		ldr	r3, [r7, #28]
 3658 0060 5A60     		str	r2, [r3, #4]
 3659              	.L240:
 3660              		.loc 1 2159 0 discriminator 2
 3661 0062 FB69     		ldr	r3, [r7, #28]
 3662 0064 5B68     		ldr	r3, [r3, #4]
 3663 0066 DB68     		ldr	r3, [r3, #12]
 3664 0068 BB61     		str	r3, [r7, #24]
 3665              	.LBE11:
2160:lib/FreeRTOS/tasks.c **** 			#if ( portSTACK_GROWTH > 0 )
2161:lib/FreeRTOS/tasks.c **** 			{
2162:lib/FreeRTOS/tasks.c **** 				usStackRemaining = usTaskCheckFreeStackSpace( ( unsigned char * ) pxNextTCB->pxEndOfStack );
2163:lib/FreeRTOS/tasks.c **** 			}
2164:lib/FreeRTOS/tasks.c **** 			#else
2165:lib/FreeRTOS/tasks.c **** 			{
2166:lib/FreeRTOS/tasks.c **** 				usStackRemaining = usTaskCheckFreeStackSpace( ( unsigned char * ) pxNextTCB->pxStack );
 3666              		.loc 1 2166 0 is_stmt 1 discriminator 2
 3667 006a BB69     		ldr	r3, [r7, #24]
 3668 006c 1B6B     		ldr	r3, [r3, #48]
 3669 006e 1846     		mov	r0, r3
 3670 0070 FFF7FEFF 		bl	usTaskCheckFreeStackSpace
 3671 0074 0346     		mov	r3, r0
 3672 0076 FB82     		strh	r3, [r7, #22]	@ movhi
2167:lib/FreeRTOS/tasks.c **** 			}
2168:lib/FreeRTOS/tasks.c **** 			#endif			
2169:lib/FreeRTOS/tasks.c **** 			
2170:lib/FreeRTOS/tasks.c **** 			sprintf( pcStatusString, ( char * ) "%s\t\t%c\t%u\t%u\t%u\r\n", pxNextTCB->pcTaskName, cStatus, 
 3673              		.loc 1 2170 0 discriminator 2
 3674 0078 BB69     		ldr	r3, [r7, #24]
 3675 007a 03F13402 		add	r2, r3, #52
 3676 007e 97F90730 		ldrsb	r3, [r7, #7]
 3677 0082 B969     		ldr	r1, [r7, #24]
 3678 0084 CC6A     		ldr	r4, [r1, #44]
 3679 0086 F88A     		ldrh	r0, [r7, #22]
 3680 0088 B969     		ldr	r1, [r7, #24]
 3681 008a 096C     		ldr	r1, [r1, #64]
 3682 008c 0094     		str	r4, [sp, #0]
 3683 008e 0190     		str	r0, [sp, #4]
 3684 0090 0291     		str	r1, [sp, #8]
 3685 0092 0848     		ldr	r0, .L242
 3686 0094 0849     		ldr	r1, .L242+4
 3687 0096 FFF7FEFF 		bl	sprintf
2171:lib/FreeRTOS/tasks.c **** 			strcat( ( char * ) pcWriteBuffer, ( char * ) pcStatusString );
 3688              		.loc 1 2171 0 discriminator 2
 3689 009a F868     		ldr	r0, [r7, #12]
 3690 009c 0549     		ldr	r1, .L242
 3691 009e FFF7FEFF 		bl	strcat
2172:lib/FreeRTOS/tasks.c **** 
2173:lib/FreeRTOS/tasks.c **** 		} while( pxNextTCB != pxFirstTCB );
 3692              		.loc 1 2173 0 discriminator 2
 3693 00a2 BA69     		ldr	r2, [r7, #24]
 3694 00a4 3B6A     		ldr	r3, [r7, #32]
 3695 00a6 9A42     		cmp	r2, r3
 3696 00a8 C8D1     		bne	.L241
2174:lib/FreeRTOS/tasks.c **** 	}
 3697              		.loc 1 2174 0
 3698 00aa 07F12C07 		add	r7, r7, #44
 3699 00ae BD46     		mov	sp, r7
 3700 00b0 90BD     		pop	{r4, r7, pc}
 3701              	.L243:
 3702 00b2 00BF     		.align	2
 3703              	.L242:
 3704 00b4 00000000 		.word	pcStatusString.8648
 3705 00b8 0C000000 		.word	.LC2
 3706              		.cfi_endproc
 3707              	.LFE144:
 3709              		.section	.text.usTaskCheckFreeStackSpace,"ax",%progbits
 3710              		.align	2
 3711              		.thumb
 3712              		.thumb_func
 3714              	usTaskCheckFreeStackSpace:
 3715              	.LFB145:
2175:lib/FreeRTOS/tasks.c **** 
2176:lib/FreeRTOS/tasks.c **** #endif
2177:lib/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
2178:lib/FreeRTOS/tasks.c **** 
2179:lib/FreeRTOS/tasks.c **** #if ( configGENERATE_RUN_TIME_STATS == 1 )
2180:lib/FreeRTOS/tasks.c **** 
2181:lib/FreeRTOS/tasks.c **** 	static void prvGenerateRunTimeStatsForTasksInList( const signed char *pcWriteBuffer, xList *pxList
2182:lib/FreeRTOS/tasks.c **** 	{
2183:lib/FreeRTOS/tasks.c **** 	volatile tskTCB *pxNextTCB, *pxFirstTCB;
2184:lib/FreeRTOS/tasks.c **** 	unsigned long ulStatsAsPercentage;
2185:lib/FreeRTOS/tasks.c **** 
2186:lib/FreeRTOS/tasks.c **** 		/* Write the run time stats of all the TCB's in pxList into the buffer. */
2187:lib/FreeRTOS/tasks.c **** 		listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList );
2188:lib/FreeRTOS/tasks.c **** 		do
2189:lib/FreeRTOS/tasks.c **** 		{
2190:lib/FreeRTOS/tasks.c **** 			/* Get next TCB in from the list. */
2191:lib/FreeRTOS/tasks.c **** 			listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList );
2192:lib/FreeRTOS/tasks.c **** 
2193:lib/FreeRTOS/tasks.c **** 			/* Divide by zero check. */
2194:lib/FreeRTOS/tasks.c **** 			if( ulTotalRunTime > 0UL )
2195:lib/FreeRTOS/tasks.c **** 			{
2196:lib/FreeRTOS/tasks.c **** 				/* Has the task run at all? */
2197:lib/FreeRTOS/tasks.c **** 				if( pxNextTCB->ulRunTimeCounter == 0UL )
2198:lib/FreeRTOS/tasks.c **** 				{
2199:lib/FreeRTOS/tasks.c **** 					/* The task has used no CPU time at all. */
2200:lib/FreeRTOS/tasks.c **** 					sprintf( pcStatsString, ( char * ) "%s\t\t0\t\t0%%\r\n", pxNextTCB->pcTaskName );
2201:lib/FreeRTOS/tasks.c **** 				}
2202:lib/FreeRTOS/tasks.c **** 				else
2203:lib/FreeRTOS/tasks.c **** 				{
2204:lib/FreeRTOS/tasks.c **** 					/* What percentage of the total run time has the task used?
2205:lib/FreeRTOS/tasks.c **** 					This will always be rounded down to the nearest integer.
2206:lib/FreeRTOS/tasks.c **** 					ulTotalRunTime has already been divided by 100. */
2207:lib/FreeRTOS/tasks.c **** 					ulStatsAsPercentage = pxNextTCB->ulRunTimeCounter / ulTotalRunTime;
2208:lib/FreeRTOS/tasks.c **** 
2209:lib/FreeRTOS/tasks.c **** 					if( ulStatsAsPercentage > 0UL )
2210:lib/FreeRTOS/tasks.c **** 					{
2211:lib/FreeRTOS/tasks.c **** 						#ifdef portLU_PRINTF_SPECIFIER_REQUIRED
2212:lib/FreeRTOS/tasks.c **** 						{
2213:lib/FreeRTOS/tasks.c **** 							sprintf( pcStatsString, ( char * ) "%s\t\t%lu\t\t%lu%%\r\n", pxNextTCB->pcTaskName, pxNextTC
2214:lib/FreeRTOS/tasks.c **** 						}
2215:lib/FreeRTOS/tasks.c **** 						#else
2216:lib/FreeRTOS/tasks.c **** 						{
2217:lib/FreeRTOS/tasks.c **** 							/* sizeof( int ) == sizeof( long ) so a smaller
2218:lib/FreeRTOS/tasks.c **** 							printf() library can be used. */
2219:lib/FreeRTOS/tasks.c **** 							sprintf( pcStatsString, ( char * ) "%s\t\t%u\t\t%u%%\r\n", pxNextTCB->pcTaskName, ( unsigned
2220:lib/FreeRTOS/tasks.c **** 						}
2221:lib/FreeRTOS/tasks.c **** 						#endif
2222:lib/FreeRTOS/tasks.c **** 					}
2223:lib/FreeRTOS/tasks.c **** 					else
2224:lib/FreeRTOS/tasks.c **** 					{
2225:lib/FreeRTOS/tasks.c **** 						/* If the percentage is zero here then the task has
2226:lib/FreeRTOS/tasks.c **** 						consumed less than 1% of the total run time. */
2227:lib/FreeRTOS/tasks.c **** 						#ifdef portLU_PRINTF_SPECIFIER_REQUIRED
2228:lib/FreeRTOS/tasks.c **** 						{
2229:lib/FreeRTOS/tasks.c **** 							sprintf( pcStatsString, ( char * ) "%s\t\t%lu\t\t<1%%\r\n", pxNextTCB->pcTaskName, pxNextTCB
2230:lib/FreeRTOS/tasks.c **** 						}
2231:lib/FreeRTOS/tasks.c **** 						#else
2232:lib/FreeRTOS/tasks.c **** 						{
2233:lib/FreeRTOS/tasks.c **** 							/* sizeof( int ) == sizeof( long ) so a smaller
2234:lib/FreeRTOS/tasks.c **** 							printf() library can be used. */
2235:lib/FreeRTOS/tasks.c **** 							sprintf( pcStatsString, ( char * ) "%s\t\t%u\t\t<1%%\r\n", pxNextTCB->pcTaskName, ( unsigned
2236:lib/FreeRTOS/tasks.c **** 						}
2237:lib/FreeRTOS/tasks.c **** 						#endif
2238:lib/FreeRTOS/tasks.c **** 					}
2239:lib/FreeRTOS/tasks.c **** 				}
2240:lib/FreeRTOS/tasks.c **** 
2241:lib/FreeRTOS/tasks.c **** 				strcat( ( char * ) pcWriteBuffer, ( char * ) pcStatsString );
2242:lib/FreeRTOS/tasks.c **** 			}
2243:lib/FreeRTOS/tasks.c **** 
2244:lib/FreeRTOS/tasks.c **** 		} while( pxNextTCB != pxFirstTCB );
2245:lib/FreeRTOS/tasks.c **** 	}
2246:lib/FreeRTOS/tasks.c **** 
2247:lib/FreeRTOS/tasks.c **** #endif
2248:lib/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
2249:lib/FreeRTOS/tasks.c **** 
2250:lib/FreeRTOS/tasks.c **** #if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )
2251:lib/FreeRTOS/tasks.c **** 
2252:lib/FreeRTOS/tasks.c **** 	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
2253:lib/FreeRTOS/tasks.c **** 	{
 3716              		.loc 1 2253 0
 3717              		.cfi_startproc
 3718              		@ args = 0, pretend = 0, frame = 8
 3719              		@ frame_needed = 1, uses_anonymous_args = 0
 3720              		@ link register save eliminated.
 3721 0000 90B4     		push	{r4, r7}
 3722              	.LCFI101:
 3723              		.cfi_def_cfa_offset 8
 3724 0002 82B0     		sub	sp, sp, #8
 3725              	.LCFI102:
 3726              		.cfi_def_cfa_offset 16
 3727 0004 00AF     		add	r7, sp, #0
 3728              		.cfi_offset 7, -4
 3729              		.cfi_offset 4, -8
 3730              	.LCFI103:
 3731              		.cfi_def_cfa_register 7
 3732 0006 7860     		str	r0, [r7, #4]
2254:lib/FreeRTOS/tasks.c **** 	register unsigned short usCount = 0U;
 3733              		.loc 1 2254 0
 3734 0008 4FF00004 		mov	r4, #0
2255:lib/FreeRTOS/tasks.c **** 
2256:lib/FreeRTOS/tasks.c **** 		while( *pucStackByte == tskSTACK_FILL_BYTE )
 3735              		.loc 1 2256 0
 3736 000c 06E0     		b	.L245
 3737              	.L246:
2257:lib/FreeRTOS/tasks.c **** 		{
2258:lib/FreeRTOS/tasks.c **** 			pucStackByte -= portSTACK_GROWTH;
 3738              		.loc 1 2258 0
 3739 000e 7B68     		ldr	r3, [r7, #4]
 3740 0010 03F10103 		add	r3, r3, #1
 3741 0014 7B60     		str	r3, [r7, #4]
2259:lib/FreeRTOS/tasks.c **** 			usCount++;
 3742              		.loc 1 2259 0
 3743 0016 04F10103 		add	r3, r4, #1
 3744 001a 9CB2     		uxth	r4, r3
 3745              	.L245:
2256:lib/FreeRTOS/tasks.c **** 		while( *pucStackByte == tskSTACK_FILL_BYTE )
 3746              		.loc 1 2256 0 discriminator 1
 3747 001c 7B68     		ldr	r3, [r7, #4]
 3748 001e 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 3749 0020 A52B     		cmp	r3, #165
 3750 0022 F4D0     		beq	.L246
2260:lib/FreeRTOS/tasks.c **** 		}
2261:lib/FreeRTOS/tasks.c **** 
2262:lib/FreeRTOS/tasks.c **** 		usCount /= sizeof( portSTACK_TYPE );
 3751              		.loc 1 2262 0
 3752 0024 4FEA9403 		lsr	r3, r4, #2
 3753 0028 9CB2     		uxth	r4, r3
2263:lib/FreeRTOS/tasks.c **** 
2264:lib/FreeRTOS/tasks.c **** 		return usCount;
 3754              		.loc 1 2264 0
 3755 002a 2346     		mov	r3, r4
2265:lib/FreeRTOS/tasks.c **** 	}
 3756              		.loc 1 2265 0
 3757 002c 1846     		mov	r0, r3
 3758 002e 07F10807 		add	r7, r7, #8
 3759 0032 BD46     		mov	sp, r7
 3760 0034 90BC     		pop	{r4, r7}
 3761 0036 7047     		bx	lr
 3762              		.cfi_endproc
 3763              	.LFE145:
 3765              		.section	.text.prvDeleteTCB,"ax",%progbits
 3766              		.align	2
 3767              		.thumb
 3768              		.thumb_func
 3770              	prvDeleteTCB:
 3771              	.LFB146:
2266:lib/FreeRTOS/tasks.c **** 
2267:lib/FreeRTOS/tasks.c **** #endif
2268:lib/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
2269:lib/FreeRTOS/tasks.c **** 
2270:lib/FreeRTOS/tasks.c **** #if ( INCLUDE_uxTaskGetStackHighWaterMark == 1 )
2271:lib/FreeRTOS/tasks.c **** 
2272:lib/FreeRTOS/tasks.c **** 	unsigned portBASE_TYPE uxTaskGetStackHighWaterMark( xTaskHandle xTask )
2273:lib/FreeRTOS/tasks.c **** 	{
2274:lib/FreeRTOS/tasks.c **** 	tskTCB *pxTCB;
2275:lib/FreeRTOS/tasks.c **** 	unsigned char *pcEndOfStack;
2276:lib/FreeRTOS/tasks.c **** 	unsigned portBASE_TYPE uxReturn;
2277:lib/FreeRTOS/tasks.c **** 
2278:lib/FreeRTOS/tasks.c **** 		pxTCB = prvGetTCBFromHandle( xTask );
2279:lib/FreeRTOS/tasks.c **** 
2280:lib/FreeRTOS/tasks.c **** 		#if portSTACK_GROWTH < 0
2281:lib/FreeRTOS/tasks.c **** 		{
2282:lib/FreeRTOS/tasks.c **** 			pcEndOfStack = ( unsigned char * ) pxTCB->pxStack;
2283:lib/FreeRTOS/tasks.c **** 		}
2284:lib/FreeRTOS/tasks.c **** 		#else
2285:lib/FreeRTOS/tasks.c **** 		{
2286:lib/FreeRTOS/tasks.c **** 			pcEndOfStack = ( unsigned char * ) pxTCB->pxEndOfStack;
2287:lib/FreeRTOS/tasks.c **** 		}
2288:lib/FreeRTOS/tasks.c **** 		#endif
2289:lib/FreeRTOS/tasks.c **** 
2290:lib/FreeRTOS/tasks.c **** 		uxReturn = ( unsigned portBASE_TYPE ) usTaskCheckFreeStackSpace( pcEndOfStack );
2291:lib/FreeRTOS/tasks.c **** 
2292:lib/FreeRTOS/tasks.c **** 		return uxReturn;
2293:lib/FreeRTOS/tasks.c **** 	}
2294:lib/FreeRTOS/tasks.c **** 
2295:lib/FreeRTOS/tasks.c **** #endif
2296:lib/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
2297:lib/FreeRTOS/tasks.c **** 
2298:lib/FreeRTOS/tasks.c **** #if ( INCLUDE_vTaskDelete == 1 )
2299:lib/FreeRTOS/tasks.c **** 
2300:lib/FreeRTOS/tasks.c **** 	static void prvDeleteTCB( tskTCB *pxTCB )
2301:lib/FreeRTOS/tasks.c **** 	{
 3772              		.loc 1 2301 0
 3773              		.cfi_startproc
 3774              		@ args = 0, pretend = 0, frame = 8
 3775              		@ frame_needed = 1, uses_anonymous_args = 0
 3776 0000 80B5     		push	{r7, lr}
 3777              	.LCFI104:
 3778              		.cfi_def_cfa_offset 8
 3779 0002 82B0     		sub	sp, sp, #8
 3780              	.LCFI105:
 3781              		.cfi_def_cfa_offset 16
 3782 0004 00AF     		add	r7, sp, #0
 3783              		.cfi_offset 14, -4
 3784              		.cfi_offset 7, -8
 3785              	.LCFI106:
 3786              		.cfi_def_cfa_register 7
 3787 0006 7860     		str	r0, [r7, #4]
2302:lib/FreeRTOS/tasks.c **** 		/* This call is required specifically for the TriCore port.  It must be
2303:lib/FreeRTOS/tasks.c **** 		above the vPortFree() calls. */
2304:lib/FreeRTOS/tasks.c **** 		portCLEAN_UP_TCB( pxTCB );
2305:lib/FreeRTOS/tasks.c **** 
2306:lib/FreeRTOS/tasks.c **** 		/* Free up the memory allocated by the scheduler for the task.  It is up to
2307:lib/FreeRTOS/tasks.c **** 		the task to free any memory allocated at the application level. */
2308:lib/FreeRTOS/tasks.c **** 		vPortFreeAligned( pxTCB->pxStack );
 3788              		.loc 1 2308 0
 3789 0008 7B68     		ldr	r3, [r7, #4]
 3790 000a 1B6B     		ldr	r3, [r3, #48]
 3791 000c 1846     		mov	r0, r3
 3792 000e FFF7FEFF 		bl	vPortFree
2309:lib/FreeRTOS/tasks.c **** 		vPortFree( pxTCB );
 3793              		.loc 1 2309 0
 3794 0012 7868     		ldr	r0, [r7, #4]
 3795 0014 FFF7FEFF 		bl	vPortFree
2310:lib/FreeRTOS/tasks.c **** 	}
 3796              		.loc 1 2310 0
 3797 0018 07F10807 		add	r7, r7, #8
 3798 001c BD46     		mov	sp, r7
 3799 001e 80BD     		pop	{r7, pc}
 3800              		.cfi_endproc
 3801              	.LFE146:
 3803              		.section	.text.xTaskGetCurrentTaskHandle,"ax",%progbits
 3804              		.align	2
 3805              		.global	xTaskGetCurrentTaskHandle
 3806              		.thumb
 3807              		.thumb_func
 3809              	xTaskGetCurrentTaskHandle:
 3810              	.LFB147:
2311:lib/FreeRTOS/tasks.c **** 
2312:lib/FreeRTOS/tasks.c **** #endif
2313:lib/FreeRTOS/tasks.c **** 
2314:lib/FreeRTOS/tasks.c **** 
2315:lib/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
2316:lib/FreeRTOS/tasks.c **** 
2317:lib/FreeRTOS/tasks.c **** #if ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) )
2318:lib/FreeRTOS/tasks.c **** 
2319:lib/FreeRTOS/tasks.c **** 	xTaskHandle xTaskGetCurrentTaskHandle( void )
2320:lib/FreeRTOS/tasks.c **** 	{
 3811              		.loc 1 2320 0
 3812              		.cfi_startproc
 3813              		@ args = 0, pretend = 0, frame = 8
 3814              		@ frame_needed = 1, uses_anonymous_args = 0
 3815              		@ link register save eliminated.
 3816 0000 80B4     		push	{r7}
 3817              	.LCFI107:
 3818              		.cfi_def_cfa_offset 4
 3819 0002 83B0     		sub	sp, sp, #12
 3820              	.LCFI108:
 3821              		.cfi_def_cfa_offset 16
 3822 0004 00AF     		add	r7, sp, #0
 3823              		.cfi_offset 7, -4
 3824              	.LCFI109:
 3825              		.cfi_def_cfa_register 7
2321:lib/FreeRTOS/tasks.c **** 	xTaskHandle xReturn;
2322:lib/FreeRTOS/tasks.c **** 
2323:lib/FreeRTOS/tasks.c **** 		/* A critical section is not required as this is not called from
2324:lib/FreeRTOS/tasks.c **** 		an interrupt and the current TCB will always be the same for any
2325:lib/FreeRTOS/tasks.c **** 		individual execution thread. */
2326:lib/FreeRTOS/tasks.c **** 		xReturn = pxCurrentTCB;
 3826              		.loc 1 2326 0
 3827 0006 054B     		ldr	r3, .L249
 3828 0008 1B68     		ldr	r3, [r3, #0]
 3829 000a 7B60     		str	r3, [r7, #4]
2327:lib/FreeRTOS/tasks.c **** 
2328:lib/FreeRTOS/tasks.c **** 		return xReturn;
 3830              		.loc 1 2328 0
 3831 000c 7B68     		ldr	r3, [r7, #4]
2329:lib/FreeRTOS/tasks.c **** 	}
 3832              		.loc 1 2329 0
 3833 000e 1846     		mov	r0, r3
 3834 0010 07F10C07 		add	r7, r7, #12
 3835 0014 BD46     		mov	sp, r7
 3836 0016 80BC     		pop	{r7}
 3837 0018 7047     		bx	lr
 3838              	.L250:
 3839 001a 00BF     		.align	2
 3840              	.L249:
 3841 001c 00000000 		.word	pxCurrentTCB
 3842              		.cfi_endproc
 3843              	.LFE147:
 3845              		.section	.text.xTaskGetSchedulerState,"ax",%progbits
 3846              		.align	2
 3847              		.global	xTaskGetSchedulerState
 3848              		.thumb
 3849              		.thumb_func
 3851              	xTaskGetSchedulerState:
 3852              	.LFB148:
2330:lib/FreeRTOS/tasks.c **** 
2331:lib/FreeRTOS/tasks.c **** #endif
2332:lib/FreeRTOS/tasks.c **** 
2333:lib/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
2334:lib/FreeRTOS/tasks.c **** 
2335:lib/FreeRTOS/tasks.c **** #if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
2336:lib/FreeRTOS/tasks.c **** 
2337:lib/FreeRTOS/tasks.c **** 	portBASE_TYPE xTaskGetSchedulerState( void )
2338:lib/FreeRTOS/tasks.c **** 	{
 3853              		.loc 1 2338 0
 3854              		.cfi_startproc
 3855              		@ args = 0, pretend = 0, frame = 8
 3856              		@ frame_needed = 1, uses_anonymous_args = 0
 3857              		@ link register save eliminated.
 3858 0000 80B4     		push	{r7}
 3859              	.LCFI110:
 3860              		.cfi_def_cfa_offset 4
 3861 0002 83B0     		sub	sp, sp, #12
 3862              	.LCFI111:
 3863              		.cfi_def_cfa_offset 16
 3864 0004 00AF     		add	r7, sp, #0
 3865              		.cfi_offset 7, -4
 3866              	.LCFI112:
 3867              		.cfi_def_cfa_register 7
2339:lib/FreeRTOS/tasks.c **** 	portBASE_TYPE xReturn;
2340:lib/FreeRTOS/tasks.c **** 
2341:lib/FreeRTOS/tasks.c **** 		if( xSchedulerRunning == pdFALSE )
 3868              		.loc 1 2341 0
 3869 0006 0D4B     		ldr	r3, .L255
 3870 0008 1B68     		ldr	r3, [r3, #0]
 3871 000a 002B     		cmp	r3, #0
 3872 000c 03D1     		bne	.L252
2342:lib/FreeRTOS/tasks.c **** 		{
2343:lib/FreeRTOS/tasks.c **** 			xReturn = taskSCHEDULER_NOT_STARTED;
 3873              		.loc 1 2343 0
 3874 000e 4FF00003 		mov	r3, #0
 3875 0012 7B60     		str	r3, [r7, #4]
 3876 0014 0AE0     		b	.L253
 3877              	.L252:
2344:lib/FreeRTOS/tasks.c **** 		}
2345:lib/FreeRTOS/tasks.c **** 		else
2346:lib/FreeRTOS/tasks.c **** 		{
2347:lib/FreeRTOS/tasks.c **** 			if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
 3878              		.loc 1 2347 0
 3879 0016 0A4B     		ldr	r3, .L255+4
 3880 0018 1B68     		ldr	r3, [r3, #0]
 3881 001a 002B     		cmp	r3, #0
 3882 001c 03D1     		bne	.L254
2348:lib/FreeRTOS/tasks.c **** 			{
2349:lib/FreeRTOS/tasks.c **** 				xReturn = taskSCHEDULER_RUNNING;
 3883              		.loc 1 2349 0
 3884 001e 4FF00103 		mov	r3, #1
 3885 0022 7B60     		str	r3, [r7, #4]
 3886 0024 02E0     		b	.L253
 3887              	.L254:
2350:lib/FreeRTOS/tasks.c **** 			}
2351:lib/FreeRTOS/tasks.c **** 			else
2352:lib/FreeRTOS/tasks.c **** 			{
2353:lib/FreeRTOS/tasks.c **** 				xReturn = taskSCHEDULER_SUSPENDED;
 3888              		.loc 1 2353 0
 3889 0026 4FF00203 		mov	r3, #2
 3890 002a 7B60     		str	r3, [r7, #4]
 3891              	.L253:
2354:lib/FreeRTOS/tasks.c **** 			}
2355:lib/FreeRTOS/tasks.c **** 		}
2356:lib/FreeRTOS/tasks.c **** 
2357:lib/FreeRTOS/tasks.c **** 		return xReturn;
 3892              		.loc 1 2357 0
 3893 002c 7B68     		ldr	r3, [r7, #4]
2358:lib/FreeRTOS/tasks.c **** 	}
 3894              		.loc 1 2358 0
 3895 002e 1846     		mov	r0, r3
 3896 0030 07F10C07 		add	r7, r7, #12
 3897 0034 BD46     		mov	sp, r7
 3898 0036 80BC     		pop	{r7}
 3899 0038 7047     		bx	lr
 3900              	.L256:
 3901 003a 00BF     		.align	2
 3902              	.L255:
 3903 003c 00000000 		.word	xSchedulerRunning
 3904 0040 00000000 		.word	uxSchedulerSuspended
 3905              		.cfi_endproc
 3906              	.LFE148:
 3908              		.section	.text.vTaskPriorityInherit,"ax",%progbits
 3909              		.align	2
 3910              		.global	vTaskPriorityInherit
 3911              		.thumb
 3912              		.thumb_func
 3914              	vTaskPriorityInherit:
 3915              	.LFB149:
2359:lib/FreeRTOS/tasks.c **** 
2360:lib/FreeRTOS/tasks.c **** #endif
2361:lib/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
2362:lib/FreeRTOS/tasks.c **** 
2363:lib/FreeRTOS/tasks.c **** #if ( configUSE_MUTEXES == 1 )
2364:lib/FreeRTOS/tasks.c **** 
2365:lib/FreeRTOS/tasks.c **** 	void vTaskPriorityInherit( xTaskHandle * const pxMutexHolder )
2366:lib/FreeRTOS/tasks.c **** 	{
 3916              		.loc 1 2366 0
 3917              		.cfi_startproc
 3918              		@ args = 0, pretend = 0, frame = 16
 3919              		@ frame_needed = 1, uses_anonymous_args = 0
 3920 0000 80B5     		push	{r7, lr}
 3921              	.LCFI113:
 3922              		.cfi_def_cfa_offset 8
 3923 0002 84B0     		sub	sp, sp, #16
 3924              	.LCFI114:
 3925              		.cfi_def_cfa_offset 24
 3926 0004 00AF     		add	r7, sp, #0
 3927              		.cfi_offset 14, -4
 3928              		.cfi_offset 7, -8
 3929              	.LCFI115:
 3930              		.cfi_def_cfa_register 7
 3931 0006 7860     		str	r0, [r7, #4]
2367:lib/FreeRTOS/tasks.c **** 	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;
 3932              		.loc 1 2367 0
 3933 0008 7B68     		ldr	r3, [r7, #4]
 3934 000a FB60     		str	r3, [r7, #12]
2368:lib/FreeRTOS/tasks.c **** 
2369:lib/FreeRTOS/tasks.c **** 		configASSERT( pxMutexHolder );
 3935              		.loc 1 2369 0
 3936 000c 7B68     		ldr	r3, [r7, #4]
 3937 000e 002B     		cmp	r3, #0
 3938 0010 04D1     		bne	.L258
 3939              		.loc 1 2369 0 is_stmt 0 discriminator 1
 3940              	@ 2369 "lib/FreeRTOS/tasks.c" 1
 3941 0012 4FF0BF00 			mov r0, #191								
 3942 0016 80F31188 		msr basepri, r0							
 3943              	
 3944              	@ 0 "" 2
 3945              		.thumb
 3946              	.L259:
 3947              		.loc 1 2369 0 discriminator 2
 3948 001a FEE7     		b	.L259
 3949              	.L258:
2370:lib/FreeRTOS/tasks.c **** 
2371:lib/FreeRTOS/tasks.c **** 		if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
 3950              		.loc 1 2371 0 is_stmt 1
 3951 001c FB68     		ldr	r3, [r7, #12]
 3952 001e DA6A     		ldr	r2, [r3, #44]
 3953 0020 254B     		ldr	r3, .L263
 3954 0022 1B68     		ldr	r3, [r3, #0]
 3955 0024 DB6A     		ldr	r3, [r3, #44]
 3956 0026 9A42     		cmp	r2, r3
 3957 0028 42D2     		bcs	.L257
2372:lib/FreeRTOS/tasks.c **** 		{
2373:lib/FreeRTOS/tasks.c **** 			/* Adjust the mutex holder state to account for its new priority. */
2374:lib/FreeRTOS/tasks.c **** 			listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxC
 3958              		.loc 1 2374 0
 3959 002a 234B     		ldr	r3, .L263
 3960 002c 1B68     		ldr	r3, [r3, #0]
 3961 002e DB6A     		ldr	r3, [r3, #44]
 3962 0030 C3F10502 		rsb	r2, r3, #5
 3963 0034 FB68     		ldr	r3, [r7, #12]
 3964 0036 9A61     		str	r2, [r3, #24]
2375:lib/FreeRTOS/tasks.c **** 
2376:lib/FreeRTOS/tasks.c **** 			/* If the task being modified is in the ready state it will need to
2377:lib/FreeRTOS/tasks.c **** 			be moved in to a new list. */
2378:lib/FreeRTOS/tasks.c **** 			if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericList
 3965              		.loc 1 2378 0
 3966 0038 FB68     		ldr	r3, [r7, #12]
 3967 003a 5969     		ldr	r1, [r3, #20]
 3968 003c FB68     		ldr	r3, [r7, #12]
 3969 003e DA6A     		ldr	r2, [r3, #44]
 3970 0040 1346     		mov	r3, r2
 3971 0042 4FEA8303 		lsl	r3, r3, #2
 3972 0046 9B18     		adds	r3, r3, r2
 3973 0048 4FEA8303 		lsl	r3, r3, #2
 3974 004c 1A46     		mov	r2, r3
 3975 004e 1B4B     		ldr	r3, .L263+4
 3976 0050 D318     		adds	r3, r2, r3
 3977 0052 9942     		cmp	r1, r3
 3978 0054 27D1     		bne	.L261
2379:lib/FreeRTOS/tasks.c **** 			{
2380:lib/FreeRTOS/tasks.c **** 				vListRemove( &( pxTCB->xGenericListItem ) );
 3979              		.loc 1 2380 0
 3980 0056 FB68     		ldr	r3, [r7, #12]
 3981 0058 03F10403 		add	r3, r3, #4
 3982 005c 1846     		mov	r0, r3
 3983 005e FFF7FEFF 		bl	vListRemove
2381:lib/FreeRTOS/tasks.c **** 
2382:lib/FreeRTOS/tasks.c **** 				/* Inherit the priority before being moved into the new list. */
2383:lib/FreeRTOS/tasks.c **** 				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
 3984              		.loc 1 2383 0
 3985 0062 154B     		ldr	r3, .L263
 3986 0064 1B68     		ldr	r3, [r3, #0]
 3987 0066 DA6A     		ldr	r2, [r3, #44]
 3988 0068 FB68     		ldr	r3, [r7, #12]
 3989 006a DA62     		str	r2, [r3, #44]
2384:lib/FreeRTOS/tasks.c **** 				prvAddTaskToReadyQueue( pxTCB );
 3990              		.loc 1 2384 0
 3991 006c FB68     		ldr	r3, [r7, #12]
 3992 006e DA6A     		ldr	r2, [r3, #44]
 3993 0070 134B     		ldr	r3, .L263+8
 3994 0072 1B68     		ldr	r3, [r3, #0]
 3995 0074 9A42     		cmp	r2, r3
 3996 0076 03D9     		bls	.L262
 3997              		.loc 1 2384 0 is_stmt 0 discriminator 1
 3998 0078 FB68     		ldr	r3, [r7, #12]
 3999 007a DA6A     		ldr	r2, [r3, #44]
 4000 007c 104B     		ldr	r3, .L263+8
 4001 007e 1A60     		str	r2, [r3, #0]
 4002              	.L262:
 4003              		.loc 1 2384 0 discriminator 2
 4004 0080 FB68     		ldr	r3, [r7, #12]
 4005 0082 DA6A     		ldr	r2, [r3, #44]
 4006 0084 1346     		mov	r3, r2
 4007 0086 4FEA8303 		lsl	r3, r3, #2
 4008 008a 9B18     		adds	r3, r3, r2
 4009 008c 4FEA8303 		lsl	r3, r3, #2
 4010 0090 1A46     		mov	r2, r3
 4011 0092 0A4B     		ldr	r3, .L263+4
 4012 0094 D218     		adds	r2, r2, r3
 4013 0096 FB68     		ldr	r3, [r7, #12]
 4014 0098 03F10403 		add	r3, r3, #4
 4015 009c 1046     		mov	r0, r2
 4016 009e 1946     		mov	r1, r3
 4017 00a0 FFF7FEFF 		bl	vListInsertEnd
 4018 00a4 04E0     		b	.L257
 4019              	.L261:
2385:lib/FreeRTOS/tasks.c **** 			}
2386:lib/FreeRTOS/tasks.c **** 			else
2387:lib/FreeRTOS/tasks.c **** 			{
2388:lib/FreeRTOS/tasks.c **** 				/* Just inherit the priority. */
2389:lib/FreeRTOS/tasks.c **** 				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
 4020              		.loc 1 2389 0 is_stmt 1
 4021 00a6 044B     		ldr	r3, .L263
 4022 00a8 1B68     		ldr	r3, [r3, #0]
 4023 00aa DA6A     		ldr	r2, [r3, #44]
 4024 00ac FB68     		ldr	r3, [r7, #12]
 4025 00ae DA62     		str	r2, [r3, #44]
 4026              	.L257:
2390:lib/FreeRTOS/tasks.c **** 			}
2391:lib/FreeRTOS/tasks.c **** 
2392:lib/FreeRTOS/tasks.c **** 			traceTASK_PRIORITY_INHERIT( pxTCB, pxCurrentTCB->uxPriority );
2393:lib/FreeRTOS/tasks.c **** 		}
2394:lib/FreeRTOS/tasks.c **** 	}
 4027              		.loc 1 2394 0
 4028 00b0 07F11007 		add	r7, r7, #16
 4029 00b4 BD46     		mov	sp, r7
 4030 00b6 80BD     		pop	{r7, pc}
 4031              	.L264:
 4032              		.align	2
 4033              	.L263:
 4034 00b8 00000000 		.word	pxCurrentTCB
 4035 00bc 00000000 		.word	pxReadyTasksLists
 4036 00c0 00000000 		.word	uxTopReadyPriority
 4037              		.cfi_endproc
 4038              	.LFE149:
 4040              		.section	.text.vTaskPriorityDisinherit,"ax",%progbits
 4041              		.align	2
 4042              		.global	vTaskPriorityDisinherit
 4043              		.thumb
 4044              		.thumb_func
 4046              	vTaskPriorityDisinherit:
 4047              	.LFB150:
2395:lib/FreeRTOS/tasks.c **** 
2396:lib/FreeRTOS/tasks.c **** #endif
2397:lib/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
2398:lib/FreeRTOS/tasks.c **** 
2399:lib/FreeRTOS/tasks.c **** #if ( configUSE_MUTEXES == 1 )
2400:lib/FreeRTOS/tasks.c **** 
2401:lib/FreeRTOS/tasks.c **** 	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
2402:lib/FreeRTOS/tasks.c **** 	{
 4048              		.loc 1 2402 0
 4049              		.cfi_startproc
 4050              		@ args = 0, pretend = 0, frame = 16
 4051              		@ frame_needed = 1, uses_anonymous_args = 0
 4052 0000 80B5     		push	{r7, lr}
 4053              	.LCFI116:
 4054              		.cfi_def_cfa_offset 8
 4055 0002 84B0     		sub	sp, sp, #16
 4056              	.LCFI117:
 4057              		.cfi_def_cfa_offset 24
 4058 0004 00AF     		add	r7, sp, #0
 4059              		.cfi_offset 14, -4
 4060              		.cfi_offset 7, -8
 4061              	.LCFI118:
 4062              		.cfi_def_cfa_register 7
 4063 0006 7860     		str	r0, [r7, #4]
2403:lib/FreeRTOS/tasks.c **** 	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;
 4064              		.loc 1 2403 0
 4065 0008 7B68     		ldr	r3, [r7, #4]
 4066 000a FB60     		str	r3, [r7, #12]
2404:lib/FreeRTOS/tasks.c **** 
2405:lib/FreeRTOS/tasks.c **** 		if( pxMutexHolder != NULL )
 4067              		.loc 1 2405 0
 4068 000c 7B68     		ldr	r3, [r7, #4]
 4069 000e 002B     		cmp	r3, #0
 4070 0010 31D0     		beq	.L265
2406:lib/FreeRTOS/tasks.c **** 		{
2407:lib/FreeRTOS/tasks.c **** 			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
 4071              		.loc 1 2407 0
 4072 0012 FB68     		ldr	r3, [r7, #12]
 4073 0014 DA6A     		ldr	r2, [r3, #44]
 4074 0016 FB68     		ldr	r3, [r7, #12]
 4075 0018 9B6C     		ldr	r3, [r3, #72]
 4076 001a 9A42     		cmp	r2, r3
 4077 001c 2BD0     		beq	.L265
2408:lib/FreeRTOS/tasks.c **** 			{
2409:lib/FreeRTOS/tasks.c **** 				/* We must be the running task to be able to give the mutex back.
2410:lib/FreeRTOS/tasks.c **** 				Remove ourselves from the ready list we currently appear in. */
2411:lib/FreeRTOS/tasks.c **** 				vListRemove( &( pxTCB->xGenericListItem ) );
 4078              		.loc 1 2411 0
 4079 001e FB68     		ldr	r3, [r7, #12]
 4080 0020 03F10403 		add	r3, r3, #4
 4081 0024 1846     		mov	r0, r3
 4082 0026 FFF7FEFF 		bl	vListRemove
2412:lib/FreeRTOS/tasks.c **** 
2413:lib/FreeRTOS/tasks.c **** 				/* Disinherit the priority before adding the task into the new
2414:lib/FreeRTOS/tasks.c **** 				ready list. */
2415:lib/FreeRTOS/tasks.c **** 				traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
2416:lib/FreeRTOS/tasks.c **** 				pxTCB->uxPriority = pxTCB->uxBasePriority;
 4083              		.loc 1 2416 0
 4084 002a FB68     		ldr	r3, [r7, #12]
 4085 002c 9A6C     		ldr	r2, [r3, #72]
 4086 002e FB68     		ldr	r3, [r7, #12]
 4087 0030 DA62     		str	r2, [r3, #44]
2417:lib/FreeRTOS/tasks.c **** 				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) px
 4088              		.loc 1 2417 0
 4089 0032 FB68     		ldr	r3, [r7, #12]
 4090 0034 DB6A     		ldr	r3, [r3, #44]
 4091 0036 C3F10502 		rsb	r2, r3, #5
 4092 003a FB68     		ldr	r3, [r7, #12]
 4093 003c 9A61     		str	r2, [r3, #24]
2418:lib/FreeRTOS/tasks.c **** 				prvAddTaskToReadyQueue( pxTCB );
 4094              		.loc 1 2418 0
 4095 003e FB68     		ldr	r3, [r7, #12]
 4096 0040 DA6A     		ldr	r2, [r3, #44]
 4097 0042 0F4B     		ldr	r3, .L268
 4098 0044 1B68     		ldr	r3, [r3, #0]
 4099 0046 9A42     		cmp	r2, r3
 4100 0048 03D9     		bls	.L267
 4101              		.loc 1 2418 0 is_stmt 0 discriminator 1
 4102 004a FB68     		ldr	r3, [r7, #12]
 4103 004c DA6A     		ldr	r2, [r3, #44]
 4104 004e 0C4B     		ldr	r3, .L268
 4105 0050 1A60     		str	r2, [r3, #0]
 4106              	.L267:
 4107              		.loc 1 2418 0 discriminator 2
 4108 0052 FB68     		ldr	r3, [r7, #12]
 4109 0054 DA6A     		ldr	r2, [r3, #44]
 4110 0056 1346     		mov	r3, r2
 4111 0058 4FEA8303 		lsl	r3, r3, #2
 4112 005c 9B18     		adds	r3, r3, r2
 4113 005e 4FEA8303 		lsl	r3, r3, #2
 4114 0062 1A46     		mov	r2, r3
 4115 0064 074B     		ldr	r3, .L268+4
 4116 0066 D218     		adds	r2, r2, r3
 4117 0068 FB68     		ldr	r3, [r7, #12]
 4118 006a 03F10403 		add	r3, r3, #4
 4119 006e 1046     		mov	r0, r2
 4120 0070 1946     		mov	r1, r3
 4121 0072 FFF7FEFF 		bl	vListInsertEnd
 4122              	.L265:
2419:lib/FreeRTOS/tasks.c **** 			}
2420:lib/FreeRTOS/tasks.c **** 		}
2421:lib/FreeRTOS/tasks.c **** 	}
 4123              		.loc 1 2421 0 is_stmt 1
 4124 0076 07F11007 		add	r7, r7, #16
 4125 007a BD46     		mov	sp, r7
 4126 007c 80BD     		pop	{r7, pc}
 4127              	.L269:
 4128 007e 00BF     		.align	2
 4129              	.L268:
 4130 0080 00000000 		.word	uxTopReadyPriority
 4131 0084 00000000 		.word	pxReadyTasksLists
 4132              		.cfi_endproc
 4133              	.LFE150:
 4135              		.section	.bss.pcStatusString.8648,"aw",%nobits
 4136              		.align	2
 4139              	pcStatusString.8648:
 4140 0000 00000000 		.space	50
 4140      00000000 
 4140      00000000 
 4140      00000000 
 4140      00000000 
 4141 0032 0000     		.text
 4142              	.Letext0:
DEFINED SYMBOLS
                            *ABS*:00000000 tasks.c
C:\Users\junpei\AppData\Local\Temp\ccHZLkSd.s:29     .bss.pxCurrentTCB:00000000 pxCurrentTCB
C:\Users\junpei\AppData\Local\Temp\ccHZLkSd.s:26     .bss.pxCurrentTCB:00000000 $d
C:\Users\junpei\AppData\Local\Temp\ccHZLkSd.s:32     .bss.pxReadyTasksLists:00000000 $d
C:\Users\junpei\AppData\Local\Temp\ccHZLkSd.s:35     .bss.pxReadyTasksLists:00000000 pxReadyTasksLists
C:\Users\junpei\AppData\Local\Temp\ccHZLkSd.s:38     .bss.xDelayedTaskList1:00000000 $d
C:\Users\junpei\AppData\Local\Temp\ccHZLkSd.s:41     .bss.xDelayedTaskList1:00000000 xDelayedTaskList1
C:\Users\junpei\AppData\Local\Temp\ccHZLkSd.s:44     .bss.xDelayedTaskList2:00000000 $d
C:\Users\junpei\AppData\Local\Temp\ccHZLkSd.s:47     .bss.xDelayedTaskList2:00000000 xDelayedTaskList2
C:\Users\junpei\AppData\Local\Temp\ccHZLkSd.s:50     .bss.pxDelayedTaskList:00000000 $d
C:\Users\junpei\AppData\Local\Temp\ccHZLkSd.s:53     .bss.pxDelayedTaskList:00000000 pxDelayedTaskList
C:\Users\junpei\AppData\Local\Temp\ccHZLkSd.s:56     .bss.pxOverflowDelayedTaskList:00000000 $d
C:\Users\junpei\AppData\Local\Temp\ccHZLkSd.s:59     .bss.pxOverflowDelayedTaskList:00000000 pxOverflowDelayedTaskList
C:\Users\junpei\AppData\Local\Temp\ccHZLkSd.s:62     .bss.xPendingReadyList:00000000 $d
C:\Users\junpei\AppData\Local\Temp\ccHZLkSd.s:65     .bss.xPendingReadyList:00000000 xPendingReadyList
C:\Users\junpei\AppData\Local\Temp\ccHZLkSd.s:68     .bss.xTasksWaitingTermination:00000000 $d
C:\Users\junpei\AppData\Local\Temp\ccHZLkSd.s:71     .bss.xTasksWaitingTermination:00000000 xTasksWaitingTermination
C:\Users\junpei\AppData\Local\Temp\ccHZLkSd.s:74     .bss.uxTasksDeleted:00000000 $d
C:\Users\junpei\AppData\Local\Temp\ccHZLkSd.s:77     .bss.uxTasksDeleted:00000000 uxTasksDeleted
C:\Users\junpei\AppData\Local\Temp\ccHZLkSd.s:80     .bss.xSuspendedTaskList:00000000 $d
C:\Users\junpei\AppData\Local\Temp\ccHZLkSd.s:83     .bss.xSuspendedTaskList:00000000 xSuspendedTaskList
C:\Users\junpei\AppData\Local\Temp\ccHZLkSd.s:86     .bss.uxCurrentNumberOfTasks:00000000 $d
C:\Users\junpei\AppData\Local\Temp\ccHZLkSd.s:89     .bss.uxCurrentNumberOfTasks:00000000 uxCurrentNumberOfTasks
C:\Users\junpei\AppData\Local\Temp\ccHZLkSd.s:92     .bss.xTickCount:00000000 $d
C:\Users\junpei\AppData\Local\Temp\ccHZLkSd.s:95     .bss.xTickCount:00000000 xTickCount
C:\Users\junpei\AppData\Local\Temp\ccHZLkSd.s:98     .bss.uxTopUsedPriority:00000000 $d
C:\Users\junpei\AppData\Local\Temp\ccHZLkSd.s:101    .bss.uxTopUsedPriority:00000000 uxTopUsedPriority
C:\Users\junpei\AppData\Local\Temp\ccHZLkSd.s:104    .bss.uxTopReadyPriority:00000000 $d
C:\Users\junpei\AppData\Local\Temp\ccHZLkSd.s:107    .bss.uxTopReadyPriority:00000000 uxTopReadyPriority
C:\Users\junpei\AppData\Local\Temp\ccHZLkSd.s:110    .bss.xSchedulerRunning:00000000 $d
C:\Users\junpei\AppData\Local\Temp\ccHZLkSd.s:113    .bss.xSchedulerRunning:00000000 xSchedulerRunning
C:\Users\junpei\AppData\Local\Temp\ccHZLkSd.s:116    .bss.uxSchedulerSuspended:00000000 $d
C:\Users\junpei\AppData\Local\Temp\ccHZLkSd.s:119    .bss.uxSchedulerSuspended:00000000 uxSchedulerSuspended
C:\Users\junpei\AppData\Local\Temp\ccHZLkSd.s:122    .bss.uxMissedTicks:00000000 $d
C:\Users\junpei\AppData\Local\Temp\ccHZLkSd.s:125    .bss.uxMissedTicks:00000000 uxMissedTicks
C:\Users\junpei\AppData\Local\Temp\ccHZLkSd.s:128    .bss.xMissedYield:00000000 $d
C:\Users\junpei\AppData\Local\Temp\ccHZLkSd.s:131    .bss.xMissedYield:00000000 xMissedYield
C:\Users\junpei\AppData\Local\Temp\ccHZLkSd.s:134    .bss.xNumOfOverflows:00000000 $d
C:\Users\junpei\AppData\Local\Temp\ccHZLkSd.s:137    .bss.xNumOfOverflows:00000000 xNumOfOverflows
C:\Users\junpei\AppData\Local\Temp\ccHZLkSd.s:140    .bss.uxTCBNumber:00000000 $d
C:\Users\junpei\AppData\Local\Temp\ccHZLkSd.s:143    .bss.uxTCBNumber:00000000 uxTCBNumber
C:\Users\junpei\AppData\Local\Temp\ccHZLkSd.s:146    .data.xNextTaskUnblockTime:00000000 $d
C:\Users\junpei\AppData\Local\Temp\ccHZLkSd.s:149    .data.xNextTaskUnblockTime:00000000 xNextTaskUnblockTime
C:\Users\junpei\AppData\Local\Temp\ccHZLkSd.s:152    .text.xTaskGenericCreate:00000000 $t
C:\Users\junpei\AppData\Local\Temp\ccHZLkSd.s:157    .text.xTaskGenericCreate:00000000 xTaskGenericCreate
C:\Users\junpei\AppData\Local\Temp\ccHZLkSd.s:3498   .text.prvAllocateTCBAndStack:00000000 prvAllocateTCBAndStack
C:\Users\junpei\AppData\Local\Temp\ccHZLkSd.s:3157   .text.prvInitialiseTCBVariables:00000000 prvInitialiseTCBVariables
C:\Users\junpei\AppData\Local\Temp\ccHZLkSd.s:3240   .text.prvInitialiseTaskLists:00000000 prvInitialiseTaskLists
C:\Users\junpei\AppData\Local\Temp\ccHZLkSd.s:411    .text.xTaskGenericCreate:00000184 $d
C:\Users\junpei\AppData\Local\Temp\ccHZLkSd.s:422    .text.vTaskDelete:00000000 $t
C:\Users\junpei\AppData\Local\Temp\ccHZLkSd.s:427    .text.vTaskDelete:00000000 vTaskDelete
C:\Users\junpei\AppData\Local\Temp\ccHZLkSd.s:526    .text.vTaskDelete:00000090 $d
C:\Users\junpei\AppData\Local\Temp\ccHZLkSd.s:535    .text.vTaskDelayUntil:00000000 $t
C:\Users\junpei\AppData\Local\Temp\ccHZLkSd.s:540    .text.vTaskDelayUntil:00000000 vTaskDelayUntil
C:\Users\junpei\AppData\Local\Temp\ccHZLkSd.s:1621   .text.vTaskSuspendAll:00000000 vTaskSuspendAll
C:\Users\junpei\AppData\Local\Temp\ccHZLkSd.s:3418   .text.prvAddCurrentTaskToDelayedList:00000000 prvAddCurrentTaskToDelayedList
C:\Users\junpei\AppData\Local\Temp\ccHZLkSd.s:1658   .text.xTaskResumeAll:00000000 xTaskResumeAll
C:\Users\junpei\AppData\Local\Temp\ccHZLkSd.s:676    .text.vTaskDelayUntil:000000b8 $d
C:\Users\junpei\AppData\Local\Temp\ccHZLkSd.s:682    .text.vTaskDelay:00000000 $t
C:\Users\junpei\AppData\Local\Temp\ccHZLkSd.s:687    .text.vTaskDelay:00000000 vTaskDelay
C:\Users\junpei\AppData\Local\Temp\ccHZLkSd.s:747    .text.vTaskDelay:00000050 $d
C:\Users\junpei\AppData\Local\Temp\ccHZLkSd.s:753    .text.uxTaskPriorityGet:00000000 $t
C:\Users\junpei\AppData\Local\Temp\ccHZLkSd.s:758    .text.uxTaskPriorityGet:00000000 uxTaskPriorityGet
C:\Users\junpei\AppData\Local\Temp\ccHZLkSd.s:808    .text.uxTaskPriorityGet:00000034 $d
C:\Users\junpei\AppData\Local\Temp\ccHZLkSd.s:813    .text.vTaskPrioritySet:00000000 $t
C:\Users\junpei\AppData\Local\Temp\ccHZLkSd.s:818    .text.vTaskPrioritySet:00000000 vTaskPrioritySet
C:\Users\junpei\AppData\Local\Temp\ccHZLkSd.s:1004   .text.vTaskPrioritySet:00000118 $d
C:\Users\junpei\AppData\Local\Temp\ccHZLkSd.s:1011   .text.vTaskSuspend:00000000 $t
C:\Users\junpei\AppData\Local\Temp\ccHZLkSd.s:1016   .text.vTaskSuspend:00000000 vTaskSuspend
C:\Users\junpei\AppData\Local\Temp\ccHZLkSd.s:2358   .text.vTaskSwitchContext:00000000 vTaskSwitchContext
C:\Users\junpei\AppData\Local\Temp\ccHZLkSd.s:1120   .text.vTaskSuspend:00000094 $d
C:\Users\junpei\AppData\Local\Temp\ccHZLkSd.s:1128   .text.xTaskIsTaskSuspended:00000000 $t
C:\Users\junpei\AppData\Local\Temp\ccHZLkSd.s:1133   .text.xTaskIsTaskSuspended:00000000 xTaskIsTaskSuspended
C:\Users\junpei\AppData\Local\Temp\ccHZLkSd.s:1204   .text.xTaskIsTaskSuspended:00000054 $d
C:\Users\junpei\AppData\Local\Temp\ccHZLkSd.s:1210   .text.vTaskResume:00000000 $t
C:\Users\junpei\AppData\Local\Temp\ccHZLkSd.s:1215   .text.vTaskResume:00000000 vTaskResume
C:\Users\junpei\AppData\Local\Temp\ccHZLkSd.s:1323   .text.vTaskResume:000000a0 $d
C:\Users\junpei\AppData\Local\Temp\ccHZLkSd.s:1330   .text.xTaskResumeFromISR:00000000 $t
C:\Users\junpei\AppData\Local\Temp\ccHZLkSd.s:1335   .text.xTaskResumeFromISR:00000000 xTaskResumeFromISR
C:\Users\junpei\AppData\Local\Temp\ccHZLkSd.s:1464   .text.xTaskResumeFromISR:000000c0 $d
C:\Users\junpei\AppData\Local\Temp\ccHZLkSd.s:1473   .rodata:00000000 $d
C:\Users\junpei\AppData\Local\Temp\ccHZLkSd.s:1477   .text.vTaskStartScheduler:00000000 $t
C:\Users\junpei\AppData\Local\Temp\ccHZLkSd.s:1482   .text.vTaskStartScheduler:00000000 vTaskStartScheduler
C:\Users\junpei\AppData\Local\Temp\ccHZLkSd.s:1566   .text.vTaskStartScheduler:00000078 $d
C:\Users\junpei\AppData\Local\Temp\ccHZLkSd.s:3110   .text.prvIdleTask:00000000 prvIdleTask
C:\Users\junpei\AppData\Local\Temp\ccHZLkSd.s:1574   .text.vTaskEndScheduler:00000000 $t
C:\Users\junpei\AppData\Local\Temp\ccHZLkSd.s:1579   .text.vTaskEndScheduler:00000000 vTaskEndScheduler
C:\Users\junpei\AppData\Local\Temp\ccHZLkSd.s:1611   .text.vTaskEndScheduler:0000001c $d
C:\Users\junpei\AppData\Local\Temp\ccHZLkSd.s:1616   .text.vTaskSuspendAll:00000000 $t
C:\Users\junpei\AppData\Local\Temp\ccHZLkSd.s:1648   .text.vTaskSuspendAll:00000018 $d
C:\Users\junpei\AppData\Local\Temp\ccHZLkSd.s:1653   .text.xTaskResumeAll:00000000 $t
C:\Users\junpei\AppData\Local\Temp\ccHZLkSd.s:2134   .text.vTaskIncrementTick:00000000 vTaskIncrementTick
C:\Users\junpei\AppData\Local\Temp\ccHZLkSd.s:1832   .text.xTaskResumeAll:00000104 $d
C:\Users\junpei\AppData\Local\Temp\ccHZLkSd.s:1844   .text.xTaskGetTickCount:00000000 $t
C:\Users\junpei\AppData\Local\Temp\ccHZLkSd.s:1849   .text.xTaskGetTickCount:00000000 xTaskGetTickCount
C:\Users\junpei\AppData\Local\Temp\ccHZLkSd.s:1884   .text.xTaskGetTickCount:00000020 $d
C:\Users\junpei\AppData\Local\Temp\ccHZLkSd.s:1889   .text.xTaskGetTickCountFromISR:00000000 $t
C:\Users\junpei\AppData\Local\Temp\ccHZLkSd.s:1894   .text.xTaskGetTickCountFromISR:00000000 xTaskGetTickCountFromISR
C:\Users\junpei\AppData\Local\Temp\ccHZLkSd.s:1942   .text.xTaskGetTickCountFromISR:00000030 $d
C:\Users\junpei\AppData\Local\Temp\ccHZLkSd.s:1947   .text.uxTaskGetNumberOfTasks:00000000 $t
C:\Users\junpei\AppData\Local\Temp\ccHZLkSd.s:1952   .text.uxTaskGetNumberOfTasks:00000000 uxTaskGetNumberOfTasks
C:\Users\junpei\AppData\Local\Temp\ccHZLkSd.s:1977   .text.uxTaskGetNumberOfTasks:00000010 $d
C:\Users\junpei\AppData\Local\Temp\ccHZLkSd.s:1986   .text.vTaskList:00000000 $t
C:\Users\junpei\AppData\Local\Temp\ccHZLkSd.s:1991   .text.vTaskList:00000000 vTaskList
C:\Users\junpei\AppData\Local\Temp\ccHZLkSd.s:3587   .text.prvListTaskWithinSingleList:00000000 prvListTaskWithinSingleList
C:\Users\junpei\AppData\Local\Temp\ccHZLkSd.s:2118   .text.vTaskList:000000d8 $d
C:\Users\junpei\AppData\Local\Temp\ccHZLkSd.s:2129   .text.vTaskIncrementTick:00000000 $t
C:\Users\junpei\AppData\Local\Temp\ccHZLkSd.s:2340   .text.vTaskIncrementTick:00000140 $d
C:\Users\junpei\AppData\Local\Temp\ccHZLkSd.s:2353   .text.vTaskSwitchContext:00000000 $t
C:\Users\junpei\AppData\Local\Temp\ccHZLkSd.s:2473   .text.vTaskSwitchContext:000000a8 $d
C:\Users\junpei\AppData\Local\Temp\ccHZLkSd.s:2482   .text.vTaskPlaceOnEventList:00000000 $t
C:\Users\junpei\AppData\Local\Temp\ccHZLkSd.s:2487   .text.vTaskPlaceOnEventList:00000000 vTaskPlaceOnEventList
C:\Users\junpei\AppData\Local\Temp\ccHZLkSd.s:2564   .text.vTaskPlaceOnEventList:0000006c $d
C:\Users\junpei\AppData\Local\Temp\ccHZLkSd.s:2571   .text.vTaskPlaceOnEventListRestricted:00000000 $t
C:\Users\junpei\AppData\Local\Temp\ccHZLkSd.s:2576   .text.vTaskPlaceOnEventListRestricted:00000000 vTaskPlaceOnEventListRestricted
C:\Users\junpei\AppData\Local\Temp\ccHZLkSd.s:2639   .text.vTaskPlaceOnEventListRestricted:00000050 $d
C:\Users\junpei\AppData\Local\Temp\ccHZLkSd.s:2645   .text.xTaskRemoveFromEventList:00000000 $t
C:\Users\junpei\AppData\Local\Temp\ccHZLkSd.s:2650   .text.xTaskRemoveFromEventList:00000000 xTaskRemoveFromEventList
C:\Users\junpei\AppData\Local\Temp\ccHZLkSd.s:2767   .text.xTaskRemoveFromEventList:000000b0 $d
C:\Users\junpei\AppData\Local\Temp\ccHZLkSd.s:2776   .text.vTaskSetTimeOutState:00000000 $t
C:\Users\junpei\AppData\Local\Temp\ccHZLkSd.s:2781   .text.vTaskSetTimeOutState:00000000 vTaskSetTimeOutState
C:\Users\junpei\AppData\Local\Temp\ccHZLkSd.s:2832   .text.vTaskSetTimeOutState:00000034 $d
C:\Users\junpei\AppData\Local\Temp\ccHZLkSd.s:2838   .text.xTaskCheckForTimeOut:00000000 $t
C:\Users\junpei\AppData\Local\Temp\ccHZLkSd.s:2843   .text.xTaskCheckForTimeOut:00000000 xTaskCheckForTimeOut
C:\Users\junpei\AppData\Local\Temp\ccHZLkSd.s:2968   .text.xTaskCheckForTimeOut:000000ac $d
C:\Users\junpei\AppData\Local\Temp\ccHZLkSd.s:2974   .text.vTaskMissedYield:00000000 $t
C:\Users\junpei\AppData\Local\Temp\ccHZLkSd.s:2979   .text.vTaskMissedYield:00000000 vTaskMissedYield
C:\Users\junpei\AppData\Local\Temp\ccHZLkSd.s:3004   .text.vTaskMissedYield:00000014 $d
C:\Users\junpei\AppData\Local\Temp\ccHZLkSd.s:3009   .text.uxTaskGetTaskNumber:00000000 $t
C:\Users\junpei\AppData\Local\Temp\ccHZLkSd.s:3014   .text.uxTaskGetTaskNumber:00000000 uxTaskGetTaskNumber
C:\Users\junpei\AppData\Local\Temp\ccHZLkSd.s:3061   .text.vTaskSetTaskNumber:00000000 $t
C:\Users\junpei\AppData\Local\Temp\ccHZLkSd.s:3066   .text.vTaskSetTaskNumber:00000000 vTaskSetTaskNumber
C:\Users\junpei\AppData\Local\Temp\ccHZLkSd.s:3106   .text.prvIdleTask:00000000 $t
C:\Users\junpei\AppData\Local\Temp\ccHZLkSd.s:3328   .text.prvCheckTasksWaitingTermination:00000000 prvCheckTasksWaitingTermination
C:\Users\junpei\AppData\Local\Temp\ccHZLkSd.s:3148   .text.prvIdleTask:00000020 $d
C:\Users\junpei\AppData\Local\Temp\ccHZLkSd.s:3153   .text.prvInitialiseTCBVariables:00000000 $t
C:\Users\junpei\AppData\Local\Temp\ccHZLkSd.s:3236   .text.prvInitialiseTaskLists:00000000 $t
C:\Users\junpei\AppData\Local\Temp\ccHZLkSd.s:3312   .text.prvInitialiseTaskLists:00000068 $d
C:\Users\junpei\AppData\Local\Temp\ccHZLkSd.s:3324   .text.prvCheckTasksWaitingTermination:00000000 $t
C:\Users\junpei\AppData\Local\Temp\ccHZLkSd.s:3770   .text.prvDeleteTCB:00000000 prvDeleteTCB
C:\Users\junpei\AppData\Local\Temp\ccHZLkSd.s:3407   .text.prvCheckTasksWaitingTermination:0000006c $d
C:\Users\junpei\AppData\Local\Temp\ccHZLkSd.s:3414   .text.prvAddCurrentTaskToDelayedList:00000000 $t
C:\Users\junpei\AppData\Local\Temp\ccHZLkSd.s:3485   .text.prvAddCurrentTaskToDelayedList:0000005c $d
C:\Users\junpei\AppData\Local\Temp\ccHZLkSd.s:3494   .text.prvAllocateTCBAndStack:00000000 $t
C:\Users\junpei\AppData\Local\Temp\ccHZLkSd.s:3583   .text.prvListTaskWithinSingleList:00000000 $t
C:\Users\junpei\AppData\Local\Temp\ccHZLkSd.s:3714   .text.usTaskCheckFreeStackSpace:00000000 usTaskCheckFreeStackSpace
C:\Users\junpei\AppData\Local\Temp\ccHZLkSd.s:3704   .text.prvListTaskWithinSingleList:000000b4 $d
C:\Users\junpei\AppData\Local\Temp\ccHZLkSd.s:4139   .bss.pcStatusString.8648:00000000 pcStatusString.8648
C:\Users\junpei\AppData\Local\Temp\ccHZLkSd.s:3710   .text.usTaskCheckFreeStackSpace:00000000 $t
C:\Users\junpei\AppData\Local\Temp\ccHZLkSd.s:3766   .text.prvDeleteTCB:00000000 $t
C:\Users\junpei\AppData\Local\Temp\ccHZLkSd.s:3804   .text.xTaskGetCurrentTaskHandle:00000000 $t
C:\Users\junpei\AppData\Local\Temp\ccHZLkSd.s:3809   .text.xTaskGetCurrentTaskHandle:00000000 xTaskGetCurrentTaskHandle
C:\Users\junpei\AppData\Local\Temp\ccHZLkSd.s:3841   .text.xTaskGetCurrentTaskHandle:0000001c $d
C:\Users\junpei\AppData\Local\Temp\ccHZLkSd.s:3846   .text.xTaskGetSchedulerState:00000000 $t
C:\Users\junpei\AppData\Local\Temp\ccHZLkSd.s:3851   .text.xTaskGetSchedulerState:00000000 xTaskGetSchedulerState
C:\Users\junpei\AppData\Local\Temp\ccHZLkSd.s:3903   .text.xTaskGetSchedulerState:0000003c $d
C:\Users\junpei\AppData\Local\Temp\ccHZLkSd.s:3909   .text.vTaskPriorityInherit:00000000 $t
C:\Users\junpei\AppData\Local\Temp\ccHZLkSd.s:3914   .text.vTaskPriorityInherit:00000000 vTaskPriorityInherit
C:\Users\junpei\AppData\Local\Temp\ccHZLkSd.s:4034   .text.vTaskPriorityInherit:000000b8 $d
C:\Users\junpei\AppData\Local\Temp\ccHZLkSd.s:4041   .text.vTaskPriorityDisinherit:00000000 $t
C:\Users\junpei\AppData\Local\Temp\ccHZLkSd.s:4046   .text.vTaskPriorityDisinherit:00000000 vTaskPriorityDisinherit
C:\Users\junpei\AppData\Local\Temp\ccHZLkSd.s:4130   .text.vTaskPriorityDisinherit:00000080 $d
C:\Users\junpei\AppData\Local\Temp\ccHZLkSd.s:4136   .bss.pcStatusString.8648:00000000 $d
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
pxPortInitialiseStack
vPortEnterCritical
vListInsertEnd
vPortExitCritical
vPortYieldFromISR
vListRemove
xTimerCreateTimerTask
xPortStartScheduler
vPortEndScheduler
strcat
vApplicationTickHook
vListInsert
vApplicationIdleHook
strncpy
vListInitialiseItem
vListInitialise
pvPortMalloc
vPortFree
memset
sprintf
