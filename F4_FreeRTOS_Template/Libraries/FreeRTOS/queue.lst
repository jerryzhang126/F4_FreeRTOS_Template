   1              		.syntax unified
   2              		.cpu cortex-m4
   3              		.eabi_attribute 27, 3
   4              		.fpu fpv4-sp-d16
   5              		.eabi_attribute 20, 1
   6              		.eabi_attribute 21, 1
   7              		.eabi_attribute 23, 3
   8              		.eabi_attribute 24, 1
   9              		.eabi_attribute 25, 1
  10              		.eabi_attribute 26, 1
  11              		.eabi_attribute 30, 6
  12              		.eabi_attribute 18, 4
  13              		.thumb
  14              		.file	"queue.c"
  22              	.Ltext0:
  23              		.cfi_sections	.debug_frame
  24              		.global	xQueueRegistry
  25              		.section	.bss.xQueueRegistry,"aw",%nobits
  26              		.align	2
  29              	xQueueRegistry:
  30 0000 00000000 		.space	64
  30      00000000 
  30      00000000 
  30      00000000 
  30      00000000 
  31              		.section	.text.xQueueGenericCreate,"ax",%progbits
  32              		.align	2
  33              		.global	xQueueGenericCreate
  34              		.thumb
  35              		.thumb_func
  37              	xQueueGenericCreate:
  38              	.LFB110:
  39              		.file 1 "lib/FreeRTOS/queue.c"
   1:lib/FreeRTOS/queue.c **** /*
   2:lib/FreeRTOS/queue.c ****     FreeRTOS V7.1.0 - Copyright (C) 2011 Real Time Engineers Ltd.
   3:lib/FreeRTOS/queue.c **** 
   4:lib/FreeRTOS/queue.c **** 
   5:lib/FreeRTOS/queue.c ****     ***************************************************************************
   6:lib/FreeRTOS/queue.c ****      *                                                                       *
   7:lib/FreeRTOS/queue.c ****      *    FreeRTOS tutorial books are available in pdf and paperback.        *
   8:lib/FreeRTOS/queue.c ****      *    Complete, revised, and edited pdf reference manuals are also       *
   9:lib/FreeRTOS/queue.c ****      *    available.                                                         *
  10:lib/FreeRTOS/queue.c ****      *                                                                       *
  11:lib/FreeRTOS/queue.c ****      *    Purchasing FreeRTOS documentation will not only help you, by       *
  12:lib/FreeRTOS/queue.c ****      *    ensuring you get running as quickly as possible and with an        *
  13:lib/FreeRTOS/queue.c ****      *    in-depth knowledge of how to use FreeRTOS, it will also help       *
  14:lib/FreeRTOS/queue.c ****      *    the FreeRTOS project to continue with its mission of providing     *
  15:lib/FreeRTOS/queue.c ****      *    professional grade, cross platform, de facto standard solutions    *
  16:lib/FreeRTOS/queue.c ****      *    for microcontrollers - completely free of charge!                  *
  17:lib/FreeRTOS/queue.c ****      *                                                                       *
  18:lib/FreeRTOS/queue.c ****      *    >>> See http://www.FreeRTOS.org/Documentation for details. <<<     *
  19:lib/FreeRTOS/queue.c ****      *                                                                       *
  20:lib/FreeRTOS/queue.c ****      *    Thank you for using FreeRTOS, and thank you for your support!      *
  21:lib/FreeRTOS/queue.c ****      *                                                                       *
  22:lib/FreeRTOS/queue.c ****     ***************************************************************************
  23:lib/FreeRTOS/queue.c **** 
  24:lib/FreeRTOS/queue.c **** 
  25:lib/FreeRTOS/queue.c ****     This file is part of the FreeRTOS distribution.
  26:lib/FreeRTOS/queue.c **** 
  27:lib/FreeRTOS/queue.c ****     FreeRTOS is free software; you can redistribute it and/or modify it under
  28:lib/FreeRTOS/queue.c ****     the terms of the GNU General Public License (version 2) as published by the
  29:lib/FreeRTOS/queue.c ****     Free Software Foundation AND MODIFIED BY the FreeRTOS exception.
  30:lib/FreeRTOS/queue.c ****     >>>NOTE<<< The modification to the GPL is included to allow you to
  31:lib/FreeRTOS/queue.c ****     distribute a combined work that includes FreeRTOS without being obliged to
  32:lib/FreeRTOS/queue.c ****     provide the source code for proprietary components outside of the FreeRTOS
  33:lib/FreeRTOS/queue.c ****     kernel.  FreeRTOS is distributed in the hope that it will be useful, but
  34:lib/FreeRTOS/queue.c ****     WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  35:lib/FreeRTOS/queue.c ****     or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
  36:lib/FreeRTOS/queue.c ****     more details. You should have received a copy of the GNU General Public
  37:lib/FreeRTOS/queue.c ****     License and the FreeRTOS license exception along with FreeRTOS; if not it
  38:lib/FreeRTOS/queue.c ****     can be viewed here: http://www.freertos.org/a00114.html and also obtained
  39:lib/FreeRTOS/queue.c ****     by writing to Richard Barry, contact details for whom are available on the
  40:lib/FreeRTOS/queue.c ****     FreeRTOS WEB site.
  41:lib/FreeRTOS/queue.c **** 
  42:lib/FreeRTOS/queue.c ****     1 tab == 4 spaces!
  43:lib/FreeRTOS/queue.c **** 
  44:lib/FreeRTOS/queue.c ****     http://www.FreeRTOS.org - Documentation, latest information, license and
  45:lib/FreeRTOS/queue.c ****     contact details.
  46:lib/FreeRTOS/queue.c **** 
  47:lib/FreeRTOS/queue.c ****     http://www.SafeRTOS.com - A version that is certified for use in safety
  48:lib/FreeRTOS/queue.c ****     critical systems.
  49:lib/FreeRTOS/queue.c **** 
  50:lib/FreeRTOS/queue.c ****     http://www.OpenRTOS.com - Commercial support, development, porting,
  51:lib/FreeRTOS/queue.c ****     licensing and training services.
  52:lib/FreeRTOS/queue.c **** */
  53:lib/FreeRTOS/queue.c **** 
  54:lib/FreeRTOS/queue.c **** #include <stdlib.h>
  55:lib/FreeRTOS/queue.c **** #include <string.h>
  56:lib/FreeRTOS/queue.c **** 
  57:lib/FreeRTOS/queue.c **** /* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
  58:lib/FreeRTOS/queue.c **** all the API functions to use the MPU wrappers.  That should only be done when
  59:lib/FreeRTOS/queue.c **** task.h is included from an application file. */
  60:lib/FreeRTOS/queue.c **** #define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
  61:lib/FreeRTOS/queue.c **** 
  62:lib/FreeRTOS/queue.c **** #include "FreeRTOS.h"
  63:lib/FreeRTOS/queue.c **** #include "task.h"
  64:lib/FreeRTOS/queue.c **** 
  65:lib/FreeRTOS/queue.c **** #if ( configUSE_CO_ROUTINES == 1 )
  66:lib/FreeRTOS/queue.c **** 	#include "croutine.h"
  67:lib/FreeRTOS/queue.c **** #endif
  68:lib/FreeRTOS/queue.c **** 
  69:lib/FreeRTOS/queue.c **** #undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE
  70:lib/FreeRTOS/queue.c **** 
  71:lib/FreeRTOS/queue.c **** /*-----------------------------------------------------------
  72:lib/FreeRTOS/queue.c ****  * PUBLIC LIST API documented in list.h
  73:lib/FreeRTOS/queue.c ****  *----------------------------------------------------------*/
  74:lib/FreeRTOS/queue.c **** 
  75:lib/FreeRTOS/queue.c **** /* Constants used with the cRxLock and cTxLock structure members. */
  76:lib/FreeRTOS/queue.c **** #define queueUNLOCKED					( ( signed portBASE_TYPE ) -1 )
  77:lib/FreeRTOS/queue.c **** #define queueLOCKED_UNMODIFIED			( ( signed portBASE_TYPE ) 0 )
  78:lib/FreeRTOS/queue.c **** 
  79:lib/FreeRTOS/queue.c **** #define queueERRONEOUS_UNBLOCK			( -1 )
  80:lib/FreeRTOS/queue.c **** 
  81:lib/FreeRTOS/queue.c **** /* For internal use only. */
  82:lib/FreeRTOS/queue.c **** #define	queueSEND_TO_BACK				( 0 )
  83:lib/FreeRTOS/queue.c **** #define	queueSEND_TO_FRONT				( 1 )
  84:lib/FreeRTOS/queue.c **** 
  85:lib/FreeRTOS/queue.c **** /* Effectively make a union out of the xQUEUE structure. */
  86:lib/FreeRTOS/queue.c **** #define pxMutexHolder					pcTail
  87:lib/FreeRTOS/queue.c **** #define uxQueueType						pcHead
  88:lib/FreeRTOS/queue.c **** #define uxRecursiveCallCount			pcReadFrom
  89:lib/FreeRTOS/queue.c **** #define queueQUEUE_IS_MUTEX				NULL
  90:lib/FreeRTOS/queue.c **** 
  91:lib/FreeRTOS/queue.c **** /* Semaphores do not actually store or copy data, so have an items size of
  92:lib/FreeRTOS/queue.c **** zero. */
  93:lib/FreeRTOS/queue.c **** #define queueSEMAPHORE_QUEUE_ITEM_LENGTH ( ( unsigned portBASE_TYPE ) 0 )
  94:lib/FreeRTOS/queue.c **** #define queueDONT_BLOCK					 ( ( portTickType ) 0U )
  95:lib/FreeRTOS/queue.c **** #define queueMUTEX_GIVE_BLOCK_TIME		 ( ( portTickType ) 0U )
  96:lib/FreeRTOS/queue.c **** 
  97:lib/FreeRTOS/queue.c **** /* These definitions *must* match those in queue.h. */
  98:lib/FreeRTOS/queue.c **** #define queueQUEUE_TYPE_BASE				( 0U )
  99:lib/FreeRTOS/queue.c **** #define queueQUEUE_TYPE_MUTEX 				( 1U )
 100:lib/FreeRTOS/queue.c **** #define queueQUEUE_TYPE_COUNTING_SEMAPHORE	( 2U )
 101:lib/FreeRTOS/queue.c **** #define queueQUEUE_TYPE_BINARY_SEMAPHORE	( 3U )
 102:lib/FreeRTOS/queue.c **** #define queueQUEUE_TYPE_RECURSIVE_MUTEX		( 4U )
 103:lib/FreeRTOS/queue.c **** 
 104:lib/FreeRTOS/queue.c **** /*
 105:lib/FreeRTOS/queue.c ****  * Definition of the queue used by the scheduler.
 106:lib/FreeRTOS/queue.c ****  * Items are queued by copy, not reference.
 107:lib/FreeRTOS/queue.c ****  */
 108:lib/FreeRTOS/queue.c **** typedef struct QueueDefinition
 109:lib/FreeRTOS/queue.c **** {
 110:lib/FreeRTOS/queue.c **** 	signed char *pcHead;				/*< Points to the beginning of the queue storage area. */
 111:lib/FreeRTOS/queue.c **** 	signed char *pcTail;				/*< Points to the byte at the end of the queue storage area.  Once more by
 112:lib/FreeRTOS/queue.c **** 
 113:lib/FreeRTOS/queue.c **** 	signed char *pcWriteTo;				/*< Points to the free next place in the storage area. */
 114:lib/FreeRTOS/queue.c **** 	signed char *pcReadFrom;			/*< Points to the last place that a queued item was read from. */
 115:lib/FreeRTOS/queue.c **** 
 116:lib/FreeRTOS/queue.c **** 	xList xTasksWaitingToSend;				/*< List of tasks that are blocked waiting to post onto this queue. 
 117:lib/FreeRTOS/queue.c **** 	xList xTasksWaitingToReceive;			/*< List of tasks that are blocked waiting to read from this queue
 118:lib/FreeRTOS/queue.c **** 
 119:lib/FreeRTOS/queue.c **** 	volatile unsigned portBASE_TYPE uxMessagesWaiting;/*< The number of items currently in the queue. 
 120:lib/FreeRTOS/queue.c **** 	unsigned portBASE_TYPE uxLength;		/*< The length of the queue defined as the number of items it wi
 121:lib/FreeRTOS/queue.c **** 	unsigned portBASE_TYPE uxItemSize;		/*< The size of each items that the queue will hold. */
 122:lib/FreeRTOS/queue.c **** 
 123:lib/FreeRTOS/queue.c **** 	signed portBASE_TYPE xRxLock;			/*< Stores the number of items received from the queue (removed fr
 124:lib/FreeRTOS/queue.c **** 	signed portBASE_TYPE xTxLock;			/*< Stores the number of items transmitted to the queue (added to 
 125:lib/FreeRTOS/queue.c **** 	
 126:lib/FreeRTOS/queue.c **** 	#if ( configUSE_TRACE_FACILITY == 1 )
 127:lib/FreeRTOS/queue.c **** 		unsigned char ucQueueNumber;
 128:lib/FreeRTOS/queue.c **** 		unsigned char ucQueueType;
 129:lib/FreeRTOS/queue.c **** 	#endif
 130:lib/FreeRTOS/queue.c **** 
 131:lib/FreeRTOS/queue.c **** } xQUEUE;
 132:lib/FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
 133:lib/FreeRTOS/queue.c **** 
 134:lib/FreeRTOS/queue.c **** /*
 135:lib/FreeRTOS/queue.c ****  * Inside this file xQueueHandle is a pointer to a xQUEUE structure.
 136:lib/FreeRTOS/queue.c ****  * To keep the definition private the API header file defines it as a
 137:lib/FreeRTOS/queue.c ****  * pointer to void.
 138:lib/FreeRTOS/queue.c ****  */
 139:lib/FreeRTOS/queue.c **** typedef xQUEUE * xQueueHandle;
 140:lib/FreeRTOS/queue.c **** 
 141:lib/FreeRTOS/queue.c **** /*
 142:lib/FreeRTOS/queue.c ****  * Prototypes for public functions are included here so we don't have to
 143:lib/FreeRTOS/queue.c ****  * include the API header file (as it defines xQueueHandle differently).  These
 144:lib/FreeRTOS/queue.c ****  * functions are documented in the API header file.
 145:lib/FreeRTOS/queue.c ****  */
 146:lib/FreeRTOS/queue.c **** xQueueHandle xQueueGenericCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxIt
 147:lib/FreeRTOS/queue.c **** signed portBASE_TYPE xQueueGenericSend( xQueueHandle xQueue, const void * const pvItemToQueue, port
 148:lib/FreeRTOS/queue.c **** unsigned portBASE_TYPE uxQueueMessagesWaiting( const xQueueHandle pxQueue ) PRIVILEGED_FUNCTION;
 149:lib/FreeRTOS/queue.c **** void vQueueDelete( xQueueHandle xQueue ) PRIVILEGED_FUNCTION;
 150:lib/FreeRTOS/queue.c **** signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQue
 151:lib/FreeRTOS/queue.c **** signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickTyp
 152:lib/FreeRTOS/queue.c **** signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed port
 153:lib/FreeRTOS/queue.c **** xQueueHandle xQueueCreateMutex( unsigned char ucQueueType ) PRIVILEGED_FUNCTION;
 154:lib/FreeRTOS/queue.c **** xQueueHandle xQueueCreateCountingSemaphore( unsigned portBASE_TYPE uxCountValue, unsigned portBASE_
 155:lib/FreeRTOS/queue.c **** portBASE_TYPE xQueueTakeMutexRecursive( xQueueHandle xMutex, portTickType xBlockTime ) PRIVILEGED_F
 156:lib/FreeRTOS/queue.c **** portBASE_TYPE xQueueGiveMutexRecursive( xQueueHandle xMutex ) PRIVILEGED_FUNCTION;
 157:lib/FreeRTOS/queue.c **** signed portBASE_TYPE xQueueAltGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, 
 158:lib/FreeRTOS/queue.c **** signed portBASE_TYPE xQueueAltGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTick
 159:lib/FreeRTOS/queue.c **** signed portBASE_TYPE xQueueIsQueueEmptyFromISR( const xQueueHandle pxQueue ) PRIVILEGED_FUNCTION;
 160:lib/FreeRTOS/queue.c **** signed portBASE_TYPE xQueueIsQueueFullFromISR( const xQueueHandle pxQueue ) PRIVILEGED_FUNCTION;
 161:lib/FreeRTOS/queue.c **** unsigned portBASE_TYPE uxQueueMessagesWaitingFromISR( const xQueueHandle pxQueue ) PRIVILEGED_FUNCT
 162:lib/FreeRTOS/queue.c **** void vQueueWaitForMessageRestricted( xQueueHandle pxQueue, portTickType xTicksToWait ) PRIVILEGED_F
 163:lib/FreeRTOS/queue.c **** unsigned char ucQueueGetQueueNumber( xQueueHandle pxQueue ) PRIVILEGED_FUNCTION;
 164:lib/FreeRTOS/queue.c **** void vQueueSetQueueNumber( xQueueHandle pxQueue, unsigned char ucQueueNumber ) PRIVILEGED_FUNCTION;
 165:lib/FreeRTOS/queue.c **** unsigned char ucQueueGetQueueType( xQueueHandle pxQueue ) PRIVILEGED_FUNCTION;
 166:lib/FreeRTOS/queue.c **** 
 167:lib/FreeRTOS/queue.c **** /*
 168:lib/FreeRTOS/queue.c ****  * Co-routine queue functions differ from task queue functions.  Co-routines are
 169:lib/FreeRTOS/queue.c ****  * an optional component.
 170:lib/FreeRTOS/queue.c ****  */
 171:lib/FreeRTOS/queue.c **** #if configUSE_CO_ROUTINES == 1
 172:lib/FreeRTOS/queue.c **** 	signed portBASE_TYPE xQueueCRSendFromISR( xQueueHandle pxQueue, const void *pvItemToQueue, signed 
 173:lib/FreeRTOS/queue.c **** 	signed portBASE_TYPE xQueueCRReceiveFromISR( xQueueHandle pxQueue, void *pvBuffer, signed portBASE
 174:lib/FreeRTOS/queue.c **** 	signed portBASE_TYPE xQueueCRSend( xQueueHandle pxQueue, const void *pvItemToQueue, portTickType x
 175:lib/FreeRTOS/queue.c **** 	signed portBASE_TYPE xQueueCRReceive( xQueueHandle pxQueue, void *pvBuffer, portTickType xTicksToW
 176:lib/FreeRTOS/queue.c **** #endif
 177:lib/FreeRTOS/queue.c **** 
 178:lib/FreeRTOS/queue.c **** /*
 179:lib/FreeRTOS/queue.c ****  * The queue registry is just a means for kernel aware debuggers to locate
 180:lib/FreeRTOS/queue.c ****  * queue structures.  It has no other purpose so is an optional component.
 181:lib/FreeRTOS/queue.c ****  */
 182:lib/FreeRTOS/queue.c **** #if configQUEUE_REGISTRY_SIZE > 0
 183:lib/FreeRTOS/queue.c **** 
 184:lib/FreeRTOS/queue.c **** 	/* The type stored within the queue registry array.  This allows a name
 185:lib/FreeRTOS/queue.c **** 	to be assigned to each queue making kernel aware debugging a little
 186:lib/FreeRTOS/queue.c **** 	more user friendly. */
 187:lib/FreeRTOS/queue.c **** 	typedef struct QUEUE_REGISTRY_ITEM
 188:lib/FreeRTOS/queue.c **** 	{
 189:lib/FreeRTOS/queue.c **** 		signed char *pcQueueName;
 190:lib/FreeRTOS/queue.c **** 		xQueueHandle xHandle;
 191:lib/FreeRTOS/queue.c **** 	} xQueueRegistryItem;
 192:lib/FreeRTOS/queue.c **** 
 193:lib/FreeRTOS/queue.c **** 	/* The queue registry is simply an array of xQueueRegistryItem structures.
 194:lib/FreeRTOS/queue.c **** 	The pcQueueName member of a structure being NULL is indicative of the
 195:lib/FreeRTOS/queue.c **** 	array position being vacant. */
 196:lib/FreeRTOS/queue.c **** 	xQueueRegistryItem xQueueRegistry[ configQUEUE_REGISTRY_SIZE ];
 197:lib/FreeRTOS/queue.c **** 
 198:lib/FreeRTOS/queue.c **** 	/* Removes a queue from the registry by simply setting the pcQueueName
 199:lib/FreeRTOS/queue.c **** 	member to NULL. */
 200:lib/FreeRTOS/queue.c **** 	static void vQueueUnregisterQueue( xQueueHandle xQueue ) PRIVILEGED_FUNCTION;
 201:lib/FreeRTOS/queue.c **** 	void vQueueAddToRegistry( xQueueHandle xQueue, signed char *pcQueueName ) PRIVILEGED_FUNCTION;
 202:lib/FreeRTOS/queue.c **** #endif
 203:lib/FreeRTOS/queue.c **** 
 204:lib/FreeRTOS/queue.c **** /*
 205:lib/FreeRTOS/queue.c ****  * Unlocks a queue locked by a call to prvLockQueue.  Locking a queue does not
 206:lib/FreeRTOS/queue.c ****  * prevent an ISR from adding or removing items to the queue, but does prevent
 207:lib/FreeRTOS/queue.c ****  * an ISR from removing tasks from the queue event lists.  If an ISR finds a
 208:lib/FreeRTOS/queue.c ****  * queue is locked it will instead increment the appropriate queue lock count
 209:lib/FreeRTOS/queue.c ****  * to indicate that a task may require unblocking.  When the queue in unlocked
 210:lib/FreeRTOS/queue.c ****  * these lock counts are inspected, and the appropriate action taken.
 211:lib/FreeRTOS/queue.c ****  */
 212:lib/FreeRTOS/queue.c **** static void prvUnlockQueue( xQueueHandle pxQueue ) PRIVILEGED_FUNCTION;
 213:lib/FreeRTOS/queue.c **** 
 214:lib/FreeRTOS/queue.c **** /*
 215:lib/FreeRTOS/queue.c ****  * Uses a critical section to determine if there is any data in a queue.
 216:lib/FreeRTOS/queue.c ****  *
 217:lib/FreeRTOS/queue.c ****  * @return pdTRUE if the queue contains no items, otherwise pdFALSE.
 218:lib/FreeRTOS/queue.c ****  */
 219:lib/FreeRTOS/queue.c **** static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue ) PRIVILEGED_FUNCTION;
 220:lib/FreeRTOS/queue.c **** 
 221:lib/FreeRTOS/queue.c **** /*
 222:lib/FreeRTOS/queue.c ****  * Uses a critical section to determine if there is any space in a queue.
 223:lib/FreeRTOS/queue.c ****  *
 224:lib/FreeRTOS/queue.c ****  * @return pdTRUE if there is no space, otherwise pdFALSE;
 225:lib/FreeRTOS/queue.c ****  */
 226:lib/FreeRTOS/queue.c **** static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue ) PRIVILEGED_FUNCTION;
 227:lib/FreeRTOS/queue.c **** 
 228:lib/FreeRTOS/queue.c **** /*
 229:lib/FreeRTOS/queue.c ****  * Copies an item into the queue, either at the front of the queue or the
 230:lib/FreeRTOS/queue.c ****  * back of the queue.
 231:lib/FreeRTOS/queue.c ****  */
 232:lib/FreeRTOS/queue.c **** static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition
 233:lib/FreeRTOS/queue.c **** 
 234:lib/FreeRTOS/queue.c **** /*
 235:lib/FreeRTOS/queue.c ****  * Copies an item out of a queue.
 236:lib/FreeRTOS/queue.c ****  */
 237:lib/FreeRTOS/queue.c **** static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer ) PRIVILEGED_FUNCTIO
 238:lib/FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
 239:lib/FreeRTOS/queue.c **** 
 240:lib/FreeRTOS/queue.c **** /*
 241:lib/FreeRTOS/queue.c ****  * Macro to mark a queue as locked.  Locking a queue prevents an ISR from
 242:lib/FreeRTOS/queue.c ****  * accessing the queue event lists.
 243:lib/FreeRTOS/queue.c ****  */
 244:lib/FreeRTOS/queue.c **** #define prvLockQueue( pxQueue )								\
 245:lib/FreeRTOS/queue.c **** 	taskENTER_CRITICAL();									\
 246:lib/FreeRTOS/queue.c **** 	{														\
 247:lib/FreeRTOS/queue.c **** 		if( ( pxQueue )->xRxLock == queueUNLOCKED )			\
 248:lib/FreeRTOS/queue.c **** 		{													\
 249:lib/FreeRTOS/queue.c **** 			( pxQueue )->xRxLock = queueLOCKED_UNMODIFIED;	\
 250:lib/FreeRTOS/queue.c **** 		}													\
 251:lib/FreeRTOS/queue.c **** 		if( ( pxQueue )->xTxLock == queueUNLOCKED )			\
 252:lib/FreeRTOS/queue.c **** 		{													\
 253:lib/FreeRTOS/queue.c **** 			( pxQueue )->xTxLock = queueLOCKED_UNMODIFIED;	\
 254:lib/FreeRTOS/queue.c **** 		}													\
 255:lib/FreeRTOS/queue.c **** 	}														\
 256:lib/FreeRTOS/queue.c **** 	taskEXIT_CRITICAL()
 257:lib/FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
 258:lib/FreeRTOS/queue.c **** 
 259:lib/FreeRTOS/queue.c **** 
 260:lib/FreeRTOS/queue.c **** /*-----------------------------------------------------------
 261:lib/FreeRTOS/queue.c ****  * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 262:lib/FreeRTOS/queue.c ****  *----------------------------------------------------------*/
 263:lib/FreeRTOS/queue.c **** 
 264:lib/FreeRTOS/queue.c **** xQueueHandle xQueueGenericCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxIt
 265:lib/FreeRTOS/queue.c **** {
  40              		.loc 1 265 0
  41              		.cfi_startproc
  42              		@ args = 0, pretend = 0, frame = 32
  43              		@ frame_needed = 1, uses_anonymous_args = 0
  44 0000 80B5     		push	{r7, lr}
  45              	.LCFI0:
  46              		.cfi_def_cfa_offset 8
  47 0002 88B0     		sub	sp, sp, #32
  48              	.LCFI1:
  49              		.cfi_def_cfa_offset 40
  50 0004 00AF     		add	r7, sp, #0
  51              		.cfi_offset 14, -4
  52              		.cfi_offset 7, -8
  53              	.LCFI2:
  54              		.cfi_def_cfa_register 7
  55 0006 F860     		str	r0, [r7, #12]
  56 0008 B960     		str	r1, [r7, #8]
  57 000a 1346     		mov	r3, r2
  58 000c FB71     		strb	r3, [r7, #7]
 266:lib/FreeRTOS/queue.c **** xQUEUE *pxNewQueue;
 267:lib/FreeRTOS/queue.c **** size_t xQueueSizeInBytes;
 268:lib/FreeRTOS/queue.c **** xQueueHandle xReturn = NULL;
  59              		.loc 1 268 0
  60 000e 4FF00003 		mov	r3, #0
  61 0012 FB61     		str	r3, [r7, #28]
 269:lib/FreeRTOS/queue.c **** 
 270:lib/FreeRTOS/queue.c **** 	/* Remove compiler warnings about unused parameters should 
 271:lib/FreeRTOS/queue.c **** 	configUSE_TRACE_FACILITY not be set to 1. */
 272:lib/FreeRTOS/queue.c **** 	( void ) ucQueueType;
 273:lib/FreeRTOS/queue.c **** 
 274:lib/FreeRTOS/queue.c **** 	/* Allocate the new queue structure. */
 275:lib/FreeRTOS/queue.c **** 	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
  62              		.loc 1 275 0
  63 0014 FB68     		ldr	r3, [r7, #12]
  64 0016 002B     		cmp	r3, #0
  65 0018 5AD0     		beq	.L2
 276:lib/FreeRTOS/queue.c **** 	{
 277:lib/FreeRTOS/queue.c **** 		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
  66              		.loc 1 277 0
  67 001a 4FF05000 		mov	r0, #80
  68 001e FFF7FEFF 		bl	pvPortMalloc
  69 0022 0346     		mov	r3, r0
  70 0024 BB61     		str	r3, [r7, #24]
 278:lib/FreeRTOS/queue.c **** 		if( pxNewQueue != NULL )
  71              		.loc 1 278 0
  72 0026 BB69     		ldr	r3, [r7, #24]
  73 0028 002B     		cmp	r3, #0
  74 002a 51D0     		beq	.L2
 279:lib/FreeRTOS/queue.c **** 		{
 280:lib/FreeRTOS/queue.c **** 			/* Create the list of pointers to queue items.  The queue is one byte
 281:lib/FreeRTOS/queue.c **** 			longer than asked for to make wrap checking easier/faster. */
 282:lib/FreeRTOS/queue.c **** 			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
  75              		.loc 1 282 0
  76 002c FB68     		ldr	r3, [r7, #12]
  77 002e BA68     		ldr	r2, [r7, #8]
  78 0030 02FB03F3 		mul	r3, r2, r3
  79 0034 03F10103 		add	r3, r3, #1
  80 0038 7B61     		str	r3, [r7, #20]
 283:lib/FreeRTOS/queue.c **** 
 284:lib/FreeRTOS/queue.c **** 			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
  81              		.loc 1 284 0
  82 003a 7869     		ldr	r0, [r7, #20]
  83 003c FFF7FEFF 		bl	pvPortMalloc
  84 0040 0346     		mov	r3, r0
  85 0042 1A46     		mov	r2, r3
  86 0044 BB69     		ldr	r3, [r7, #24]
  87 0046 1A60     		str	r2, [r3, #0]
 285:lib/FreeRTOS/queue.c **** 			if( pxNewQueue->pcHead != NULL )
  88              		.loc 1 285 0
  89 0048 BB69     		ldr	r3, [r7, #24]
  90 004a 1B68     		ldr	r3, [r3, #0]
  91 004c 002B     		cmp	r3, #0
  92 004e 3CD0     		beq	.L3
 286:lib/FreeRTOS/queue.c **** 			{
 287:lib/FreeRTOS/queue.c **** 				/* Initialise the queue members as described above where the
 288:lib/FreeRTOS/queue.c **** 				queue type is defined. */
 289:lib/FreeRTOS/queue.c **** 				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
  93              		.loc 1 289 0
  94 0050 BB69     		ldr	r3, [r7, #24]
  95 0052 1A68     		ldr	r2, [r3, #0]
  96 0054 FB68     		ldr	r3, [r7, #12]
  97 0056 B968     		ldr	r1, [r7, #8]
  98 0058 01FB03F3 		mul	r3, r1, r3
  99 005c D218     		adds	r2, r2, r3
 100 005e BB69     		ldr	r3, [r7, #24]
 101 0060 5A60     		str	r2, [r3, #4]
 290:lib/FreeRTOS/queue.c **** 				pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
 102              		.loc 1 290 0
 103 0062 BB69     		ldr	r3, [r7, #24]
 104 0064 4FF00002 		mov	r2, #0
 105 0068 9A63     		str	r2, [r3, #56]
 291:lib/FreeRTOS/queue.c **** 				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
 106              		.loc 1 291 0
 107 006a BB69     		ldr	r3, [r7, #24]
 108 006c 1A68     		ldr	r2, [r3, #0]
 109 006e BB69     		ldr	r3, [r7, #24]
 110 0070 9A60     		str	r2, [r3, #8]
 292:lib/FreeRTOS/queue.c **** 				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - ( unsigned portBASE_TYPE ) 1U
 111              		.loc 1 292 0
 112 0072 BB69     		ldr	r3, [r7, #24]
 113 0074 1A68     		ldr	r2, [r3, #0]
 114 0076 FB68     		ldr	r3, [r7, #12]
 115 0078 03F1FF33 		add	r3, r3, #-1
 116 007c B968     		ldr	r1, [r7, #8]
 117 007e 01FB03F3 		mul	r3, r1, r3
 118 0082 D218     		adds	r2, r2, r3
 119 0084 BB69     		ldr	r3, [r7, #24]
 120 0086 DA60     		str	r2, [r3, #12]
 293:lib/FreeRTOS/queue.c **** 				pxNewQueue->uxLength = uxQueueLength;
 121              		.loc 1 293 0
 122 0088 BB69     		ldr	r3, [r7, #24]
 123 008a FA68     		ldr	r2, [r7, #12]
 124 008c DA63     		str	r2, [r3, #60]
 294:lib/FreeRTOS/queue.c **** 				pxNewQueue->uxItemSize = uxItemSize;
 125              		.loc 1 294 0
 126 008e BB69     		ldr	r3, [r7, #24]
 127 0090 BA68     		ldr	r2, [r7, #8]
 128 0092 1A64     		str	r2, [r3, #64]
 295:lib/FreeRTOS/queue.c **** 				pxNewQueue->xRxLock = queueUNLOCKED;
 129              		.loc 1 295 0
 130 0094 BB69     		ldr	r3, [r7, #24]
 131 0096 4FF0FF32 		mov	r2, #-1
 132 009a 5A64     		str	r2, [r3, #68]
 296:lib/FreeRTOS/queue.c **** 				pxNewQueue->xTxLock = queueUNLOCKED;
 133              		.loc 1 296 0
 134 009c BB69     		ldr	r3, [r7, #24]
 135 009e 4FF0FF32 		mov	r2, #-1
 136 00a2 9A64     		str	r2, [r3, #72]
 297:lib/FreeRTOS/queue.c **** 				#if ( configUSE_TRACE_FACILITY == 1 )
 298:lib/FreeRTOS/queue.c **** 				{
 299:lib/FreeRTOS/queue.c **** 					pxNewQueue->ucQueueType = ucQueueType;
 137              		.loc 1 299 0
 138 00a4 BB69     		ldr	r3, [r7, #24]
 139 00a6 FA79     		ldrb	r2, [r7, #7]
 140 00a8 83F84D20 		strb	r2, [r3, #77]
 300:lib/FreeRTOS/queue.c **** 				}
 301:lib/FreeRTOS/queue.c **** 				#endif /* configUSE_TRACE_FACILITY */
 302:lib/FreeRTOS/queue.c **** 
 303:lib/FreeRTOS/queue.c **** 				/* Likewise ensure the event queues start with the correct state. */
 304:lib/FreeRTOS/queue.c **** 				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
 141              		.loc 1 304 0
 142 00ac BB69     		ldr	r3, [r7, #24]
 143 00ae 03F11003 		add	r3, r3, #16
 144 00b2 1846     		mov	r0, r3
 145 00b4 FFF7FEFF 		bl	vListInitialise
 305:lib/FreeRTOS/queue.c **** 				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
 146              		.loc 1 305 0
 147 00b8 BB69     		ldr	r3, [r7, #24]
 148 00ba 03F12403 		add	r3, r3, #36
 149 00be 1846     		mov	r0, r3
 150 00c0 FFF7FEFF 		bl	vListInitialise
 306:lib/FreeRTOS/queue.c **** 
 307:lib/FreeRTOS/queue.c **** 				traceQUEUE_CREATE( pxNewQueue );
 308:lib/FreeRTOS/queue.c **** 				xReturn = pxNewQueue;
 151              		.loc 1 308 0
 152 00c4 BB69     		ldr	r3, [r7, #24]
 153 00c6 FB61     		str	r3, [r7, #28]
 154 00c8 02E0     		b	.L2
 155              	.L3:
 309:lib/FreeRTOS/queue.c **** 			}
 310:lib/FreeRTOS/queue.c **** 			else
 311:lib/FreeRTOS/queue.c **** 			{
 312:lib/FreeRTOS/queue.c **** 				traceQUEUE_CREATE_FAILED( ucQueueType );
 313:lib/FreeRTOS/queue.c **** 				vPortFree( pxNewQueue );
 156              		.loc 1 313 0
 157 00ca B869     		ldr	r0, [r7, #24]
 158 00cc FFF7FEFF 		bl	vPortFree
 159              	.L2:
 314:lib/FreeRTOS/queue.c **** 			}
 315:lib/FreeRTOS/queue.c **** 		}
 316:lib/FreeRTOS/queue.c **** 	}
 317:lib/FreeRTOS/queue.c **** 
 318:lib/FreeRTOS/queue.c **** 	configASSERT( xReturn );
 160              		.loc 1 318 0
 161 00d0 FB69     		ldr	r3, [r7, #28]
 162 00d2 002B     		cmp	r3, #0
 163 00d4 04D1     		bne	.L4
 164              		.loc 1 318 0 is_stmt 0 discriminator 1
 165              	@ 318 "lib/FreeRTOS/queue.c" 1
 166 00d6 4FF0BF00 			mov r0, #191								
 167 00da 80F31188 		msr basepri, r0							
 168              	
 169              	@ 0 "" 2
 170              		.thumb
 171              	.L5:
 172              		.loc 1 318 0 discriminator 2
 173 00de FEE7     		b	.L5
 174              	.L4:
 319:lib/FreeRTOS/queue.c **** 
 320:lib/FreeRTOS/queue.c **** 	return xReturn;
 175              		.loc 1 320 0 is_stmt 1
 176 00e0 FB69     		ldr	r3, [r7, #28]
 321:lib/FreeRTOS/queue.c **** }
 177              		.loc 1 321 0
 178 00e2 1846     		mov	r0, r3
 179 00e4 07F12007 		add	r7, r7, #32
 180 00e8 BD46     		mov	sp, r7
 181 00ea 80BD     		pop	{r7, pc}
 182              		.cfi_endproc
 183              	.LFE110:
 185              		.section	.text.xQueueCreateMutex,"ax",%progbits
 186              		.align	2
 187              		.global	xQueueCreateMutex
 188              		.thumb
 189              		.thumb_func
 191              	xQueueCreateMutex:
 192              	.LFB111:
 322:lib/FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
 323:lib/FreeRTOS/queue.c **** 
 324:lib/FreeRTOS/queue.c **** #if ( configUSE_MUTEXES == 1 )
 325:lib/FreeRTOS/queue.c **** 
 326:lib/FreeRTOS/queue.c **** 	xQueueHandle xQueueCreateMutex( unsigned char ucQueueType )
 327:lib/FreeRTOS/queue.c **** 	{
 193              		.loc 1 327 0
 194              		.cfi_startproc
 195              		@ args = 0, pretend = 0, frame = 16
 196              		@ frame_needed = 1, uses_anonymous_args = 0
 197 0000 80B5     		push	{r7, lr}
 198              	.LCFI3:
 199              		.cfi_def_cfa_offset 8
 200 0002 84B0     		sub	sp, sp, #16
 201              	.LCFI4:
 202              		.cfi_def_cfa_offset 24
 203 0004 00AF     		add	r7, sp, #0
 204              		.cfi_offset 14, -4
 205              		.cfi_offset 7, -8
 206              	.LCFI5:
 207              		.cfi_def_cfa_register 7
 208 0006 0346     		mov	r3, r0
 209 0008 FB71     		strb	r3, [r7, #7]
 328:lib/FreeRTOS/queue.c **** 	xQUEUE *pxNewQueue;
 329:lib/FreeRTOS/queue.c **** 
 330:lib/FreeRTOS/queue.c **** 		/* Prevent compiler warnings about unused parameters if
 331:lib/FreeRTOS/queue.c **** 		configUSE_TRACE_FACILITY does not equal 1. */
 332:lib/FreeRTOS/queue.c **** 		( void ) ucQueueType;
 333:lib/FreeRTOS/queue.c **** 	
 334:lib/FreeRTOS/queue.c **** 		/* Allocate the new queue structure. */
 335:lib/FreeRTOS/queue.c **** 		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
 210              		.loc 1 335 0
 211 000a 4FF05000 		mov	r0, #80
 212 000e FFF7FEFF 		bl	pvPortMalloc
 213 0012 0346     		mov	r3, r0
 214 0014 FB60     		str	r3, [r7, #12]
 336:lib/FreeRTOS/queue.c **** 		if( pxNewQueue != NULL )
 215              		.loc 1 336 0
 216 0016 FB68     		ldr	r3, [r7, #12]
 217 0018 002B     		cmp	r3, #0
 218 001a 3CD0     		beq	.L7
 337:lib/FreeRTOS/queue.c **** 		{
 338:lib/FreeRTOS/queue.c **** 			/* Information required for priority inheritance. */
 339:lib/FreeRTOS/queue.c **** 			pxNewQueue->pxMutexHolder = NULL;
 219              		.loc 1 339 0
 220 001c FB68     		ldr	r3, [r7, #12]
 221 001e 4FF00002 		mov	r2, #0
 222 0022 5A60     		str	r2, [r3, #4]
 340:lib/FreeRTOS/queue.c **** 			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
 223              		.loc 1 340 0
 224 0024 FB68     		ldr	r3, [r7, #12]
 225 0026 4FF00002 		mov	r2, #0
 226 002a 1A60     		str	r2, [r3, #0]
 341:lib/FreeRTOS/queue.c **** 
 342:lib/FreeRTOS/queue.c **** 			/* Queues used as a mutex no data is actually copied into or out
 343:lib/FreeRTOS/queue.c **** 			of the queue. */
 344:lib/FreeRTOS/queue.c **** 			pxNewQueue->pcWriteTo = NULL;
 227              		.loc 1 344 0
 228 002c FB68     		ldr	r3, [r7, #12]
 229 002e 4FF00002 		mov	r2, #0
 230 0032 9A60     		str	r2, [r3, #8]
 345:lib/FreeRTOS/queue.c **** 			pxNewQueue->pcReadFrom = NULL;
 231              		.loc 1 345 0
 232 0034 FB68     		ldr	r3, [r7, #12]
 233 0036 4FF00002 		mov	r2, #0
 234 003a DA60     		str	r2, [r3, #12]
 346:lib/FreeRTOS/queue.c **** 
 347:lib/FreeRTOS/queue.c **** 			/* Each mutex has a length of 1 (like a binary semaphore) and
 348:lib/FreeRTOS/queue.c **** 			an item size of 0 as nothing is actually copied into or out
 349:lib/FreeRTOS/queue.c **** 			of the mutex. */
 350:lib/FreeRTOS/queue.c **** 			pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
 235              		.loc 1 350 0
 236 003c FB68     		ldr	r3, [r7, #12]
 237 003e 4FF00002 		mov	r2, #0
 238 0042 9A63     		str	r2, [r3, #56]
 351:lib/FreeRTOS/queue.c **** 			pxNewQueue->uxLength = ( unsigned portBASE_TYPE ) 1U;
 239              		.loc 1 351 0
 240 0044 FB68     		ldr	r3, [r7, #12]
 241 0046 4FF00102 		mov	r2, #1
 242 004a DA63     		str	r2, [r3, #60]
 352:lib/FreeRTOS/queue.c **** 			pxNewQueue->uxItemSize = ( unsigned portBASE_TYPE ) 0U;
 243              		.loc 1 352 0
 244 004c FB68     		ldr	r3, [r7, #12]
 245 004e 4FF00002 		mov	r2, #0
 246 0052 1A64     		str	r2, [r3, #64]
 353:lib/FreeRTOS/queue.c **** 			pxNewQueue->xRxLock = queueUNLOCKED;
 247              		.loc 1 353 0
 248 0054 FB68     		ldr	r3, [r7, #12]
 249 0056 4FF0FF32 		mov	r2, #-1
 250 005a 5A64     		str	r2, [r3, #68]
 354:lib/FreeRTOS/queue.c **** 			pxNewQueue->xTxLock = queueUNLOCKED;
 251              		.loc 1 354 0
 252 005c FB68     		ldr	r3, [r7, #12]
 253 005e 4FF0FF32 		mov	r2, #-1
 254 0062 9A64     		str	r2, [r3, #72]
 355:lib/FreeRTOS/queue.c **** 			
 356:lib/FreeRTOS/queue.c **** 			#if ( configUSE_TRACE_FACILITY == 1 )
 357:lib/FreeRTOS/queue.c **** 			{
 358:lib/FreeRTOS/queue.c **** 				pxNewQueue->ucQueueType = ucQueueType;
 255              		.loc 1 358 0
 256 0064 FB68     		ldr	r3, [r7, #12]
 257 0066 FA79     		ldrb	r2, [r7, #7]
 258 0068 83F84D20 		strb	r2, [r3, #77]
 359:lib/FreeRTOS/queue.c **** 			}
 360:lib/FreeRTOS/queue.c **** 			#endif
 361:lib/FreeRTOS/queue.c **** 
 362:lib/FreeRTOS/queue.c **** 			/* Ensure the event queues start with the correct state. */
 363:lib/FreeRTOS/queue.c **** 			vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
 259              		.loc 1 363 0
 260 006c FB68     		ldr	r3, [r7, #12]
 261 006e 03F11003 		add	r3, r3, #16
 262 0072 1846     		mov	r0, r3
 263 0074 FFF7FEFF 		bl	vListInitialise
 364:lib/FreeRTOS/queue.c **** 			vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
 264              		.loc 1 364 0
 265 0078 FB68     		ldr	r3, [r7, #12]
 266 007a 03F12403 		add	r3, r3, #36
 267 007e 1846     		mov	r0, r3
 268 0080 FFF7FEFF 		bl	vListInitialise
 365:lib/FreeRTOS/queue.c **** 
 366:lib/FreeRTOS/queue.c **** 			traceCREATE_MUTEX( pxNewQueue );
 367:lib/FreeRTOS/queue.c **** 
 368:lib/FreeRTOS/queue.c **** 			/* Start with the semaphore in the expected state. */
 369:lib/FreeRTOS/queue.c **** 			xQueueGenericSend( pxNewQueue, NULL, ( portTickType ) 0U, queueSEND_TO_BACK );
 269              		.loc 1 369 0
 270 0084 F868     		ldr	r0, [r7, #12]
 271 0086 4FF00001 		mov	r1, #0
 272 008a 4FF00002 		mov	r2, #0
 273 008e 4FF00003 		mov	r3, #0
 274 0092 FFF7FEFF 		bl	xQueueGenericSend
 275              	.L7:
 370:lib/FreeRTOS/queue.c **** 		}
 371:lib/FreeRTOS/queue.c **** 		else
 372:lib/FreeRTOS/queue.c **** 		{
 373:lib/FreeRTOS/queue.c **** 			traceCREATE_MUTEX_FAILED();
 374:lib/FreeRTOS/queue.c **** 		}
 375:lib/FreeRTOS/queue.c **** 
 376:lib/FreeRTOS/queue.c **** 		configASSERT( pxNewQueue );
 276              		.loc 1 376 0
 277 0096 FB68     		ldr	r3, [r7, #12]
 278 0098 002B     		cmp	r3, #0
 279 009a 04D1     		bne	.L8
 280              		.loc 1 376 0 is_stmt 0 discriminator 1
 281              	@ 376 "lib/FreeRTOS/queue.c" 1
 282 009c 4FF0BF00 			mov r0, #191								
 283 00a0 80F31188 		msr basepri, r0							
 284              	
 285              	@ 0 "" 2
 286              		.thumb
 287              	.L9:
 288              		.loc 1 376 0 discriminator 2
 289 00a4 FEE7     		b	.L9
 290              	.L8:
 377:lib/FreeRTOS/queue.c **** 		return pxNewQueue;
 291              		.loc 1 377 0 is_stmt 1
 292 00a6 FB68     		ldr	r3, [r7, #12]
 378:lib/FreeRTOS/queue.c **** 	}
 293              		.loc 1 378 0
 294 00a8 1846     		mov	r0, r3
 295 00aa 07F11007 		add	r7, r7, #16
 296 00ae BD46     		mov	sp, r7
 297 00b0 80BD     		pop	{r7, pc}
 298              		.cfi_endproc
 299              	.LFE111:
 301 00b2 00BF     		.section	.text.xQueueGiveMutexRecursive,"ax",%progbits
 302              		.align	2
 303              		.global	xQueueGiveMutexRecursive
 304              		.thumb
 305              		.thumb_func
 307              	xQueueGiveMutexRecursive:
 308              	.LFB112:
 379:lib/FreeRTOS/queue.c **** 
 380:lib/FreeRTOS/queue.c **** #endif /* configUSE_MUTEXES */
 381:lib/FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
 382:lib/FreeRTOS/queue.c **** 
 383:lib/FreeRTOS/queue.c **** #if configUSE_RECURSIVE_MUTEXES == 1
 384:lib/FreeRTOS/queue.c **** 
 385:lib/FreeRTOS/queue.c **** 	portBASE_TYPE xQueueGiveMutexRecursive( xQueueHandle pxMutex )
 386:lib/FreeRTOS/queue.c **** 	{
 309              		.loc 1 386 0
 310              		.cfi_startproc
 311              		@ args = 0, pretend = 0, frame = 16
 312              		@ frame_needed = 1, uses_anonymous_args = 0
 313 0000 90B5     		push	{r4, r7, lr}
 314              	.LCFI6:
 315              		.cfi_def_cfa_offset 12
 316 0002 85B0     		sub	sp, sp, #20
 317              	.LCFI7:
 318              		.cfi_def_cfa_offset 32
 319 0004 00AF     		add	r7, sp, #0
 320              		.cfi_offset 14, -4
 321              		.cfi_offset 7, -8
 322              		.cfi_offset 4, -12
 323              	.LCFI8:
 324              		.cfi_def_cfa_register 7
 325 0006 7860     		str	r0, [r7, #4]
 387:lib/FreeRTOS/queue.c **** 	portBASE_TYPE xReturn;
 388:lib/FreeRTOS/queue.c **** 
 389:lib/FreeRTOS/queue.c **** 		configASSERT( pxMutex );
 326              		.loc 1 389 0
 327 0008 7B68     		ldr	r3, [r7, #4]
 328 000a 002B     		cmp	r3, #0
 329 000c 04D1     		bne	.L11
 330              		.loc 1 389 0 is_stmt 0 discriminator 1
 331              	@ 389 "lib/FreeRTOS/queue.c" 1
 332 000e 4FF0BF00 			mov r0, #191								
 333 0012 80F31188 		msr basepri, r0							
 334              	
 335              	@ 0 "" 2
 336              		.thumb
 337              	.L12:
 338              		.loc 1 389 0 discriminator 2
 339 0016 FEE7     		b	.L12
 340              	.L11:
 390:lib/FreeRTOS/queue.c **** 
 391:lib/FreeRTOS/queue.c **** 		/* If this is the task that holds the mutex then pxMutexHolder will not
 392:lib/FreeRTOS/queue.c **** 		change outside of this task.  If this task does not hold the mutex then
 393:lib/FreeRTOS/queue.c **** 		pxMutexHolder can never coincidentally equal the tasks handle, and as
 394:lib/FreeRTOS/queue.c **** 		this is the only condition we are interested in it does not matter if
 395:lib/FreeRTOS/queue.c **** 		pxMutexHolder is accessed simultaneously by another task.  Therefore no
 396:lib/FreeRTOS/queue.c **** 		mutual exclusion is required to test the pxMutexHolder variable. */
 397:lib/FreeRTOS/queue.c **** 		if( pxMutex->pxMutexHolder == xTaskGetCurrentTaskHandle() )
 341              		.loc 1 397 0 is_stmt 1
 342 0018 7B68     		ldr	r3, [r7, #4]
 343 001a 5C68     		ldr	r4, [r3, #4]
 344 001c FFF7FEFF 		bl	xTaskGetCurrentTaskHandle
 345 0020 0346     		mov	r3, r0
 346 0022 9C42     		cmp	r4, r3
 347 0024 16D1     		bne	.L13
 398:lib/FreeRTOS/queue.c **** 		{
 399:lib/FreeRTOS/queue.c **** 			traceGIVE_MUTEX_RECURSIVE( pxMutex );
 400:lib/FreeRTOS/queue.c **** 
 401:lib/FreeRTOS/queue.c **** 			/* uxRecursiveCallCount cannot be zero if pxMutexHolder is equal to
 402:lib/FreeRTOS/queue.c **** 			the task handle, therefore no underflow check is required.  Also,
 403:lib/FreeRTOS/queue.c **** 			uxRecursiveCallCount is only modified by the mutex holder, and as
 404:lib/FreeRTOS/queue.c **** 			there can only be one, no mutual exclusion is required to modify the
 405:lib/FreeRTOS/queue.c **** 			uxRecursiveCallCount member. */
 406:lib/FreeRTOS/queue.c **** 			( pxMutex->uxRecursiveCallCount )--;
 348              		.loc 1 406 0
 349 0026 7B68     		ldr	r3, [r7, #4]
 350 0028 DB68     		ldr	r3, [r3, #12]
 351 002a 03F1FF32 		add	r2, r3, #-1
 352 002e 7B68     		ldr	r3, [r7, #4]
 353 0030 DA60     		str	r2, [r3, #12]
 407:lib/FreeRTOS/queue.c **** 
 408:lib/FreeRTOS/queue.c **** 			/* Have we unwound the call count? */
 409:lib/FreeRTOS/queue.c **** 			if( pxMutex->uxRecursiveCallCount == 0 )
 354              		.loc 1 409 0
 355 0032 7B68     		ldr	r3, [r7, #4]
 356 0034 DB68     		ldr	r3, [r3, #12]
 357 0036 002B     		cmp	r3, #0
 358 0038 08D1     		bne	.L14
 410:lib/FreeRTOS/queue.c **** 			{
 411:lib/FreeRTOS/queue.c **** 				/* Return the mutex.  This will automatically unblock any other
 412:lib/FreeRTOS/queue.c **** 				task that might be waiting to access the mutex. */
 413:lib/FreeRTOS/queue.c **** 				xQueueGenericSend( pxMutex, NULL, queueMUTEX_GIVE_BLOCK_TIME, queueSEND_TO_BACK );
 359              		.loc 1 413 0
 360 003a 7868     		ldr	r0, [r7, #4]
 361 003c 4FF00001 		mov	r1, #0
 362 0040 4FF00002 		mov	r2, #0
 363 0044 4FF00003 		mov	r3, #0
 364 0048 FFF7FEFF 		bl	xQueueGenericSend
 365              	.L14:
 414:lib/FreeRTOS/queue.c **** 			}
 415:lib/FreeRTOS/queue.c **** 
 416:lib/FreeRTOS/queue.c **** 			xReturn = pdPASS;
 366              		.loc 1 416 0
 367 004c 4FF00103 		mov	r3, #1
 368 0050 FB60     		str	r3, [r7, #12]
 369 0052 02E0     		b	.L15
 370              	.L13:
 417:lib/FreeRTOS/queue.c **** 		}
 418:lib/FreeRTOS/queue.c **** 		else
 419:lib/FreeRTOS/queue.c **** 		{
 420:lib/FreeRTOS/queue.c **** 			/* We cannot give the mutex because we are not the holder. */
 421:lib/FreeRTOS/queue.c **** 			xReturn = pdFAIL;
 371              		.loc 1 421 0
 372 0054 4FF00003 		mov	r3, #0
 373 0058 FB60     		str	r3, [r7, #12]
 374              	.L15:
 422:lib/FreeRTOS/queue.c **** 
 423:lib/FreeRTOS/queue.c **** 			traceGIVE_MUTEX_RECURSIVE_FAILED( pxMutex );
 424:lib/FreeRTOS/queue.c **** 		}
 425:lib/FreeRTOS/queue.c **** 
 426:lib/FreeRTOS/queue.c **** 		return xReturn;
 375              		.loc 1 426 0
 376 005a FB68     		ldr	r3, [r7, #12]
 427:lib/FreeRTOS/queue.c **** 	}
 377              		.loc 1 427 0
 378 005c 1846     		mov	r0, r3
 379 005e 07F11407 		add	r7, r7, #20
 380 0062 BD46     		mov	sp, r7
 381 0064 90BD     		pop	{r4, r7, pc}
 382              		.cfi_endproc
 383              	.LFE112:
 385 0066 00BF     		.section	.text.xQueueTakeMutexRecursive,"ax",%progbits
 386              		.align	2
 387              		.global	xQueueTakeMutexRecursive
 388              		.thumb
 389              		.thumb_func
 391              	xQueueTakeMutexRecursive:
 392              	.LFB113:
 428:lib/FreeRTOS/queue.c **** 
 429:lib/FreeRTOS/queue.c **** #endif /* configUSE_RECURSIVE_MUTEXES */
 430:lib/FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
 431:lib/FreeRTOS/queue.c **** 
 432:lib/FreeRTOS/queue.c **** #if configUSE_RECURSIVE_MUTEXES == 1
 433:lib/FreeRTOS/queue.c **** 
 434:lib/FreeRTOS/queue.c **** 	portBASE_TYPE xQueueTakeMutexRecursive( xQueueHandle pxMutex, portTickType xBlockTime )
 435:lib/FreeRTOS/queue.c **** 	{
 393              		.loc 1 435 0
 394              		.cfi_startproc
 395              		@ args = 0, pretend = 0, frame = 16
 396              		@ frame_needed = 1, uses_anonymous_args = 0
 397 0000 90B5     		push	{r4, r7, lr}
 398              	.LCFI9:
 399              		.cfi_def_cfa_offset 12
 400 0002 85B0     		sub	sp, sp, #20
 401              	.LCFI10:
 402              		.cfi_def_cfa_offset 32
 403 0004 00AF     		add	r7, sp, #0
 404              		.cfi_offset 14, -4
 405              		.cfi_offset 7, -8
 406              		.cfi_offset 4, -12
 407              	.LCFI11:
 408              		.cfi_def_cfa_register 7
 409 0006 7860     		str	r0, [r7, #4]
 410 0008 3960     		str	r1, [r7, #0]
 436:lib/FreeRTOS/queue.c **** 	portBASE_TYPE xReturn;
 437:lib/FreeRTOS/queue.c **** 
 438:lib/FreeRTOS/queue.c **** 		configASSERT( pxMutex );
 411              		.loc 1 438 0
 412 000a 7B68     		ldr	r3, [r7, #4]
 413 000c 002B     		cmp	r3, #0
 414 000e 04D1     		bne	.L17
 415              		.loc 1 438 0 is_stmt 0 discriminator 1
 416              	@ 438 "lib/FreeRTOS/queue.c" 1
 417 0010 4FF0BF00 			mov r0, #191								
 418 0014 80F31188 		msr basepri, r0							
 419              	
 420              	@ 0 "" 2
 421              		.thumb
 422              	.L18:
 423              		.loc 1 438 0 discriminator 2
 424 0018 FEE7     		b	.L18
 425              	.L17:
 439:lib/FreeRTOS/queue.c **** 
 440:lib/FreeRTOS/queue.c **** 		/* Comments regarding mutual exclusion as per those within
 441:lib/FreeRTOS/queue.c **** 		xQueueGiveMutexRecursive(). */
 442:lib/FreeRTOS/queue.c **** 
 443:lib/FreeRTOS/queue.c **** 		traceTAKE_MUTEX_RECURSIVE( pxMutex );
 444:lib/FreeRTOS/queue.c **** 
 445:lib/FreeRTOS/queue.c **** 		if( pxMutex->pxMutexHolder == xTaskGetCurrentTaskHandle() )
 426              		.loc 1 445 0 is_stmt 1
 427 001a 7B68     		ldr	r3, [r7, #4]
 428 001c 5C68     		ldr	r4, [r3, #4]
 429 001e FFF7FEFF 		bl	xTaskGetCurrentTaskHandle
 430 0022 0346     		mov	r3, r0
 431 0024 9C42     		cmp	r4, r3
 432 0026 09D1     		bne	.L19
 446:lib/FreeRTOS/queue.c **** 		{
 447:lib/FreeRTOS/queue.c **** 			( pxMutex->uxRecursiveCallCount )++;
 433              		.loc 1 447 0
 434 0028 7B68     		ldr	r3, [r7, #4]
 435 002a DB68     		ldr	r3, [r3, #12]
 436 002c 03F10102 		add	r2, r3, #1
 437 0030 7B68     		ldr	r3, [r7, #4]
 438 0032 DA60     		str	r2, [r3, #12]
 448:lib/FreeRTOS/queue.c **** 			xReturn = pdPASS;
 439              		.loc 1 448 0
 440 0034 4FF00103 		mov	r3, #1
 441 0038 FB60     		str	r3, [r7, #12]
 442 003a 11E0     		b	.L20
 443              	.L19:
 449:lib/FreeRTOS/queue.c **** 		}
 450:lib/FreeRTOS/queue.c **** 		else
 451:lib/FreeRTOS/queue.c **** 		{
 452:lib/FreeRTOS/queue.c **** 			xReturn = xQueueGenericReceive( pxMutex, NULL, xBlockTime, pdFALSE );
 444              		.loc 1 452 0
 445 003c 7868     		ldr	r0, [r7, #4]
 446 003e 4FF00001 		mov	r1, #0
 447 0042 3A68     		ldr	r2, [r7, #0]
 448 0044 4FF00003 		mov	r3, #0
 449 0048 FFF7FEFF 		bl	xQueueGenericReceive
 450 004c F860     		str	r0, [r7, #12]
 453:lib/FreeRTOS/queue.c **** 
 454:lib/FreeRTOS/queue.c **** 			/* pdPASS will only be returned if we successfully obtained the mutex,
 455:lib/FreeRTOS/queue.c **** 			we may have blocked to reach here. */
 456:lib/FreeRTOS/queue.c **** 			if( xReturn == pdPASS )
 451              		.loc 1 456 0
 452 004e FB68     		ldr	r3, [r7, #12]
 453 0050 012B     		cmp	r3, #1
 454 0052 05D1     		bne	.L20
 457:lib/FreeRTOS/queue.c **** 			{
 458:lib/FreeRTOS/queue.c **** 				( pxMutex->uxRecursiveCallCount )++;
 455              		.loc 1 458 0
 456 0054 7B68     		ldr	r3, [r7, #4]
 457 0056 DB68     		ldr	r3, [r3, #12]
 458 0058 03F10102 		add	r2, r3, #1
 459 005c 7B68     		ldr	r3, [r7, #4]
 460 005e DA60     		str	r2, [r3, #12]
 461              	.L20:
 459:lib/FreeRTOS/queue.c **** 			}
 460:lib/FreeRTOS/queue.c **** 			else
 461:lib/FreeRTOS/queue.c **** 			{
 462:lib/FreeRTOS/queue.c **** 				traceTAKE_MUTEX_RECURSIVE_FAILED( pxMutex );
 463:lib/FreeRTOS/queue.c **** 			}
 464:lib/FreeRTOS/queue.c **** 		}
 465:lib/FreeRTOS/queue.c **** 
 466:lib/FreeRTOS/queue.c **** 		return xReturn;
 462              		.loc 1 466 0
 463 0060 FB68     		ldr	r3, [r7, #12]
 467:lib/FreeRTOS/queue.c **** 	}
 464              		.loc 1 467 0
 465 0062 1846     		mov	r0, r3
 466 0064 07F11407 		add	r7, r7, #20
 467 0068 BD46     		mov	sp, r7
 468 006a 90BD     		pop	{r4, r7, pc}
 469              		.cfi_endproc
 470              	.LFE113:
 472              		.section	.text.xQueueCreateCountingSemaphore,"ax",%progbits
 473              		.align	2
 474              		.global	xQueueCreateCountingSemaphore
 475              		.thumb
 476              		.thumb_func
 478              	xQueueCreateCountingSemaphore:
 479              	.LFB114:
 468:lib/FreeRTOS/queue.c **** 
 469:lib/FreeRTOS/queue.c **** #endif /* configUSE_RECURSIVE_MUTEXES */
 470:lib/FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
 471:lib/FreeRTOS/queue.c **** 
 472:lib/FreeRTOS/queue.c **** #if configUSE_COUNTING_SEMAPHORES == 1
 473:lib/FreeRTOS/queue.c **** 
 474:lib/FreeRTOS/queue.c **** 	xQueueHandle xQueueCreateCountingSemaphore( unsigned portBASE_TYPE uxCountValue, unsigned portBASE
 475:lib/FreeRTOS/queue.c **** 	{
 480              		.loc 1 475 0
 481              		.cfi_startproc
 482              		@ args = 0, pretend = 0, frame = 16
 483              		@ frame_needed = 1, uses_anonymous_args = 0
 484 0000 80B5     		push	{r7, lr}
 485              	.LCFI12:
 486              		.cfi_def_cfa_offset 8
 487 0002 84B0     		sub	sp, sp, #16
 488              	.LCFI13:
 489              		.cfi_def_cfa_offset 24
 490 0004 00AF     		add	r7, sp, #0
 491              		.cfi_offset 14, -4
 492              		.cfi_offset 7, -8
 493              	.LCFI14:
 494              		.cfi_def_cfa_register 7
 495 0006 7860     		str	r0, [r7, #4]
 496 0008 3960     		str	r1, [r7, #0]
 476:lib/FreeRTOS/queue.c **** 	xQueueHandle pxHandle;
 477:lib/FreeRTOS/queue.c **** 
 478:lib/FreeRTOS/queue.c **** 		pxHandle = xQueueGenericCreate( ( unsigned portBASE_TYPE ) uxCountValue, queueSEMAPHORE_QUEUE_ITE
 497              		.loc 1 478 0
 498 000a 7868     		ldr	r0, [r7, #4]
 499 000c 4FF00001 		mov	r1, #0
 500 0010 4FF00202 		mov	r2, #2
 501 0014 FFF7FEFF 		bl	xQueueGenericCreate
 502 0018 F860     		str	r0, [r7, #12]
 479:lib/FreeRTOS/queue.c **** 
 480:lib/FreeRTOS/queue.c **** 		if( pxHandle != NULL )
 503              		.loc 1 480 0
 504 001a FB68     		ldr	r3, [r7, #12]
 505 001c 002B     		cmp	r3, #0
 506 001e 02D0     		beq	.L22
 481:lib/FreeRTOS/queue.c **** 		{
 482:lib/FreeRTOS/queue.c **** 			pxHandle->uxMessagesWaiting = uxInitialCount;
 507              		.loc 1 482 0
 508 0020 FB68     		ldr	r3, [r7, #12]
 509 0022 3A68     		ldr	r2, [r7, #0]
 510 0024 9A63     		str	r2, [r3, #56]
 511              	.L22:
 483:lib/FreeRTOS/queue.c **** 
 484:lib/FreeRTOS/queue.c **** 			traceCREATE_COUNTING_SEMAPHORE();
 485:lib/FreeRTOS/queue.c **** 		}
 486:lib/FreeRTOS/queue.c **** 		else
 487:lib/FreeRTOS/queue.c **** 		{
 488:lib/FreeRTOS/queue.c **** 			traceCREATE_COUNTING_SEMAPHORE_FAILED();
 489:lib/FreeRTOS/queue.c **** 		}
 490:lib/FreeRTOS/queue.c **** 
 491:lib/FreeRTOS/queue.c **** 		configASSERT( pxHandle );
 512              		.loc 1 491 0
 513 0026 FB68     		ldr	r3, [r7, #12]
 514 0028 002B     		cmp	r3, #0
 515 002a 04D1     		bne	.L23
 516              		.loc 1 491 0 is_stmt 0 discriminator 1
 517              	@ 491 "lib/FreeRTOS/queue.c" 1
 518 002c 4FF0BF00 			mov r0, #191								
 519 0030 80F31188 		msr basepri, r0							
 520              	
 521              	@ 0 "" 2
 522              		.thumb
 523              	.L24:
 524              		.loc 1 491 0 discriminator 2
 525 0034 FEE7     		b	.L24
 526              	.L23:
 492:lib/FreeRTOS/queue.c **** 		return pxHandle;
 527              		.loc 1 492 0 is_stmt 1
 528 0036 FB68     		ldr	r3, [r7, #12]
 493:lib/FreeRTOS/queue.c **** 	}
 529              		.loc 1 493 0
 530 0038 1846     		mov	r0, r3
 531 003a 07F11007 		add	r7, r7, #16
 532 003e BD46     		mov	sp, r7
 533 0040 80BD     		pop	{r7, pc}
 534              		.cfi_endproc
 535              	.LFE114:
 537 0042 00BF     		.section	.text.xQueueGenericSend,"ax",%progbits
 538              		.align	2
 539              		.global	xQueueGenericSend
 540              		.thumb
 541              		.thumb_func
 543              	xQueueGenericSend:
 544              	.LFB115:
 494:lib/FreeRTOS/queue.c **** 
 495:lib/FreeRTOS/queue.c **** #endif /* configUSE_COUNTING_SEMAPHORES */
 496:lib/FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
 497:lib/FreeRTOS/queue.c **** 
 498:lib/FreeRTOS/queue.c **** signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, por
 499:lib/FreeRTOS/queue.c **** {
 545              		.loc 1 499 0
 546              		.cfi_startproc
 547              		@ args = 0, pretend = 0, frame = 32
 548              		@ frame_needed = 1, uses_anonymous_args = 0
 549 0000 80B5     		push	{r7, lr}
 550              	.LCFI15:
 551              		.cfi_def_cfa_offset 8
 552 0002 88B0     		sub	sp, sp, #32
 553              	.LCFI16:
 554              		.cfi_def_cfa_offset 40
 555 0004 00AF     		add	r7, sp, #0
 556              		.cfi_offset 14, -4
 557              		.cfi_offset 7, -8
 558              	.LCFI17:
 559              		.cfi_def_cfa_register 7
 560 0006 F860     		str	r0, [r7, #12]
 561 0008 B960     		str	r1, [r7, #8]
 562 000a 7A60     		str	r2, [r7, #4]
 563 000c 3B60     		str	r3, [r7, #0]
 500:lib/FreeRTOS/queue.c **** signed portBASE_TYPE xEntryTimeSet = pdFALSE;
 564              		.loc 1 500 0
 565 000e 4FF00003 		mov	r3, #0
 566 0012 FB61     		str	r3, [r7, #28]
 501:lib/FreeRTOS/queue.c **** xTimeOutType xTimeOut;
 502:lib/FreeRTOS/queue.c **** 
 503:lib/FreeRTOS/queue.c **** 	configASSERT( pxQueue );
 567              		.loc 1 503 0
 568 0014 FB68     		ldr	r3, [r7, #12]
 569 0016 002B     		cmp	r3, #0
 570 0018 04D1     		bne	.L26
 571              		.loc 1 503 0 is_stmt 0 discriminator 1
 572              	@ 503 "lib/FreeRTOS/queue.c" 1
 573 001a 4FF0BF00 			mov r0, #191								
 574 001e 80F31188 		msr basepri, r0							
 575              	
 576              	@ 0 "" 2
 577              		.thumb
 578              	.L27:
 579              		.loc 1 503 0 discriminator 2
 580 0022 FEE7     		b	.L27
 581              	.L26:
 504:lib/FreeRTOS/queue.c **** 	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 
 582              		.loc 1 504 0 is_stmt 1
 583 0024 BB68     		ldr	r3, [r7, #8]
 584 0026 002B     		cmp	r3, #0
 585 0028 03D1     		bne	.L28
 586              		.loc 1 504 0 is_stmt 0 discriminator 2
 587 002a FB68     		ldr	r3, [r7, #12]
 588 002c 1B6C     		ldr	r3, [r3, #64]
 589 002e 002B     		cmp	r3, #0
 590 0030 02D1     		bne	.L29
 591              	.L28:
 592              		.loc 1 504 0 discriminator 1
 593 0032 4FF00103 		mov	r3, #1
 594 0036 01E0     		b	.L30
 595              	.L29:
 596              		.loc 1 504 0 discriminator 3
 597 0038 4FF00003 		mov	r3, #0
 598              	.L30:
 599              		.loc 1 504 0 discriminator 4
 600 003c 002B     		cmp	r3, #0
 601 003e 05D1     		bne	.L31
 602              		.loc 1 504 0 discriminator 5
 603              	@ 504 "lib/FreeRTOS/queue.c" 1
 604 0040 4FF0BF00 			mov r0, #191								
 605 0044 80F31188 		msr basepri, r0							
 606              	
 607              	@ 0 "" 2
 608              		.thumb
 609              	.L32:
 610              		.loc 1 504 0 discriminator 6
 611 0048 FEE7     		b	.L32
 612              	.L43:
 505:lib/FreeRTOS/queue.c **** 
 506:lib/FreeRTOS/queue.c **** 	/* This function relaxes the coding standard somewhat to allow return
 507:lib/FreeRTOS/queue.c **** 	statements within the function itself.  This is done in the interest
 508:lib/FreeRTOS/queue.c **** 	of execution time efficiency. */
 509:lib/FreeRTOS/queue.c **** 	for( ;; )
 510:lib/FreeRTOS/queue.c **** 	{
 511:lib/FreeRTOS/queue.c **** 		taskENTER_CRITICAL();
 512:lib/FreeRTOS/queue.c **** 		{
 513:lib/FreeRTOS/queue.c **** 			/* Is there room on the queue now?  To be running we must be
 514:lib/FreeRTOS/queue.c **** 			the highest priority task wanting to access the queue. */
 515:lib/FreeRTOS/queue.c **** 			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
 516:lib/FreeRTOS/queue.c **** 			{
 517:lib/FreeRTOS/queue.c **** 				traceQUEUE_SEND( pxQueue );
 518:lib/FreeRTOS/queue.c **** 				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 519:lib/FreeRTOS/queue.c **** 
 520:lib/FreeRTOS/queue.c **** 				/* If there was a task waiting for data to arrive on the
 521:lib/FreeRTOS/queue.c **** 				queue then unblock it now. */
 522:lib/FreeRTOS/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 523:lib/FreeRTOS/queue.c **** 				{
 524:lib/FreeRTOS/queue.c **** 					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
 525:lib/FreeRTOS/queue.c **** 					{
 526:lib/FreeRTOS/queue.c **** 						/* The unblocked task has a priority higher than
 527:lib/FreeRTOS/queue.c **** 						our own so yield immediately.  Yes it is ok to do
 528:lib/FreeRTOS/queue.c **** 						this from within the critical section - the kernel
 529:lib/FreeRTOS/queue.c **** 						takes care of that. */
 530:lib/FreeRTOS/queue.c **** 						portYIELD_WITHIN_API();
 531:lib/FreeRTOS/queue.c **** 					}
 532:lib/FreeRTOS/queue.c **** 				}
 533:lib/FreeRTOS/queue.c **** 
 534:lib/FreeRTOS/queue.c **** 				taskEXIT_CRITICAL();
 535:lib/FreeRTOS/queue.c **** 
 536:lib/FreeRTOS/queue.c **** 				/* Return to the original privilege level before exiting the
 537:lib/FreeRTOS/queue.c **** 				function. */
 538:lib/FreeRTOS/queue.c **** 				return pdPASS;
 539:lib/FreeRTOS/queue.c **** 			}
 540:lib/FreeRTOS/queue.c **** 			else
 541:lib/FreeRTOS/queue.c **** 			{
 542:lib/FreeRTOS/queue.c **** 				if( xTicksToWait == ( portTickType ) 0 )
 543:lib/FreeRTOS/queue.c **** 				{
 544:lib/FreeRTOS/queue.c **** 					/* The queue was full and no block time is specified (or
 545:lib/FreeRTOS/queue.c **** 					the block time has expired) so leave now. */
 546:lib/FreeRTOS/queue.c **** 					taskEXIT_CRITICAL();
 547:lib/FreeRTOS/queue.c **** 
 548:lib/FreeRTOS/queue.c **** 					/* Return to the original privilege level before exiting
 549:lib/FreeRTOS/queue.c **** 					the function. */
 550:lib/FreeRTOS/queue.c **** 					traceQUEUE_SEND_FAILED( pxQueue );
 551:lib/FreeRTOS/queue.c **** 					return errQUEUE_FULL;
 552:lib/FreeRTOS/queue.c **** 				}
 553:lib/FreeRTOS/queue.c **** 				else if( xEntryTimeSet == pdFALSE )
 554:lib/FreeRTOS/queue.c **** 				{
 555:lib/FreeRTOS/queue.c **** 					/* The queue was full and a block time was specified so
 556:lib/FreeRTOS/queue.c **** 					configure the timeout structure. */
 557:lib/FreeRTOS/queue.c **** 					vTaskSetTimeOutState( &xTimeOut );
 558:lib/FreeRTOS/queue.c **** 					xEntryTimeSet = pdTRUE;
 559:lib/FreeRTOS/queue.c **** 				}
 560:lib/FreeRTOS/queue.c **** 			}
 561:lib/FreeRTOS/queue.c **** 		}
 562:lib/FreeRTOS/queue.c **** 		taskEXIT_CRITICAL();
 563:lib/FreeRTOS/queue.c **** 
 564:lib/FreeRTOS/queue.c **** 		/* Interrupts and other tasks can send to and receive from the queue
 565:lib/FreeRTOS/queue.c **** 		now the critical section has been exited. */
 566:lib/FreeRTOS/queue.c **** 
 567:lib/FreeRTOS/queue.c **** 		vTaskSuspendAll();
 568:lib/FreeRTOS/queue.c **** 		prvLockQueue( pxQueue );
 569:lib/FreeRTOS/queue.c **** 
 570:lib/FreeRTOS/queue.c **** 		/* Update the timeout state to see if it has expired yet. */
 571:lib/FreeRTOS/queue.c **** 		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 572:lib/FreeRTOS/queue.c **** 		{
 573:lib/FreeRTOS/queue.c **** 			if( prvIsQueueFull( pxQueue ) != pdFALSE )
 574:lib/FreeRTOS/queue.c **** 			{
 575:lib/FreeRTOS/queue.c **** 				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
 576:lib/FreeRTOS/queue.c **** 				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
 577:lib/FreeRTOS/queue.c **** 
 578:lib/FreeRTOS/queue.c **** 				/* Unlocking the queue means queue events can effect the
 579:lib/FreeRTOS/queue.c **** 				event list.  It is possible	that interrupts occurring now
 580:lib/FreeRTOS/queue.c **** 				remove this task from the event	list again - but as the
 581:lib/FreeRTOS/queue.c **** 				scheduler is suspended the task will go onto the pending
 582:lib/FreeRTOS/queue.c **** 				ready last instead of the actual ready list. */
 583:lib/FreeRTOS/queue.c **** 				prvUnlockQueue( pxQueue );
 584:lib/FreeRTOS/queue.c **** 
 585:lib/FreeRTOS/queue.c **** 				/* Resuming the scheduler will move tasks from the pending
 586:lib/FreeRTOS/queue.c **** 				ready list into the ready list - so it is feasible that this
 587:lib/FreeRTOS/queue.c **** 				task is already in a ready list before it yields - in which
 588:lib/FreeRTOS/queue.c **** 				case the yield will not cause a context switch unless there
 589:lib/FreeRTOS/queue.c **** 				is also a higher priority task in the pending ready list. */
 590:lib/FreeRTOS/queue.c **** 				if( xTaskResumeAll() == pdFALSE )
 591:lib/FreeRTOS/queue.c **** 				{
 592:lib/FreeRTOS/queue.c **** 					portYIELD_WITHIN_API();
 593:lib/FreeRTOS/queue.c **** 				}
 594:lib/FreeRTOS/queue.c **** 			}
 595:lib/FreeRTOS/queue.c **** 			else
 596:lib/FreeRTOS/queue.c **** 			{
 597:lib/FreeRTOS/queue.c **** 				/* Try again. */
 598:lib/FreeRTOS/queue.c **** 				prvUnlockQueue( pxQueue );
 599:lib/FreeRTOS/queue.c **** 				( void ) xTaskResumeAll();
 600:lib/FreeRTOS/queue.c **** 			}
 601:lib/FreeRTOS/queue.c **** 		}
 602:lib/FreeRTOS/queue.c **** 		else
 603:lib/FreeRTOS/queue.c **** 		{
 604:lib/FreeRTOS/queue.c **** 			/* The timeout has expired. */
 605:lib/FreeRTOS/queue.c **** 			prvUnlockQueue( pxQueue );
 606:lib/FreeRTOS/queue.c **** 			( void ) xTaskResumeAll();
 607:lib/FreeRTOS/queue.c **** 
 608:lib/FreeRTOS/queue.c **** 			/* Return to the original privilege level before exiting the
 609:lib/FreeRTOS/queue.c **** 			function. */
 610:lib/FreeRTOS/queue.c **** 			traceQUEUE_SEND_FAILED( pxQueue );
 611:lib/FreeRTOS/queue.c **** 			return errQUEUE_FULL;
 612:lib/FreeRTOS/queue.c **** 		}
 613:lib/FreeRTOS/queue.c **** 	}
 613              		.loc 1 613 0 is_stmt 1
 614 004a 00BF     		nop
 615              	.L31:
 511:lib/FreeRTOS/queue.c **** 		taskENTER_CRITICAL();
 616              		.loc 1 511 0
 617 004c FFF7FEFF 		bl	vPortEnterCritical
 515:lib/FreeRTOS/queue.c **** 			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
 618              		.loc 1 515 0
 619 0050 FB68     		ldr	r3, [r7, #12]
 620 0052 9A6B     		ldr	r2, [r3, #56]
 621 0054 FB68     		ldr	r3, [r7, #12]
 622 0056 DB6B     		ldr	r3, [r3, #60]
 623 0058 9A42     		cmp	r2, r3
 624 005a 18D2     		bcs	.L33
 518:lib/FreeRTOS/queue.c **** 				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 625              		.loc 1 518 0
 626 005c F868     		ldr	r0, [r7, #12]
 627 005e B968     		ldr	r1, [r7, #8]
 628 0060 3A68     		ldr	r2, [r7, #0]
 629 0062 FFF7FEFF 		bl	prvCopyDataToQueue
 522:lib/FreeRTOS/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 630              		.loc 1 522 0
 631 0066 FB68     		ldr	r3, [r7, #12]
 632 0068 5B6A     		ldr	r3, [r3, #36]
 633 006a 002B     		cmp	r3, #0
 634 006c 0AD0     		beq	.L34
 524:lib/FreeRTOS/queue.c **** 					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
 635              		.loc 1 524 0
 636 006e FB68     		ldr	r3, [r7, #12]
 637 0070 03F12403 		add	r3, r3, #36
 638 0074 1846     		mov	r0, r3
 639 0076 FFF7FEFF 		bl	xTaskRemoveFromEventList
 640 007a 0346     		mov	r3, r0
 641 007c 012B     		cmp	r3, #1
 642 007e 01D1     		bne	.L34
 530:lib/FreeRTOS/queue.c **** 						portYIELD_WITHIN_API();
 643              		.loc 1 530 0
 644 0080 FFF7FEFF 		bl	vPortYieldFromISR
 645              	.L34:
 534:lib/FreeRTOS/queue.c **** 				taskEXIT_CRITICAL();
 646              		.loc 1 534 0
 647 0084 FFF7FEFF 		bl	vPortExitCritical
 538:lib/FreeRTOS/queue.c **** 				return pdPASS;
 648              		.loc 1 538 0
 649 0088 4FF00103 		mov	r3, #1
 650 008c 5DE0     		b	.L35
 651              	.L33:
 542:lib/FreeRTOS/queue.c **** 				if( xTicksToWait == ( portTickType ) 0 )
 652              		.loc 1 542 0
 653 008e 7B68     		ldr	r3, [r7, #4]
 654 0090 002B     		cmp	r3, #0
 655 0092 04D1     		bne	.L36
 546:lib/FreeRTOS/queue.c **** 					taskEXIT_CRITICAL();
 656              		.loc 1 546 0
 657 0094 FFF7FEFF 		bl	vPortExitCritical
 551:lib/FreeRTOS/queue.c **** 					return errQUEUE_FULL;
 658              		.loc 1 551 0
 659 0098 4FF00003 		mov	r3, #0
 660 009c 55E0     		b	.L35
 661              	.L36:
 553:lib/FreeRTOS/queue.c **** 				else if( xEntryTimeSet == pdFALSE )
 662              		.loc 1 553 0
 663 009e FB69     		ldr	r3, [r7, #28]
 664 00a0 002B     		cmp	r3, #0
 665 00a2 07D1     		bne	.L37
 557:lib/FreeRTOS/queue.c **** 					vTaskSetTimeOutState( &xTimeOut );
 666              		.loc 1 557 0
 667 00a4 07F11403 		add	r3, r7, #20
 668 00a8 1846     		mov	r0, r3
 669 00aa FFF7FEFF 		bl	vTaskSetTimeOutState
 558:lib/FreeRTOS/queue.c **** 					xEntryTimeSet = pdTRUE;
 670              		.loc 1 558 0
 671 00ae 4FF00103 		mov	r3, #1
 672 00b2 FB61     		str	r3, [r7, #28]
 673              	.L37:
 562:lib/FreeRTOS/queue.c **** 		taskEXIT_CRITICAL();
 674              		.loc 1 562 0
 675 00b4 FFF7FEFF 		bl	vPortExitCritical
 567:lib/FreeRTOS/queue.c **** 		vTaskSuspendAll();
 676              		.loc 1 567 0
 677 00b8 FFF7FEFF 		bl	vTaskSuspendAll
 568:lib/FreeRTOS/queue.c **** 		prvLockQueue( pxQueue );
 678              		.loc 1 568 0
 679 00bc FFF7FEFF 		bl	vPortEnterCritical
 680 00c0 FB68     		ldr	r3, [r7, #12]
 681 00c2 5B6C     		ldr	r3, [r3, #68]
 682 00c4 B3F1FF3F 		cmp	r3, #-1
 683 00c8 03D1     		bne	.L38
 568:lib/FreeRTOS/queue.c **** 		prvLockQueue( pxQueue );
 684              		.loc 1 568 0 is_stmt 0 discriminator 1
 685 00ca FB68     		ldr	r3, [r7, #12]
 686 00cc 4FF00002 		mov	r2, #0
 687 00d0 5A64     		str	r2, [r3, #68]
 688              	.L38:
 568:lib/FreeRTOS/queue.c **** 		prvLockQueue( pxQueue );
 689              		.loc 1 568 0 discriminator 2
 690 00d2 FB68     		ldr	r3, [r7, #12]
 691 00d4 9B6C     		ldr	r3, [r3, #72]
 692 00d6 B3F1FF3F 		cmp	r3, #-1
 693 00da 03D1     		bne	.L39
 568:lib/FreeRTOS/queue.c **** 		prvLockQueue( pxQueue );
 694              		.loc 1 568 0 discriminator 3
 695 00dc FB68     		ldr	r3, [r7, #12]
 696 00de 4FF00002 		mov	r2, #0
 697 00e2 9A64     		str	r2, [r3, #72]
 698              	.L39:
 568:lib/FreeRTOS/queue.c **** 		prvLockQueue( pxQueue );
 699              		.loc 1 568 0 discriminator 4
 700 00e4 FFF7FEFF 		bl	vPortExitCritical
 571:lib/FreeRTOS/queue.c **** 		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 701              		.loc 1 571 0 is_stmt 1 discriminator 4
 702 00e8 07F11402 		add	r2, r7, #20
 703 00ec 07F10403 		add	r3, r7, #4
 704 00f0 1046     		mov	r0, r2
 705 00f2 1946     		mov	r1, r3
 706 00f4 FFF7FEFF 		bl	xTaskCheckForTimeOut
 707 00f8 0346     		mov	r3, r0
 708 00fa 002B     		cmp	r3, #0
 709 00fc 1ED1     		bne	.L40
 573:lib/FreeRTOS/queue.c **** 			if( prvIsQueueFull( pxQueue ) != pdFALSE )
 710              		.loc 1 573 0
 711 00fe F868     		ldr	r0, [r7, #12]
 712 0100 FFF7FEFF 		bl	prvIsQueueFull
 713 0104 0346     		mov	r3, r0
 714 0106 002B     		cmp	r3, #0
 715 0108 12D0     		beq	.L41
 576:lib/FreeRTOS/queue.c **** 				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
 716              		.loc 1 576 0
 717 010a FB68     		ldr	r3, [r7, #12]
 718 010c 03F11002 		add	r2, r3, #16
 719 0110 7B68     		ldr	r3, [r7, #4]
 720 0112 1046     		mov	r0, r2
 721 0114 1946     		mov	r1, r3
 722 0116 FFF7FEFF 		bl	vTaskPlaceOnEventList
 583:lib/FreeRTOS/queue.c **** 				prvUnlockQueue( pxQueue );
 723              		.loc 1 583 0
 724 011a F868     		ldr	r0, [r7, #12]
 725 011c FFF7FEFF 		bl	prvUnlockQueue
 590:lib/FreeRTOS/queue.c **** 				if( xTaskResumeAll() == pdFALSE )
 726              		.loc 1 590 0
 727 0120 FFF7FEFF 		bl	xTaskResumeAll
 728 0124 0346     		mov	r3, r0
 729 0126 002B     		cmp	r3, #0
 730 0128 8FD1     		bne	.L43
 592:lib/FreeRTOS/queue.c **** 					portYIELD_WITHIN_API();
 731              		.loc 1 592 0
 732 012a FFF7FEFF 		bl	vPortYieldFromISR
 733              		.loc 1 613 0
 734 012e 8DE7     		b	.L31
 735              	.L41:
 598:lib/FreeRTOS/queue.c **** 				prvUnlockQueue( pxQueue );
 736              		.loc 1 598 0
 737 0130 F868     		ldr	r0, [r7, #12]
 738 0132 FFF7FEFF 		bl	prvUnlockQueue
 599:lib/FreeRTOS/queue.c **** 				( void ) xTaskResumeAll();
 739              		.loc 1 599 0
 740 0136 FFF7FEFF 		bl	xTaskResumeAll
 741              		.loc 1 613 0
 742 013a 87E7     		b	.L31
 743              	.L40:
 605:lib/FreeRTOS/queue.c **** 			prvUnlockQueue( pxQueue );
 744              		.loc 1 605 0
 745 013c F868     		ldr	r0, [r7, #12]
 746 013e FFF7FEFF 		bl	prvUnlockQueue
 606:lib/FreeRTOS/queue.c **** 			( void ) xTaskResumeAll();
 747              		.loc 1 606 0
 748 0142 FFF7FEFF 		bl	xTaskResumeAll
 611:lib/FreeRTOS/queue.c **** 			return errQUEUE_FULL;
 749              		.loc 1 611 0
 750 0146 4FF00003 		mov	r3, #0
 751              	.L35:
 614:lib/FreeRTOS/queue.c **** }
 752              		.loc 1 614 0
 753 014a 1846     		mov	r0, r3
 754 014c 07F12007 		add	r7, r7, #32
 755 0150 BD46     		mov	sp, r7
 756 0152 80BD     		pop	{r7, pc}
 757              		.cfi_endproc
 758              	.LFE115:
 760              		.section	.text.xQueueGenericSendFromISR,"ax",%progbits
 761              		.align	2
 762              		.global	xQueueGenericSendFromISR
 763              		.thumb
 764              		.thumb_func
 766              	xQueueGenericSendFromISR:
 767              	.LFB116:
 615:lib/FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
 616:lib/FreeRTOS/queue.c **** 
 617:lib/FreeRTOS/queue.c **** #if configUSE_ALTERNATIVE_API == 1
 618:lib/FreeRTOS/queue.c **** 
 619:lib/FreeRTOS/queue.c **** 	signed portBASE_TYPE xQueueAltGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue,
 620:lib/FreeRTOS/queue.c **** 	{
 621:lib/FreeRTOS/queue.c **** 	signed portBASE_TYPE xEntryTimeSet = pdFALSE;
 622:lib/FreeRTOS/queue.c **** 	xTimeOutType xTimeOut;
 623:lib/FreeRTOS/queue.c **** 
 624:lib/FreeRTOS/queue.c **** 		configASSERT( pxQueue );
 625:lib/FreeRTOS/queue.c **** 		configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE )
 626:lib/FreeRTOS/queue.c **** 
 627:lib/FreeRTOS/queue.c **** 		for( ;; )
 628:lib/FreeRTOS/queue.c **** 		{
 629:lib/FreeRTOS/queue.c **** 			taskENTER_CRITICAL();
 630:lib/FreeRTOS/queue.c **** 			{
 631:lib/FreeRTOS/queue.c **** 				/* Is there room on the queue now?  To be running we must be
 632:lib/FreeRTOS/queue.c **** 				the highest priority task wanting to access the queue. */
 633:lib/FreeRTOS/queue.c **** 				if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
 634:lib/FreeRTOS/queue.c **** 				{
 635:lib/FreeRTOS/queue.c **** 					traceQUEUE_SEND( pxQueue );
 636:lib/FreeRTOS/queue.c **** 					prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 637:lib/FreeRTOS/queue.c **** 
 638:lib/FreeRTOS/queue.c **** 					/* If there was a task waiting for data to arrive on the
 639:lib/FreeRTOS/queue.c **** 					queue then unblock it now. */
 640:lib/FreeRTOS/queue.c **** 					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 641:lib/FreeRTOS/queue.c **** 					{
 642:lib/FreeRTOS/queue.c **** 						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
 643:lib/FreeRTOS/queue.c **** 						{
 644:lib/FreeRTOS/queue.c **** 							/* The unblocked task has a priority higher than
 645:lib/FreeRTOS/queue.c **** 							our own so yield immediately. */
 646:lib/FreeRTOS/queue.c **** 							portYIELD_WITHIN_API();
 647:lib/FreeRTOS/queue.c **** 						}
 648:lib/FreeRTOS/queue.c **** 					}
 649:lib/FreeRTOS/queue.c **** 
 650:lib/FreeRTOS/queue.c **** 					taskEXIT_CRITICAL();
 651:lib/FreeRTOS/queue.c **** 					return pdPASS;
 652:lib/FreeRTOS/queue.c **** 				}
 653:lib/FreeRTOS/queue.c **** 				else
 654:lib/FreeRTOS/queue.c **** 				{
 655:lib/FreeRTOS/queue.c **** 					if( xTicksToWait == ( portTickType ) 0 )
 656:lib/FreeRTOS/queue.c **** 					{
 657:lib/FreeRTOS/queue.c **** 						taskEXIT_CRITICAL();
 658:lib/FreeRTOS/queue.c **** 						return errQUEUE_FULL;
 659:lib/FreeRTOS/queue.c **** 					}
 660:lib/FreeRTOS/queue.c **** 					else if( xEntryTimeSet == pdFALSE )
 661:lib/FreeRTOS/queue.c **** 					{
 662:lib/FreeRTOS/queue.c **** 						vTaskSetTimeOutState( &xTimeOut );
 663:lib/FreeRTOS/queue.c **** 						xEntryTimeSet = pdTRUE;
 664:lib/FreeRTOS/queue.c **** 					}
 665:lib/FreeRTOS/queue.c **** 				}
 666:lib/FreeRTOS/queue.c **** 			}
 667:lib/FreeRTOS/queue.c **** 			taskEXIT_CRITICAL();
 668:lib/FreeRTOS/queue.c **** 
 669:lib/FreeRTOS/queue.c **** 			taskENTER_CRITICAL();
 670:lib/FreeRTOS/queue.c **** 			{
 671:lib/FreeRTOS/queue.c **** 				if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 672:lib/FreeRTOS/queue.c **** 				{
 673:lib/FreeRTOS/queue.c **** 					if( prvIsQueueFull( pxQueue ) != pdFALSE )
 674:lib/FreeRTOS/queue.c **** 					{
 675:lib/FreeRTOS/queue.c **** 						traceBLOCKING_ON_QUEUE_SEND( pxQueue );
 676:lib/FreeRTOS/queue.c **** 						vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
 677:lib/FreeRTOS/queue.c **** 						portYIELD_WITHIN_API();
 678:lib/FreeRTOS/queue.c **** 					}
 679:lib/FreeRTOS/queue.c **** 				}
 680:lib/FreeRTOS/queue.c **** 				else
 681:lib/FreeRTOS/queue.c **** 				{
 682:lib/FreeRTOS/queue.c **** 					taskEXIT_CRITICAL();
 683:lib/FreeRTOS/queue.c **** 					traceQUEUE_SEND_FAILED( pxQueue );
 684:lib/FreeRTOS/queue.c **** 					return errQUEUE_FULL;
 685:lib/FreeRTOS/queue.c **** 				}
 686:lib/FreeRTOS/queue.c **** 			}
 687:lib/FreeRTOS/queue.c **** 			taskEXIT_CRITICAL();
 688:lib/FreeRTOS/queue.c **** 		}
 689:lib/FreeRTOS/queue.c **** 	}
 690:lib/FreeRTOS/queue.c **** 
 691:lib/FreeRTOS/queue.c **** #endif /* configUSE_ALTERNATIVE_API */
 692:lib/FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
 693:lib/FreeRTOS/queue.c **** 
 694:lib/FreeRTOS/queue.c **** #if configUSE_ALTERNATIVE_API == 1
 695:lib/FreeRTOS/queue.c **** 
 696:lib/FreeRTOS/queue.c **** 	signed portBASE_TYPE xQueueAltGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTic
 697:lib/FreeRTOS/queue.c **** 	{
 698:lib/FreeRTOS/queue.c **** 	signed portBASE_TYPE xEntryTimeSet = pdFALSE;
 699:lib/FreeRTOS/queue.c **** 	xTimeOutType xTimeOut;
 700:lib/FreeRTOS/queue.c **** 	signed char *pcOriginalReadPosition;
 701:lib/FreeRTOS/queue.c **** 
 702:lib/FreeRTOS/queue.c **** 		configASSERT( pxQueue );
 703:lib/FreeRTOS/queue.c **** 		configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U )
 704:lib/FreeRTOS/queue.c **** 
 705:lib/FreeRTOS/queue.c **** 		for( ;; )
 706:lib/FreeRTOS/queue.c **** 		{
 707:lib/FreeRTOS/queue.c **** 			taskENTER_CRITICAL();
 708:lib/FreeRTOS/queue.c **** 			{
 709:lib/FreeRTOS/queue.c **** 				if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
 710:lib/FreeRTOS/queue.c **** 				{
 711:lib/FreeRTOS/queue.c **** 					/* Remember our read position in case we are just peeking. */
 712:lib/FreeRTOS/queue.c **** 					pcOriginalReadPosition = pxQueue->pcReadFrom;
 713:lib/FreeRTOS/queue.c **** 
 714:lib/FreeRTOS/queue.c **** 					prvCopyDataFromQueue( pxQueue, pvBuffer );
 715:lib/FreeRTOS/queue.c **** 
 716:lib/FreeRTOS/queue.c **** 					if( xJustPeeking == pdFALSE )
 717:lib/FreeRTOS/queue.c **** 					{
 718:lib/FreeRTOS/queue.c **** 						traceQUEUE_RECEIVE( pxQueue );
 719:lib/FreeRTOS/queue.c **** 
 720:lib/FreeRTOS/queue.c **** 						/* We are actually removing data. */
 721:lib/FreeRTOS/queue.c **** 						--( pxQueue->uxMessagesWaiting );
 722:lib/FreeRTOS/queue.c **** 
 723:lib/FreeRTOS/queue.c **** 						#if ( configUSE_MUTEXES == 1 )
 724:lib/FreeRTOS/queue.c **** 						{
 725:lib/FreeRTOS/queue.c **** 							if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 726:lib/FreeRTOS/queue.c **** 							{
 727:lib/FreeRTOS/queue.c **** 								/* Record the information required to implement
 728:lib/FreeRTOS/queue.c **** 								priority inheritance should it become necessary. */
 729:lib/FreeRTOS/queue.c **** 								pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
 730:lib/FreeRTOS/queue.c **** 							}
 731:lib/FreeRTOS/queue.c **** 						}
 732:lib/FreeRTOS/queue.c **** 						#endif
 733:lib/FreeRTOS/queue.c **** 
 734:lib/FreeRTOS/queue.c **** 						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 735:lib/FreeRTOS/queue.c **** 						{
 736:lib/FreeRTOS/queue.c **** 							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
 737:lib/FreeRTOS/queue.c **** 							{
 738:lib/FreeRTOS/queue.c **** 								portYIELD_WITHIN_API();
 739:lib/FreeRTOS/queue.c **** 							}
 740:lib/FreeRTOS/queue.c **** 						}
 741:lib/FreeRTOS/queue.c **** 					}
 742:lib/FreeRTOS/queue.c **** 					else
 743:lib/FreeRTOS/queue.c **** 					{
 744:lib/FreeRTOS/queue.c **** 						traceQUEUE_PEEK( pxQueue );
 745:lib/FreeRTOS/queue.c **** 
 746:lib/FreeRTOS/queue.c **** 						/* We are not removing the data, so reset our read
 747:lib/FreeRTOS/queue.c **** 						pointer. */
 748:lib/FreeRTOS/queue.c **** 						pxQueue->pcReadFrom = pcOriginalReadPosition;
 749:lib/FreeRTOS/queue.c **** 
 750:lib/FreeRTOS/queue.c **** 						/* The data is being left in the queue, so see if there are
 751:lib/FreeRTOS/queue.c **** 						any other tasks waiting for the data. */
 752:lib/FreeRTOS/queue.c **** 						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 753:lib/FreeRTOS/queue.c **** 						{
 754:lib/FreeRTOS/queue.c **** 							/* Tasks that are removed from the event list will get added to
 755:lib/FreeRTOS/queue.c **** 							the pending ready list as the scheduler is still suspended. */
 756:lib/FreeRTOS/queue.c **** 							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 757:lib/FreeRTOS/queue.c **** 							{
 758:lib/FreeRTOS/queue.c **** 								/* The task waiting has a higher priority than this task. */
 759:lib/FreeRTOS/queue.c **** 								portYIELD_WITHIN_API();
 760:lib/FreeRTOS/queue.c **** 							}
 761:lib/FreeRTOS/queue.c **** 						}
 762:lib/FreeRTOS/queue.c **** 
 763:lib/FreeRTOS/queue.c **** 					}
 764:lib/FreeRTOS/queue.c **** 
 765:lib/FreeRTOS/queue.c **** 					taskEXIT_CRITICAL();
 766:lib/FreeRTOS/queue.c **** 					return pdPASS;
 767:lib/FreeRTOS/queue.c **** 				}
 768:lib/FreeRTOS/queue.c **** 				else
 769:lib/FreeRTOS/queue.c **** 				{
 770:lib/FreeRTOS/queue.c **** 					if( xTicksToWait == ( portTickType ) 0 )
 771:lib/FreeRTOS/queue.c **** 					{
 772:lib/FreeRTOS/queue.c **** 						taskEXIT_CRITICAL();
 773:lib/FreeRTOS/queue.c **** 						traceQUEUE_RECEIVE_FAILED( pxQueue );
 774:lib/FreeRTOS/queue.c **** 						return errQUEUE_EMPTY;
 775:lib/FreeRTOS/queue.c **** 					}
 776:lib/FreeRTOS/queue.c **** 					else if( xEntryTimeSet == pdFALSE )
 777:lib/FreeRTOS/queue.c **** 					{
 778:lib/FreeRTOS/queue.c **** 						vTaskSetTimeOutState( &xTimeOut );
 779:lib/FreeRTOS/queue.c **** 						xEntryTimeSet = pdTRUE;
 780:lib/FreeRTOS/queue.c **** 					}
 781:lib/FreeRTOS/queue.c **** 				}
 782:lib/FreeRTOS/queue.c **** 			}
 783:lib/FreeRTOS/queue.c **** 			taskEXIT_CRITICAL();
 784:lib/FreeRTOS/queue.c **** 
 785:lib/FreeRTOS/queue.c **** 			taskENTER_CRITICAL();
 786:lib/FreeRTOS/queue.c **** 			{
 787:lib/FreeRTOS/queue.c **** 				if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 788:lib/FreeRTOS/queue.c **** 				{
 789:lib/FreeRTOS/queue.c **** 					if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 790:lib/FreeRTOS/queue.c **** 					{
 791:lib/FreeRTOS/queue.c **** 						traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
 792:lib/FreeRTOS/queue.c **** 
 793:lib/FreeRTOS/queue.c **** 						#if ( configUSE_MUTEXES == 1 )
 794:lib/FreeRTOS/queue.c **** 						{
 795:lib/FreeRTOS/queue.c **** 							if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 796:lib/FreeRTOS/queue.c **** 							{
 797:lib/FreeRTOS/queue.c **** 								portENTER_CRITICAL();
 798:lib/FreeRTOS/queue.c **** 									vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
 799:lib/FreeRTOS/queue.c **** 								portEXIT_CRITICAL();
 800:lib/FreeRTOS/queue.c **** 							}
 801:lib/FreeRTOS/queue.c **** 						}
 802:lib/FreeRTOS/queue.c **** 						#endif
 803:lib/FreeRTOS/queue.c **** 
 804:lib/FreeRTOS/queue.c **** 						vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 805:lib/FreeRTOS/queue.c **** 						portYIELD_WITHIN_API();
 806:lib/FreeRTOS/queue.c **** 					}
 807:lib/FreeRTOS/queue.c **** 				}
 808:lib/FreeRTOS/queue.c **** 				else
 809:lib/FreeRTOS/queue.c **** 				{
 810:lib/FreeRTOS/queue.c **** 					taskEXIT_CRITICAL();
 811:lib/FreeRTOS/queue.c **** 					traceQUEUE_RECEIVE_FAILED( pxQueue );
 812:lib/FreeRTOS/queue.c **** 					return errQUEUE_EMPTY;
 813:lib/FreeRTOS/queue.c **** 				}
 814:lib/FreeRTOS/queue.c **** 			}
 815:lib/FreeRTOS/queue.c **** 			taskEXIT_CRITICAL();
 816:lib/FreeRTOS/queue.c **** 		}
 817:lib/FreeRTOS/queue.c **** 	}
 818:lib/FreeRTOS/queue.c **** 
 819:lib/FreeRTOS/queue.c **** 
 820:lib/FreeRTOS/queue.c **** #endif /* configUSE_ALTERNATIVE_API */
 821:lib/FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
 822:lib/FreeRTOS/queue.c **** 
 823:lib/FreeRTOS/queue.c **** signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQue
 824:lib/FreeRTOS/queue.c **** {
 768              		.loc 1 824 0
 769              		.cfi_startproc
 770              		@ args = 0, pretend = 0, frame = 24
 771              		@ frame_needed = 1, uses_anonymous_args = 0
 772 0000 80B5     		push	{r7, lr}
 773              	.LCFI18:
 774              		.cfi_def_cfa_offset 8
 775 0002 86B0     		sub	sp, sp, #24
 776              	.LCFI19:
 777              		.cfi_def_cfa_offset 32
 778 0004 00AF     		add	r7, sp, #0
 779              		.cfi_offset 14, -4
 780              		.cfi_offset 7, -8
 781              	.LCFI20:
 782              		.cfi_def_cfa_register 7
 783 0006 F860     		str	r0, [r7, #12]
 784 0008 B960     		str	r1, [r7, #8]
 785 000a 7A60     		str	r2, [r7, #4]
 786 000c 3B60     		str	r3, [r7, #0]
 825:lib/FreeRTOS/queue.c **** signed portBASE_TYPE xReturn;
 826:lib/FreeRTOS/queue.c **** unsigned portBASE_TYPE uxSavedInterruptStatus;
 827:lib/FreeRTOS/queue.c **** 
 828:lib/FreeRTOS/queue.c **** 	configASSERT( pxQueue );
 787              		.loc 1 828 0
 788 000e FB68     		ldr	r3, [r7, #12]
 789 0010 002B     		cmp	r3, #0
 790 0012 04D1     		bne	.L45
 791              		.loc 1 828 0 is_stmt 0 discriminator 1
 792              	@ 828 "lib/FreeRTOS/queue.c" 1
 793 0014 4FF0BF00 			mov r0, #191								
 794 0018 80F31188 		msr basepri, r0							
 795              	
 796              	@ 0 "" 2
 797              		.thumb
 798              	.L46:
 799              		.loc 1 828 0 discriminator 2
 800 001c FEE7     		b	.L46
 801              	.L45:
 829:lib/FreeRTOS/queue.c **** 	configASSERT( pxHigherPriorityTaskWoken );
 802              		.loc 1 829 0 is_stmt 1
 803 001e 7B68     		ldr	r3, [r7, #4]
 804 0020 002B     		cmp	r3, #0
 805 0022 04D1     		bne	.L47
 806              		.loc 1 829 0 is_stmt 0 discriminator 1
 807              	@ 829 "lib/FreeRTOS/queue.c" 1
 808 0024 4FF0BF00 			mov r0, #191								
 809 0028 80F31188 		msr basepri, r0							
 810              	
 811              	@ 0 "" 2
 812              		.thumb
 813              	.L48:
 814              		.loc 1 829 0 discriminator 2
 815 002c FEE7     		b	.L48
 816              	.L47:
 830:lib/FreeRTOS/queue.c **** 	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 
 817              		.loc 1 830 0 is_stmt 1
 818 002e BB68     		ldr	r3, [r7, #8]
 819 0030 002B     		cmp	r3, #0
 820 0032 03D1     		bne	.L49
 821              		.loc 1 830 0 is_stmt 0 discriminator 2
 822 0034 FB68     		ldr	r3, [r7, #12]
 823 0036 1B6C     		ldr	r3, [r3, #64]
 824 0038 002B     		cmp	r3, #0
 825 003a 02D1     		bne	.L50
 826              	.L49:
 827              		.loc 1 830 0 discriminator 1
 828 003c 4FF00103 		mov	r3, #1
 829 0040 01E0     		b	.L51
 830              	.L50:
 831              		.loc 1 830 0 discriminator 3
 832 0042 4FF00003 		mov	r3, #0
 833              	.L51:
 834              		.loc 1 830 0 discriminator 4
 835 0046 002B     		cmp	r3, #0
 836 0048 04D1     		bne	.L52
 837              		.loc 1 830 0 discriminator 5
 838              	@ 830 "lib/FreeRTOS/queue.c" 1
 839 004a 4FF0BF00 			mov r0, #191								
 840 004e 80F31188 		msr basepri, r0							
 841              	
 842              	@ 0 "" 2
 843              		.thumb
 844              	.L53:
 845              		.loc 1 830 0 discriminator 6
 846 0052 FEE7     		b	.L53
 847              	.L52:
 831:lib/FreeRTOS/queue.c **** 
 832:lib/FreeRTOS/queue.c **** 	/* Similar to xQueueGenericSend, except we don't block if there is no room
 833:lib/FreeRTOS/queue.c **** 	in the queue.  Also we don't directly wake a task that was blocked on a
 834:lib/FreeRTOS/queue.c **** 	queue read, instead we return a flag to say whether a context switch is
 835:lib/FreeRTOS/queue.c **** 	required or not (i.e. has a task with a higher priority than us been woken
 836:lib/FreeRTOS/queue.c **** 	by this	post). */
 837:lib/FreeRTOS/queue.c **** 	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 848              		.loc 1 837 0 is_stmt 1
 849 0054 4FF00003 		mov	r3, #0
 850 0058 3B61     		str	r3, [r7, #16]
 851              	@ 837 "lib/FreeRTOS/queue.c" 1
 852 005a 4FF0BF00 			mov r0, #191								
 853 005e 80F31188 		msr basepri, r0							
 854              	
 855              	@ 0 "" 2
 838:lib/FreeRTOS/queue.c **** 	{
 839:lib/FreeRTOS/queue.c **** 		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
 856              		.loc 1 839 0
 857              		.thumb
 858 0062 FB68     		ldr	r3, [r7, #12]
 859 0064 9A6B     		ldr	r2, [r3, #56]
 860 0066 FB68     		ldr	r3, [r7, #12]
 861 0068 DB6B     		ldr	r3, [r3, #60]
 862 006a 9A42     		cmp	r2, r3
 863 006c 25D2     		bcs	.L54
 840:lib/FreeRTOS/queue.c **** 		{
 841:lib/FreeRTOS/queue.c **** 			traceQUEUE_SEND_FROM_ISR( pxQueue );
 842:lib/FreeRTOS/queue.c **** 
 843:lib/FreeRTOS/queue.c **** 			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 864              		.loc 1 843 0
 865 006e F868     		ldr	r0, [r7, #12]
 866 0070 B968     		ldr	r1, [r7, #8]
 867 0072 3A68     		ldr	r2, [r7, #0]
 868 0074 FFF7FEFF 		bl	prvCopyDataToQueue
 844:lib/FreeRTOS/queue.c **** 
 845:lib/FreeRTOS/queue.c **** 			/* If the queue is locked we do not alter the event list.  This will
 846:lib/FreeRTOS/queue.c **** 			be done when the queue is unlocked later. */
 847:lib/FreeRTOS/queue.c **** 			if( pxQueue->xTxLock == queueUNLOCKED )
 869              		.loc 1 847 0
 870 0078 FB68     		ldr	r3, [r7, #12]
 871 007a 9B6C     		ldr	r3, [r3, #72]
 872 007c B3F1FF3F 		cmp	r3, #-1
 873 0080 11D1     		bne	.L55
 848:lib/FreeRTOS/queue.c **** 			{
 849:lib/FreeRTOS/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 874              		.loc 1 849 0
 875 0082 FB68     		ldr	r3, [r7, #12]
 876 0084 5B6A     		ldr	r3, [r3, #36]
 877 0086 002B     		cmp	r3, #0
 878 0088 13D0     		beq	.L56
 850:lib/FreeRTOS/queue.c **** 				{
 851:lib/FreeRTOS/queue.c **** 					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 879              		.loc 1 851 0
 880 008a FB68     		ldr	r3, [r7, #12]
 881 008c 03F12403 		add	r3, r3, #36
 882 0090 1846     		mov	r0, r3
 883 0092 FFF7FEFF 		bl	xTaskRemoveFromEventList
 884 0096 0346     		mov	r3, r0
 885 0098 002B     		cmp	r3, #0
 886 009a 0AD0     		beq	.L56
 852:lib/FreeRTOS/queue.c **** 					{
 853:lib/FreeRTOS/queue.c **** 						/* The task waiting has a higher priority so record that a
 854:lib/FreeRTOS/queue.c **** 						context	switch is required. */
 855:lib/FreeRTOS/queue.c **** 						*pxHigherPriorityTaskWoken = pdTRUE;
 887              		.loc 1 855 0
 888 009c 7B68     		ldr	r3, [r7, #4]
 889 009e 4FF00102 		mov	r2, #1
 890 00a2 1A60     		str	r2, [r3, #0]
 891 00a4 05E0     		b	.L56
 892              	.L55:
 856:lib/FreeRTOS/queue.c **** 					}
 857:lib/FreeRTOS/queue.c **** 				}
 858:lib/FreeRTOS/queue.c **** 			}
 859:lib/FreeRTOS/queue.c **** 			else
 860:lib/FreeRTOS/queue.c **** 			{
 861:lib/FreeRTOS/queue.c **** 				/* Increment the lock count so the task that unlocks the queue
 862:lib/FreeRTOS/queue.c **** 				knows that data was posted while it was locked. */
 863:lib/FreeRTOS/queue.c **** 				++( pxQueue->xTxLock );
 893              		.loc 1 863 0
 894 00a6 FB68     		ldr	r3, [r7, #12]
 895 00a8 9B6C     		ldr	r3, [r3, #72]
 896 00aa 03F10102 		add	r2, r3, #1
 897 00ae FB68     		ldr	r3, [r7, #12]
 898 00b0 9A64     		str	r2, [r3, #72]
 899              	.L56:
 864:lib/FreeRTOS/queue.c **** 			}
 865:lib/FreeRTOS/queue.c **** 
 866:lib/FreeRTOS/queue.c **** 			xReturn = pdPASS;
 900              		.loc 1 866 0
 901 00b2 4FF00103 		mov	r3, #1
 902 00b6 7B61     		str	r3, [r7, #20]
 903 00b8 02E0     		b	.L57
 904              	.L54:
 867:lib/FreeRTOS/queue.c **** 		}
 868:lib/FreeRTOS/queue.c **** 		else
 869:lib/FreeRTOS/queue.c **** 		{
 870:lib/FreeRTOS/queue.c **** 			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
 871:lib/FreeRTOS/queue.c **** 			xReturn = errQUEUE_FULL;
 905              		.loc 1 871 0
 906 00ba 4FF00003 		mov	r3, #0
 907 00be 7B61     		str	r3, [r7, #20]
 908              	.L57:
 872:lib/FreeRTOS/queue.c **** 		}
 873:lib/FreeRTOS/queue.c **** 	}
 874:lib/FreeRTOS/queue.c **** 	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
 909              		.loc 1 874 0
 910              	@ 874 "lib/FreeRTOS/queue.c" 1
 911 00c0 4FF00000 			mov r0, #0					
 912 00c4 80F31188 		msr basepri, r0				
 913              	
 914              	@ 0 "" 2
 875:lib/FreeRTOS/queue.c **** 
 876:lib/FreeRTOS/queue.c **** 	return xReturn;
 915              		.loc 1 876 0
 916              		.thumb
 917 00c8 7B69     		ldr	r3, [r7, #20]
 877:lib/FreeRTOS/queue.c **** }
 918              		.loc 1 877 0
 919 00ca 1846     		mov	r0, r3
 920 00cc 07F11807 		add	r7, r7, #24
 921 00d0 BD46     		mov	sp, r7
 922 00d2 80BD     		pop	{r7, pc}
 923              		.cfi_endproc
 924              	.LFE116:
 926              		.section	.text.xQueueGenericReceive,"ax",%progbits
 927              		.align	2
 928              		.global	xQueueGenericReceive
 929              		.thumb
 930              		.thumb_func
 932              	xQueueGenericReceive:
 933              	.LFB117:
 878:lib/FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
 879:lib/FreeRTOS/queue.c **** 
 880:lib/FreeRTOS/queue.c **** signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickTyp
 881:lib/FreeRTOS/queue.c **** {
 934              		.loc 1 881 0
 935              		.cfi_startproc
 936              		@ args = 0, pretend = 0, frame = 32
 937              		@ frame_needed = 1, uses_anonymous_args = 0
 938 0000 80B5     		push	{r7, lr}
 939              	.LCFI21:
 940              		.cfi_def_cfa_offset 8
 941 0002 88B0     		sub	sp, sp, #32
 942              	.LCFI22:
 943              		.cfi_def_cfa_offset 40
 944 0004 00AF     		add	r7, sp, #0
 945              		.cfi_offset 14, -4
 946              		.cfi_offset 7, -8
 947              	.LCFI23:
 948              		.cfi_def_cfa_register 7
 949 0006 F860     		str	r0, [r7, #12]
 950 0008 B960     		str	r1, [r7, #8]
 951 000a 7A60     		str	r2, [r7, #4]
 952 000c 3B60     		str	r3, [r7, #0]
 882:lib/FreeRTOS/queue.c **** signed portBASE_TYPE xEntryTimeSet = pdFALSE;
 953              		.loc 1 882 0
 954 000e 4FF00003 		mov	r3, #0
 955 0012 FB61     		str	r3, [r7, #28]
 883:lib/FreeRTOS/queue.c **** xTimeOutType xTimeOut;
 884:lib/FreeRTOS/queue.c **** signed char *pcOriginalReadPosition;
 885:lib/FreeRTOS/queue.c **** 
 886:lib/FreeRTOS/queue.c **** 	configASSERT( pxQueue );
 956              		.loc 1 886 0
 957 0014 FB68     		ldr	r3, [r7, #12]
 958 0016 002B     		cmp	r3, #0
 959 0018 04D1     		bne	.L59
 960              		.loc 1 886 0 is_stmt 0 discriminator 1
 961              	@ 886 "lib/FreeRTOS/queue.c" 1
 962 001a 4FF0BF00 			mov r0, #191								
 963 001e 80F31188 		msr basepri, r0							
 964              	
 965              	@ 0 "" 2
 966              		.thumb
 967              	.L60:
 968              		.loc 1 886 0 discriminator 2
 969 0022 FEE7     		b	.L60
 970              	.L59:
 887:lib/FreeRTOS/queue.c **** 	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) 
 971              		.loc 1 887 0 is_stmt 1
 972 0024 BB68     		ldr	r3, [r7, #8]
 973 0026 002B     		cmp	r3, #0
 974 0028 03D1     		bne	.L61
 975              		.loc 1 887 0 is_stmt 0 discriminator 2
 976 002a FB68     		ldr	r3, [r7, #12]
 977 002c 1B6C     		ldr	r3, [r3, #64]
 978 002e 002B     		cmp	r3, #0
 979 0030 02D1     		bne	.L62
 980              	.L61:
 981              		.loc 1 887 0 discriminator 1
 982 0032 4FF00103 		mov	r3, #1
 983 0036 01E0     		b	.L63
 984              	.L62:
 985              		.loc 1 887 0 discriminator 3
 986 0038 4FF00003 		mov	r3, #0
 987              	.L63:
 988              		.loc 1 887 0 discriminator 4
 989 003c 002B     		cmp	r3, #0
 990 003e 05D1     		bne	.L64
 991              		.loc 1 887 0 discriminator 5
 992              	@ 887 "lib/FreeRTOS/queue.c" 1
 993 0040 4FF0BF00 			mov r0, #191								
 994 0044 80F31188 		msr basepri, r0							
 995              	
 996              	@ 0 "" 2
 997              		.thumb
 998              	.L65:
 999              		.loc 1 887 0 discriminator 6
 1000 0048 FEE7     		b	.L65
 1001              	.L79:
 888:lib/FreeRTOS/queue.c **** 
 889:lib/FreeRTOS/queue.c **** 	/* This function relaxes the coding standard somewhat to allow return
 890:lib/FreeRTOS/queue.c **** 	statements within the function itself.  This is done in the interest
 891:lib/FreeRTOS/queue.c **** 	of execution time efficiency. */
 892:lib/FreeRTOS/queue.c **** 
 893:lib/FreeRTOS/queue.c **** 	for( ;; )
 894:lib/FreeRTOS/queue.c **** 	{
 895:lib/FreeRTOS/queue.c **** 		taskENTER_CRITICAL();
 896:lib/FreeRTOS/queue.c **** 		{
 897:lib/FreeRTOS/queue.c **** 			/* Is there data in the queue now?  To be running we must be
 898:lib/FreeRTOS/queue.c **** 			the highest priority task wanting to access the queue. */
 899:lib/FreeRTOS/queue.c **** 			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
 900:lib/FreeRTOS/queue.c **** 			{
 901:lib/FreeRTOS/queue.c **** 				/* Remember our read position in case we are just peeking. */
 902:lib/FreeRTOS/queue.c **** 				pcOriginalReadPosition = pxQueue->pcReadFrom;
 903:lib/FreeRTOS/queue.c **** 
 904:lib/FreeRTOS/queue.c **** 				prvCopyDataFromQueue( pxQueue, pvBuffer );
 905:lib/FreeRTOS/queue.c **** 
 906:lib/FreeRTOS/queue.c **** 				if( xJustPeeking == pdFALSE )
 907:lib/FreeRTOS/queue.c **** 				{
 908:lib/FreeRTOS/queue.c **** 					traceQUEUE_RECEIVE( pxQueue );
 909:lib/FreeRTOS/queue.c **** 
 910:lib/FreeRTOS/queue.c **** 					/* We are actually removing data. */
 911:lib/FreeRTOS/queue.c **** 					--( pxQueue->uxMessagesWaiting );
 912:lib/FreeRTOS/queue.c **** 
 913:lib/FreeRTOS/queue.c **** 					#if ( configUSE_MUTEXES == 1 )
 914:lib/FreeRTOS/queue.c **** 					{
 915:lib/FreeRTOS/queue.c **** 						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 916:lib/FreeRTOS/queue.c **** 						{
 917:lib/FreeRTOS/queue.c **** 							/* Record the information required to implement
 918:lib/FreeRTOS/queue.c **** 							priority inheritance should it become necessary. */
 919:lib/FreeRTOS/queue.c **** 							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
 920:lib/FreeRTOS/queue.c **** 						}
 921:lib/FreeRTOS/queue.c **** 					}
 922:lib/FreeRTOS/queue.c **** 					#endif
 923:lib/FreeRTOS/queue.c **** 
 924:lib/FreeRTOS/queue.c **** 					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 925:lib/FreeRTOS/queue.c **** 					{
 926:lib/FreeRTOS/queue.c **** 						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
 927:lib/FreeRTOS/queue.c **** 						{
 928:lib/FreeRTOS/queue.c **** 							portYIELD_WITHIN_API();
 929:lib/FreeRTOS/queue.c **** 						}
 930:lib/FreeRTOS/queue.c **** 					}
 931:lib/FreeRTOS/queue.c **** 				}
 932:lib/FreeRTOS/queue.c **** 				else
 933:lib/FreeRTOS/queue.c **** 				{
 934:lib/FreeRTOS/queue.c **** 					traceQUEUE_PEEK( pxQueue );
 935:lib/FreeRTOS/queue.c **** 
 936:lib/FreeRTOS/queue.c **** 					/* We are not removing the data, so reset our read
 937:lib/FreeRTOS/queue.c **** 					pointer. */
 938:lib/FreeRTOS/queue.c **** 					pxQueue->pcReadFrom = pcOriginalReadPosition;
 939:lib/FreeRTOS/queue.c **** 
 940:lib/FreeRTOS/queue.c **** 					/* The data is being left in the queue, so see if there are
 941:lib/FreeRTOS/queue.c **** 					any other tasks waiting for the data. */
 942:lib/FreeRTOS/queue.c **** 					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 943:lib/FreeRTOS/queue.c **** 					{
 944:lib/FreeRTOS/queue.c **** 						/* Tasks that are removed from the event list will get added to
 945:lib/FreeRTOS/queue.c **** 						the pending ready list as the scheduler is still suspended. */
 946:lib/FreeRTOS/queue.c **** 						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 947:lib/FreeRTOS/queue.c **** 						{
 948:lib/FreeRTOS/queue.c **** 							/* The task waiting has a higher priority than this task. */
 949:lib/FreeRTOS/queue.c **** 							portYIELD_WITHIN_API();
 950:lib/FreeRTOS/queue.c **** 						}
 951:lib/FreeRTOS/queue.c **** 					}
 952:lib/FreeRTOS/queue.c **** 
 953:lib/FreeRTOS/queue.c **** 				}
 954:lib/FreeRTOS/queue.c **** 
 955:lib/FreeRTOS/queue.c **** 				taskEXIT_CRITICAL();
 956:lib/FreeRTOS/queue.c **** 				return pdPASS;
 957:lib/FreeRTOS/queue.c **** 			}
 958:lib/FreeRTOS/queue.c **** 			else
 959:lib/FreeRTOS/queue.c **** 			{
 960:lib/FreeRTOS/queue.c **** 				if( xTicksToWait == ( portTickType ) 0 )
 961:lib/FreeRTOS/queue.c **** 				{
 962:lib/FreeRTOS/queue.c **** 					/* The queue was empty and no block time is specified (or
 963:lib/FreeRTOS/queue.c **** 					the block time has expired) so leave now. */
 964:lib/FreeRTOS/queue.c **** 					taskEXIT_CRITICAL();
 965:lib/FreeRTOS/queue.c **** 					traceQUEUE_RECEIVE_FAILED( pxQueue );
 966:lib/FreeRTOS/queue.c **** 					return errQUEUE_EMPTY;
 967:lib/FreeRTOS/queue.c **** 				}
 968:lib/FreeRTOS/queue.c **** 				else if( xEntryTimeSet == pdFALSE )
 969:lib/FreeRTOS/queue.c **** 				{
 970:lib/FreeRTOS/queue.c **** 					/* The queue was empty and a block time was specified so
 971:lib/FreeRTOS/queue.c **** 					configure the timeout structure. */
 972:lib/FreeRTOS/queue.c **** 					vTaskSetTimeOutState( &xTimeOut );
 973:lib/FreeRTOS/queue.c **** 					xEntryTimeSet = pdTRUE;
 974:lib/FreeRTOS/queue.c **** 				}
 975:lib/FreeRTOS/queue.c **** 			}
 976:lib/FreeRTOS/queue.c **** 		}
 977:lib/FreeRTOS/queue.c **** 		taskEXIT_CRITICAL();
 978:lib/FreeRTOS/queue.c **** 
 979:lib/FreeRTOS/queue.c **** 		/* Interrupts and other tasks can send to and receive from the queue
 980:lib/FreeRTOS/queue.c **** 		now the critical section has been exited. */
 981:lib/FreeRTOS/queue.c **** 
 982:lib/FreeRTOS/queue.c **** 		vTaskSuspendAll();
 983:lib/FreeRTOS/queue.c **** 		prvLockQueue( pxQueue );
 984:lib/FreeRTOS/queue.c **** 
 985:lib/FreeRTOS/queue.c **** 		/* Update the timeout state to see if it has expired yet. */
 986:lib/FreeRTOS/queue.c **** 		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 987:lib/FreeRTOS/queue.c **** 		{
 988:lib/FreeRTOS/queue.c **** 			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 989:lib/FreeRTOS/queue.c **** 			{
 990:lib/FreeRTOS/queue.c **** 				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
 991:lib/FreeRTOS/queue.c **** 
 992:lib/FreeRTOS/queue.c **** 				#if ( configUSE_MUTEXES == 1 )
 993:lib/FreeRTOS/queue.c **** 				{
 994:lib/FreeRTOS/queue.c **** 					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 995:lib/FreeRTOS/queue.c **** 					{
 996:lib/FreeRTOS/queue.c **** 						portENTER_CRITICAL();
 997:lib/FreeRTOS/queue.c **** 						{
 998:lib/FreeRTOS/queue.c **** 							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
 999:lib/FreeRTOS/queue.c **** 						}
1000:lib/FreeRTOS/queue.c **** 						portEXIT_CRITICAL();
1001:lib/FreeRTOS/queue.c **** 					}
1002:lib/FreeRTOS/queue.c **** 				}
1003:lib/FreeRTOS/queue.c **** 				#endif
1004:lib/FreeRTOS/queue.c **** 
1005:lib/FreeRTOS/queue.c **** 				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
1006:lib/FreeRTOS/queue.c **** 				prvUnlockQueue( pxQueue );
1007:lib/FreeRTOS/queue.c **** 				if( xTaskResumeAll() == pdFALSE )
1008:lib/FreeRTOS/queue.c **** 				{
1009:lib/FreeRTOS/queue.c **** 					portYIELD_WITHIN_API();
1010:lib/FreeRTOS/queue.c **** 				}
1011:lib/FreeRTOS/queue.c **** 			}
1012:lib/FreeRTOS/queue.c **** 			else
1013:lib/FreeRTOS/queue.c **** 			{
1014:lib/FreeRTOS/queue.c **** 				/* Try again. */
1015:lib/FreeRTOS/queue.c **** 				prvUnlockQueue( pxQueue );
1016:lib/FreeRTOS/queue.c **** 				( void ) xTaskResumeAll();
1017:lib/FreeRTOS/queue.c **** 			}
1018:lib/FreeRTOS/queue.c **** 		}
1019:lib/FreeRTOS/queue.c **** 		else
1020:lib/FreeRTOS/queue.c **** 		{
1021:lib/FreeRTOS/queue.c **** 			prvUnlockQueue( pxQueue );
1022:lib/FreeRTOS/queue.c **** 			( void ) xTaskResumeAll();
1023:lib/FreeRTOS/queue.c **** 			traceQUEUE_RECEIVE_FAILED( pxQueue );
1024:lib/FreeRTOS/queue.c **** 			return errQUEUE_EMPTY;
1025:lib/FreeRTOS/queue.c **** 		}
1026:lib/FreeRTOS/queue.c **** 	}
 1002              		.loc 1 1026 0 is_stmt 1
 1003 004a 00BF     		nop
 1004              	.L64:
 895:lib/FreeRTOS/queue.c **** 		taskENTER_CRITICAL();
 1005              		.loc 1 895 0
 1006 004c FFF7FEFF 		bl	vPortEnterCritical
 899:lib/FreeRTOS/queue.c **** 			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
 1007              		.loc 1 899 0
 1008 0050 FB68     		ldr	r3, [r7, #12]
 1009 0052 9B6B     		ldr	r3, [r3, #56]
 1010 0054 002B     		cmp	r3, #0
 1011 0056 40D0     		beq	.L66
 902:lib/FreeRTOS/queue.c **** 				pcOriginalReadPosition = pxQueue->pcReadFrom;
 1012              		.loc 1 902 0
 1013 0058 FB68     		ldr	r3, [r7, #12]
 1014 005a DB68     		ldr	r3, [r3, #12]
 1015 005c BB61     		str	r3, [r7, #24]
 904:lib/FreeRTOS/queue.c **** 				prvCopyDataFromQueue( pxQueue, pvBuffer );
 1016              		.loc 1 904 0
 1017 005e F868     		ldr	r0, [r7, #12]
 1018 0060 B968     		ldr	r1, [r7, #8]
 1019 0062 FFF7FEFF 		bl	prvCopyDataFromQueue
 906:lib/FreeRTOS/queue.c **** 				if( xJustPeeking == pdFALSE )
 1020              		.loc 1 906 0
 1021 0066 3B68     		ldr	r3, [r7, #0]
 1022 0068 002B     		cmp	r3, #0
 1023 006a 1FD1     		bne	.L67
 911:lib/FreeRTOS/queue.c **** 					--( pxQueue->uxMessagesWaiting );
 1024              		.loc 1 911 0
 1025 006c FB68     		ldr	r3, [r7, #12]
 1026 006e 9B6B     		ldr	r3, [r3, #56]
 1027 0070 03F1FF32 		add	r2, r3, #-1
 1028 0074 FB68     		ldr	r3, [r7, #12]
 1029 0076 9A63     		str	r2, [r3, #56]
 915:lib/FreeRTOS/queue.c **** 						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 1030              		.loc 1 915 0
 1031 0078 FB68     		ldr	r3, [r7, #12]
 1032 007a 1B68     		ldr	r3, [r3, #0]
 1033 007c 002B     		cmp	r3, #0
 1034 007e 05D1     		bne	.L68
 919:lib/FreeRTOS/queue.c **** 							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
 1035              		.loc 1 919 0
 1036 0080 FFF7FEFF 		bl	xTaskGetCurrentTaskHandle
 1037 0084 0346     		mov	r3, r0
 1038 0086 1A46     		mov	r2, r3
 1039 0088 FB68     		ldr	r3, [r7, #12]
 1040 008a 5A60     		str	r2, [r3, #4]
 1041              	.L68:
 924:lib/FreeRTOS/queue.c **** 					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 1042              		.loc 1 924 0
 1043 008c FB68     		ldr	r3, [r7, #12]
 1044 008e 1B69     		ldr	r3, [r3, #16]
 1045 0090 002B     		cmp	r3, #0
 1046 0092 1DD0     		beq	.L69
 926:lib/FreeRTOS/queue.c **** 						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
 1047              		.loc 1 926 0
 1048 0094 FB68     		ldr	r3, [r7, #12]
 1049 0096 03F11003 		add	r3, r3, #16
 1050 009a 1846     		mov	r0, r3
 1051 009c FFF7FEFF 		bl	xTaskRemoveFromEventList
 1052 00a0 0346     		mov	r3, r0
 1053 00a2 012B     		cmp	r3, #1
 1054 00a4 14D1     		bne	.L69
 928:lib/FreeRTOS/queue.c **** 							portYIELD_WITHIN_API();
 1055              		.loc 1 928 0
 1056 00a6 FFF7FEFF 		bl	vPortYieldFromISR
 1057 00aa 11E0     		b	.L69
 1058              	.L67:
 938:lib/FreeRTOS/queue.c **** 					pxQueue->pcReadFrom = pcOriginalReadPosition;
 1059              		.loc 1 938 0
 1060 00ac FB68     		ldr	r3, [r7, #12]
 1061 00ae BA69     		ldr	r2, [r7, #24]
 1062 00b0 DA60     		str	r2, [r3, #12]
 942:lib/FreeRTOS/queue.c **** 					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 1063              		.loc 1 942 0
 1064 00b2 FB68     		ldr	r3, [r7, #12]
 1065 00b4 5B6A     		ldr	r3, [r3, #36]
 1066 00b6 002B     		cmp	r3, #0
 1067 00b8 0AD0     		beq	.L69
 946:lib/FreeRTOS/queue.c **** 						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 1068              		.loc 1 946 0
 1069 00ba FB68     		ldr	r3, [r7, #12]
 1070 00bc 03F12403 		add	r3, r3, #36
 1071 00c0 1846     		mov	r0, r3
 1072 00c2 FFF7FEFF 		bl	xTaskRemoveFromEventList
 1073 00c6 0346     		mov	r3, r0
 1074 00c8 002B     		cmp	r3, #0
 1075 00ca 01D0     		beq	.L69
 949:lib/FreeRTOS/queue.c **** 							portYIELD_WITHIN_API();
 1076              		.loc 1 949 0
 1077 00cc FFF7FEFF 		bl	vPortYieldFromISR
 1078              	.L69:
 955:lib/FreeRTOS/queue.c **** 				taskEXIT_CRITICAL();
 1079              		.loc 1 955 0
 1080 00d0 FFF7FEFF 		bl	vPortExitCritical
 956:lib/FreeRTOS/queue.c **** 				return pdPASS;
 1081              		.loc 1 956 0
 1082 00d4 4FF00103 		mov	r3, #1
 1083 00d8 6BE0     		b	.L70
 1084              	.L66:
 960:lib/FreeRTOS/queue.c **** 				if( xTicksToWait == ( portTickType ) 0 )
 1085              		.loc 1 960 0
 1086 00da 7B68     		ldr	r3, [r7, #4]
 1087 00dc 002B     		cmp	r3, #0
 1088 00de 04D1     		bne	.L71
 964:lib/FreeRTOS/queue.c **** 					taskEXIT_CRITICAL();
 1089              		.loc 1 964 0
 1090 00e0 FFF7FEFF 		bl	vPortExitCritical
 966:lib/FreeRTOS/queue.c **** 					return errQUEUE_EMPTY;
 1091              		.loc 1 966 0
 1092 00e4 4FF00003 		mov	r3, #0
 1093 00e8 63E0     		b	.L70
 1094              	.L71:
 968:lib/FreeRTOS/queue.c **** 				else if( xEntryTimeSet == pdFALSE )
 1095              		.loc 1 968 0
 1096 00ea FB69     		ldr	r3, [r7, #28]
 1097 00ec 002B     		cmp	r3, #0
 1098 00ee 07D1     		bne	.L72
 972:lib/FreeRTOS/queue.c **** 					vTaskSetTimeOutState( &xTimeOut );
 1099              		.loc 1 972 0
 1100 00f0 07F11003 		add	r3, r7, #16
 1101 00f4 1846     		mov	r0, r3
 1102 00f6 FFF7FEFF 		bl	vTaskSetTimeOutState
 973:lib/FreeRTOS/queue.c **** 					xEntryTimeSet = pdTRUE;
 1103              		.loc 1 973 0
 1104 00fa 4FF00103 		mov	r3, #1
 1105 00fe FB61     		str	r3, [r7, #28]
 1106              	.L72:
 977:lib/FreeRTOS/queue.c **** 		taskEXIT_CRITICAL();
 1107              		.loc 1 977 0
 1108 0100 FFF7FEFF 		bl	vPortExitCritical
 982:lib/FreeRTOS/queue.c **** 		vTaskSuspendAll();
 1109              		.loc 1 982 0
 1110 0104 FFF7FEFF 		bl	vTaskSuspendAll
 983:lib/FreeRTOS/queue.c **** 		prvLockQueue( pxQueue );
 1111              		.loc 1 983 0
 1112 0108 FFF7FEFF 		bl	vPortEnterCritical
 1113 010c FB68     		ldr	r3, [r7, #12]
 1114 010e 5B6C     		ldr	r3, [r3, #68]
 1115 0110 B3F1FF3F 		cmp	r3, #-1
 1116 0114 03D1     		bne	.L73
 983:lib/FreeRTOS/queue.c **** 		prvLockQueue( pxQueue );
 1117              		.loc 1 983 0 is_stmt 0 discriminator 1
 1118 0116 FB68     		ldr	r3, [r7, #12]
 1119 0118 4FF00002 		mov	r2, #0
 1120 011c 5A64     		str	r2, [r3, #68]
 1121              	.L73:
 983:lib/FreeRTOS/queue.c **** 		prvLockQueue( pxQueue );
 1122              		.loc 1 983 0 discriminator 2
 1123 011e FB68     		ldr	r3, [r7, #12]
 1124 0120 9B6C     		ldr	r3, [r3, #72]
 1125 0122 B3F1FF3F 		cmp	r3, #-1
 1126 0126 03D1     		bne	.L74
 983:lib/FreeRTOS/queue.c **** 		prvLockQueue( pxQueue );
 1127              		.loc 1 983 0 discriminator 3
 1128 0128 FB68     		ldr	r3, [r7, #12]
 1129 012a 4FF00002 		mov	r2, #0
 1130 012e 9A64     		str	r2, [r3, #72]
 1131              	.L74:
 983:lib/FreeRTOS/queue.c **** 		prvLockQueue( pxQueue );
 1132              		.loc 1 983 0 discriminator 4
 1133 0130 FFF7FEFF 		bl	vPortExitCritical
 986:lib/FreeRTOS/queue.c **** 		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 1134              		.loc 1 986 0 is_stmt 1 discriminator 4
 1135 0134 07F11002 		add	r2, r7, #16
 1136 0138 07F10403 		add	r3, r7, #4
 1137 013c 1046     		mov	r0, r2
 1138 013e 1946     		mov	r1, r3
 1139 0140 FFF7FEFF 		bl	xTaskCheckForTimeOut
 1140 0144 0346     		mov	r3, r0
 1141 0146 002B     		cmp	r3, #0
 1142 0148 2CD1     		bne	.L75
 988:lib/FreeRTOS/queue.c **** 			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 1143              		.loc 1 988 0
 1144 014a F868     		ldr	r0, [r7, #12]
 1145 014c FFF7FEFF 		bl	prvIsQueueEmpty
 1146 0150 0346     		mov	r3, r0
 1147 0152 002B     		cmp	r3, #0
 1148 0154 20D0     		beq	.L76
 994:lib/FreeRTOS/queue.c **** 					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 1149              		.loc 1 994 0
 1150 0156 FB68     		ldr	r3, [r7, #12]
 1151 0158 1B68     		ldr	r3, [r3, #0]
 1152 015a 002B     		cmp	r3, #0
 1153 015c 08D1     		bne	.L77
 996:lib/FreeRTOS/queue.c **** 						portENTER_CRITICAL();
 1154              		.loc 1 996 0
 1155 015e FFF7FEFF 		bl	vPortEnterCritical
 998:lib/FreeRTOS/queue.c **** 							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
 1156              		.loc 1 998 0
 1157 0162 FB68     		ldr	r3, [r7, #12]
 1158 0164 5B68     		ldr	r3, [r3, #4]
 1159 0166 1846     		mov	r0, r3
 1160 0168 FFF7FEFF 		bl	vTaskPriorityInherit
1000:lib/FreeRTOS/queue.c **** 						portEXIT_CRITICAL();
 1161              		.loc 1 1000 0
 1162 016c FFF7FEFF 		bl	vPortExitCritical
 1163              	.L77:
1005:lib/FreeRTOS/queue.c **** 				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 1164              		.loc 1 1005 0
 1165 0170 FB68     		ldr	r3, [r7, #12]
 1166 0172 03F12402 		add	r2, r3, #36
 1167 0176 7B68     		ldr	r3, [r7, #4]
 1168 0178 1046     		mov	r0, r2
 1169 017a 1946     		mov	r1, r3
 1170 017c FFF7FEFF 		bl	vTaskPlaceOnEventList
1006:lib/FreeRTOS/queue.c **** 				prvUnlockQueue( pxQueue );
 1171              		.loc 1 1006 0
 1172 0180 F868     		ldr	r0, [r7, #12]
 1173 0182 FFF7FEFF 		bl	prvUnlockQueue
1007:lib/FreeRTOS/queue.c **** 				if( xTaskResumeAll() == pdFALSE )
 1174              		.loc 1 1007 0
 1175 0186 FFF7FEFF 		bl	xTaskResumeAll
 1176 018a 0346     		mov	r3, r0
 1177 018c 002B     		cmp	r3, #0
 1178 018e 7FF45CAF 		bne	.L79
1009:lib/FreeRTOS/queue.c **** 					portYIELD_WITHIN_API();
 1179              		.loc 1 1009 0
 1180 0192 FFF7FEFF 		bl	vPortYieldFromISR
 1181              		.loc 1 1026 0
 1182 0196 59E7     		b	.L64
 1183              	.L76:
1015:lib/FreeRTOS/queue.c **** 				prvUnlockQueue( pxQueue );
 1184              		.loc 1 1015 0
 1185 0198 F868     		ldr	r0, [r7, #12]
 1186 019a FFF7FEFF 		bl	prvUnlockQueue
1016:lib/FreeRTOS/queue.c **** 				( void ) xTaskResumeAll();
 1187              		.loc 1 1016 0
 1188 019e FFF7FEFF 		bl	xTaskResumeAll
 1189              		.loc 1 1026 0
 1190 01a2 53E7     		b	.L64
 1191              	.L75:
1021:lib/FreeRTOS/queue.c **** 			prvUnlockQueue( pxQueue );
 1192              		.loc 1 1021 0
 1193 01a4 F868     		ldr	r0, [r7, #12]
 1194 01a6 FFF7FEFF 		bl	prvUnlockQueue
1022:lib/FreeRTOS/queue.c **** 			( void ) xTaskResumeAll();
 1195              		.loc 1 1022 0
 1196 01aa FFF7FEFF 		bl	xTaskResumeAll
1024:lib/FreeRTOS/queue.c **** 			return errQUEUE_EMPTY;
 1197              		.loc 1 1024 0
 1198 01ae 4FF00003 		mov	r3, #0
 1199              	.L70:
1027:lib/FreeRTOS/queue.c **** }
 1200              		.loc 1 1027 0
 1201 01b2 1846     		mov	r0, r3
 1202 01b4 07F12007 		add	r7, r7, #32
 1203 01b8 BD46     		mov	sp, r7
 1204 01ba 80BD     		pop	{r7, pc}
 1205              		.cfi_endproc
 1206              	.LFE117:
 1208              		.section	.text.xQueueReceiveFromISR,"ax",%progbits
 1209              		.align	2
 1210              		.global	xQueueReceiveFromISR
 1211              		.thumb
 1212              		.thumb_func
 1214              	xQueueReceiveFromISR:
 1215              	.LFB118:
1028:lib/FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
1029:lib/FreeRTOS/queue.c **** 
1030:lib/FreeRTOS/queue.c **** signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed port
1031:lib/FreeRTOS/queue.c **** {
 1216              		.loc 1 1031 0
 1217              		.cfi_startproc
 1218              		@ args = 0, pretend = 0, frame = 24
 1219              		@ frame_needed = 1, uses_anonymous_args = 0
 1220 0000 80B5     		push	{r7, lr}
 1221              	.LCFI24:
 1222              		.cfi_def_cfa_offset 8
 1223 0002 86B0     		sub	sp, sp, #24
 1224              	.LCFI25:
 1225              		.cfi_def_cfa_offset 32
 1226 0004 00AF     		add	r7, sp, #0
 1227              		.cfi_offset 14, -4
 1228              		.cfi_offset 7, -8
 1229              	.LCFI26:
 1230              		.cfi_def_cfa_register 7
 1231 0006 F860     		str	r0, [r7, #12]
 1232 0008 B960     		str	r1, [r7, #8]
 1233 000a 7A60     		str	r2, [r7, #4]
1032:lib/FreeRTOS/queue.c **** signed portBASE_TYPE xReturn;
1033:lib/FreeRTOS/queue.c **** unsigned portBASE_TYPE uxSavedInterruptStatus;
1034:lib/FreeRTOS/queue.c **** 
1035:lib/FreeRTOS/queue.c **** 	configASSERT( pxQueue );
 1234              		.loc 1 1035 0
 1235 000c FB68     		ldr	r3, [r7, #12]
 1236 000e 002B     		cmp	r3, #0
 1237 0010 04D1     		bne	.L81
 1238              		.loc 1 1035 0 is_stmt 0 discriminator 1
 1239              	@ 1035 "lib/FreeRTOS/queue.c" 1
 1240 0012 4FF0BF00 			mov r0, #191								
 1241 0016 80F31188 		msr basepri, r0							
 1242              	
 1243              	@ 0 "" 2
 1244              		.thumb
 1245              	.L82:
 1246              		.loc 1 1035 0 discriminator 2
 1247 001a FEE7     		b	.L82
 1248              	.L81:
1036:lib/FreeRTOS/queue.c **** 	configASSERT( pxTaskWoken );
 1249              		.loc 1 1036 0 is_stmt 1
 1250 001c 7B68     		ldr	r3, [r7, #4]
 1251 001e 002B     		cmp	r3, #0
 1252 0020 04D1     		bne	.L83
 1253              		.loc 1 1036 0 is_stmt 0 discriminator 1
 1254              	@ 1036 "lib/FreeRTOS/queue.c" 1
 1255 0022 4FF0BF00 			mov r0, #191								
 1256 0026 80F31188 		msr basepri, r0							
 1257              	
 1258              	@ 0 "" 2
 1259              		.thumb
 1260              	.L84:
 1261              		.loc 1 1036 0 discriminator 2
 1262 002a FEE7     		b	.L84
 1263              	.L83:
1037:lib/FreeRTOS/queue.c **** 	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) 
 1264              		.loc 1 1037 0 is_stmt 1
 1265 002c BB68     		ldr	r3, [r7, #8]
 1266 002e 002B     		cmp	r3, #0
 1267 0030 03D1     		bne	.L85
 1268              		.loc 1 1037 0 is_stmt 0 discriminator 2
 1269 0032 FB68     		ldr	r3, [r7, #12]
 1270 0034 1B6C     		ldr	r3, [r3, #64]
 1271 0036 002B     		cmp	r3, #0
 1272 0038 02D1     		bne	.L86
 1273              	.L85:
 1274              		.loc 1 1037 0 discriminator 1
 1275 003a 4FF00103 		mov	r3, #1
 1276 003e 01E0     		b	.L87
 1277              	.L86:
 1278              		.loc 1 1037 0 discriminator 3
 1279 0040 4FF00003 		mov	r3, #0
 1280              	.L87:
 1281              		.loc 1 1037 0 discriminator 4
 1282 0044 002B     		cmp	r3, #0
 1283 0046 04D1     		bne	.L88
 1284              		.loc 1 1037 0 discriminator 5
 1285              	@ 1037 "lib/FreeRTOS/queue.c" 1
 1286 0048 4FF0BF00 			mov r0, #191								
 1287 004c 80F31188 		msr basepri, r0							
 1288              	
 1289              	@ 0 "" 2
 1290              		.thumb
 1291              	.L89:
 1292              		.loc 1 1037 0 discriminator 6
 1293 0050 FEE7     		b	.L89
 1294              	.L88:
1038:lib/FreeRTOS/queue.c **** 
1039:lib/FreeRTOS/queue.c **** 	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 1295              		.loc 1 1039 0 is_stmt 1
 1296 0052 4FF00003 		mov	r3, #0
 1297 0056 3B61     		str	r3, [r7, #16]
 1298              	@ 1039 "lib/FreeRTOS/queue.c" 1
 1299 0058 4FF0BF00 			mov r0, #191								
 1300 005c 80F31188 		msr basepri, r0							
 1301              	
 1302              	@ 0 "" 2
1040:lib/FreeRTOS/queue.c **** 	{
1041:lib/FreeRTOS/queue.c **** 		/* We cannot block from an ISR, so check there is data available. */
1042:lib/FreeRTOS/queue.c **** 		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
 1303              		.loc 1 1042 0
 1304              		.thumb
 1305 0060 FB68     		ldr	r3, [r7, #12]
 1306 0062 9B6B     		ldr	r3, [r3, #56]
 1307 0064 002B     		cmp	r3, #0
 1308 0066 2AD0     		beq	.L90
1043:lib/FreeRTOS/queue.c **** 		{
1044:lib/FreeRTOS/queue.c **** 			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );
1045:lib/FreeRTOS/queue.c **** 
1046:lib/FreeRTOS/queue.c **** 			prvCopyDataFromQueue( pxQueue, pvBuffer );
 1309              		.loc 1 1046 0
 1310 0068 F868     		ldr	r0, [r7, #12]
 1311 006a B968     		ldr	r1, [r7, #8]
 1312 006c FFF7FEFF 		bl	prvCopyDataFromQueue
1047:lib/FreeRTOS/queue.c **** 			--( pxQueue->uxMessagesWaiting );
 1313              		.loc 1 1047 0
 1314 0070 FB68     		ldr	r3, [r7, #12]
 1315 0072 9B6B     		ldr	r3, [r3, #56]
 1316 0074 03F1FF32 		add	r2, r3, #-1
 1317 0078 FB68     		ldr	r3, [r7, #12]
 1318 007a 9A63     		str	r2, [r3, #56]
1048:lib/FreeRTOS/queue.c **** 
1049:lib/FreeRTOS/queue.c **** 			/* If the queue is locked we will not modify the event list.  Instead
1050:lib/FreeRTOS/queue.c **** 			we update the lock count so the task that unlocks the queue will know
1051:lib/FreeRTOS/queue.c **** 			that an ISR has removed data while the queue was locked. */
1052:lib/FreeRTOS/queue.c **** 			if( pxQueue->xRxLock == queueUNLOCKED )
 1319              		.loc 1 1052 0
 1320 007c FB68     		ldr	r3, [r7, #12]
 1321 007e 5B6C     		ldr	r3, [r3, #68]
 1322 0080 B3F1FF3F 		cmp	r3, #-1
 1323 0084 11D1     		bne	.L91
1053:lib/FreeRTOS/queue.c **** 			{
1054:lib/FreeRTOS/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 1324              		.loc 1 1054 0
 1325 0086 FB68     		ldr	r3, [r7, #12]
 1326 0088 1B69     		ldr	r3, [r3, #16]
 1327 008a 002B     		cmp	r3, #0
 1328 008c 13D0     		beq	.L92
1055:lib/FreeRTOS/queue.c **** 				{
1056:lib/FreeRTOS/queue.c **** 					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 1329              		.loc 1 1056 0
 1330 008e FB68     		ldr	r3, [r7, #12]
 1331 0090 03F11003 		add	r3, r3, #16
 1332 0094 1846     		mov	r0, r3
 1333 0096 FFF7FEFF 		bl	xTaskRemoveFromEventList
 1334 009a 0346     		mov	r3, r0
 1335 009c 002B     		cmp	r3, #0
 1336 009e 0AD0     		beq	.L92
1057:lib/FreeRTOS/queue.c **** 					{
1058:lib/FreeRTOS/queue.c **** 						/* The task waiting has a higher priority than us so
1059:lib/FreeRTOS/queue.c **** 						force a context switch. */
1060:lib/FreeRTOS/queue.c **** 						*pxTaskWoken = pdTRUE;
 1337              		.loc 1 1060 0
 1338 00a0 7B68     		ldr	r3, [r7, #4]
 1339 00a2 4FF00102 		mov	r2, #1
 1340 00a6 1A60     		str	r2, [r3, #0]
 1341 00a8 05E0     		b	.L92
 1342              	.L91:
1061:lib/FreeRTOS/queue.c **** 					}
1062:lib/FreeRTOS/queue.c **** 				}
1063:lib/FreeRTOS/queue.c **** 			}
1064:lib/FreeRTOS/queue.c **** 			else
1065:lib/FreeRTOS/queue.c **** 			{
1066:lib/FreeRTOS/queue.c **** 				/* Increment the lock count so the task that unlocks the queue
1067:lib/FreeRTOS/queue.c **** 				knows that data was removed while it was locked. */
1068:lib/FreeRTOS/queue.c **** 				++( pxQueue->xRxLock );
 1343              		.loc 1 1068 0
 1344 00aa FB68     		ldr	r3, [r7, #12]
 1345 00ac 5B6C     		ldr	r3, [r3, #68]
 1346 00ae 03F10102 		add	r2, r3, #1
 1347 00b2 FB68     		ldr	r3, [r7, #12]
 1348 00b4 5A64     		str	r2, [r3, #68]
 1349              	.L92:
1069:lib/FreeRTOS/queue.c **** 			}
1070:lib/FreeRTOS/queue.c **** 
1071:lib/FreeRTOS/queue.c **** 			xReturn = pdPASS;
 1350              		.loc 1 1071 0
 1351 00b6 4FF00103 		mov	r3, #1
 1352 00ba 7B61     		str	r3, [r7, #20]
 1353 00bc 02E0     		b	.L93
 1354              	.L90:
1072:lib/FreeRTOS/queue.c **** 		}
1073:lib/FreeRTOS/queue.c **** 		else
1074:lib/FreeRTOS/queue.c **** 		{
1075:lib/FreeRTOS/queue.c **** 			xReturn = pdFAIL;
 1355              		.loc 1 1075 0
 1356 00be 4FF00003 		mov	r3, #0
 1357 00c2 7B61     		str	r3, [r7, #20]
 1358              	.L93:
1076:lib/FreeRTOS/queue.c **** 			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
1077:lib/FreeRTOS/queue.c **** 		}
1078:lib/FreeRTOS/queue.c **** 	}
1079:lib/FreeRTOS/queue.c **** 	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
 1359              		.loc 1 1079 0
 1360              	@ 1079 "lib/FreeRTOS/queue.c" 1
 1361 00c4 4FF00000 			mov r0, #0					
 1362 00c8 80F31188 		msr basepri, r0				
 1363              	
 1364              	@ 0 "" 2
1080:lib/FreeRTOS/queue.c **** 
1081:lib/FreeRTOS/queue.c **** 	return xReturn;
 1365              		.loc 1 1081 0
 1366              		.thumb
 1367 00cc 7B69     		ldr	r3, [r7, #20]
1082:lib/FreeRTOS/queue.c **** }
 1368              		.loc 1 1082 0
 1369 00ce 1846     		mov	r0, r3
 1370 00d0 07F11807 		add	r7, r7, #24
 1371 00d4 BD46     		mov	sp, r7
 1372 00d6 80BD     		pop	{r7, pc}
 1373              		.cfi_endproc
 1374              	.LFE118:
 1376              		.section	.text.uxQueueMessagesWaiting,"ax",%progbits
 1377              		.align	2
 1378              		.global	uxQueueMessagesWaiting
 1379              		.thumb
 1380              		.thumb_func
 1382              	uxQueueMessagesWaiting:
 1383              	.LFB119:
1083:lib/FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
1084:lib/FreeRTOS/queue.c **** 
1085:lib/FreeRTOS/queue.c **** unsigned portBASE_TYPE uxQueueMessagesWaiting( const xQueueHandle pxQueue )
1086:lib/FreeRTOS/queue.c **** {
 1384              		.loc 1 1086 0
 1385              		.cfi_startproc
 1386              		@ args = 0, pretend = 0, frame = 16
 1387              		@ frame_needed = 1, uses_anonymous_args = 0
 1388 0000 80B5     		push	{r7, lr}
 1389              	.LCFI27:
 1390              		.cfi_def_cfa_offset 8
 1391 0002 84B0     		sub	sp, sp, #16
 1392              	.LCFI28:
 1393              		.cfi_def_cfa_offset 24
 1394 0004 00AF     		add	r7, sp, #0
 1395              		.cfi_offset 14, -4
 1396              		.cfi_offset 7, -8
 1397              	.LCFI29:
 1398              		.cfi_def_cfa_register 7
 1399 0006 7860     		str	r0, [r7, #4]
1087:lib/FreeRTOS/queue.c **** unsigned portBASE_TYPE uxReturn;
1088:lib/FreeRTOS/queue.c **** 
1089:lib/FreeRTOS/queue.c **** 	configASSERT( pxQueue );
 1400              		.loc 1 1089 0
 1401 0008 7B68     		ldr	r3, [r7, #4]
 1402 000a 002B     		cmp	r3, #0
 1403 000c 04D1     		bne	.L95
 1404              		.loc 1 1089 0 is_stmt 0 discriminator 1
 1405              	@ 1089 "lib/FreeRTOS/queue.c" 1
 1406 000e 4FF0BF00 			mov r0, #191								
 1407 0012 80F31188 		msr basepri, r0							
 1408              	
 1409              	@ 0 "" 2
 1410              		.thumb
 1411              	.L96:
 1412              		.loc 1 1089 0 discriminator 2
 1413 0016 FEE7     		b	.L96
 1414              	.L95:
1090:lib/FreeRTOS/queue.c **** 
1091:lib/FreeRTOS/queue.c **** 	taskENTER_CRITICAL();
 1415              		.loc 1 1091 0 is_stmt 1
 1416 0018 FFF7FEFF 		bl	vPortEnterCritical
1092:lib/FreeRTOS/queue.c **** 		uxReturn = pxQueue->uxMessagesWaiting;
 1417              		.loc 1 1092 0
 1418 001c 7B68     		ldr	r3, [r7, #4]
 1419 001e 9B6B     		ldr	r3, [r3, #56]
 1420 0020 FB60     		str	r3, [r7, #12]
1093:lib/FreeRTOS/queue.c **** 	taskEXIT_CRITICAL();
 1421              		.loc 1 1093 0
 1422 0022 FFF7FEFF 		bl	vPortExitCritical
1094:lib/FreeRTOS/queue.c **** 
1095:lib/FreeRTOS/queue.c **** 	return uxReturn;
 1423              		.loc 1 1095 0
 1424 0026 FB68     		ldr	r3, [r7, #12]
1096:lib/FreeRTOS/queue.c **** }
 1425              		.loc 1 1096 0
 1426 0028 1846     		mov	r0, r3
 1427 002a 07F11007 		add	r7, r7, #16
 1428 002e BD46     		mov	sp, r7
 1429 0030 80BD     		pop	{r7, pc}
 1430              		.cfi_endproc
 1431              	.LFE119:
 1433 0032 00BF     		.section	.text.uxQueueMessagesWaitingFromISR,"ax",%progbits
 1434              		.align	2
 1435              		.global	uxQueueMessagesWaitingFromISR
 1436              		.thumb
 1437              		.thumb_func
 1439              	uxQueueMessagesWaitingFromISR:
 1440              	.LFB120:
1097:lib/FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
1098:lib/FreeRTOS/queue.c **** 
1099:lib/FreeRTOS/queue.c **** unsigned portBASE_TYPE uxQueueMessagesWaitingFromISR( const xQueueHandle pxQueue )
1100:lib/FreeRTOS/queue.c **** {
 1441              		.loc 1 1100 0
 1442              		.cfi_startproc
 1443              		@ args = 0, pretend = 0, frame = 16
 1444              		@ frame_needed = 1, uses_anonymous_args = 0
 1445              		@ link register save eliminated.
 1446 0000 80B4     		push	{r7}
 1447              	.LCFI30:
 1448              		.cfi_def_cfa_offset 4
 1449 0002 85B0     		sub	sp, sp, #20
 1450              	.LCFI31:
 1451              		.cfi_def_cfa_offset 24
 1452 0004 00AF     		add	r7, sp, #0
 1453              		.cfi_offset 7, -4
 1454              	.LCFI32:
 1455              		.cfi_def_cfa_register 7
 1456 0006 7860     		str	r0, [r7, #4]
1101:lib/FreeRTOS/queue.c **** unsigned portBASE_TYPE uxReturn;
1102:lib/FreeRTOS/queue.c **** 
1103:lib/FreeRTOS/queue.c **** 	configASSERT( pxQueue );
 1457              		.loc 1 1103 0
 1458 0008 7B68     		ldr	r3, [r7, #4]
 1459 000a 002B     		cmp	r3, #0
 1460 000c 04D1     		bne	.L98
 1461              		.loc 1 1103 0 is_stmt 0 discriminator 1
 1462              	@ 1103 "lib/FreeRTOS/queue.c" 1
 1463 000e 4FF0BF00 			mov r0, #191								
 1464 0012 80F31188 		msr basepri, r0							
 1465              	
 1466              	@ 0 "" 2
 1467              		.thumb
 1468              	.L99:
 1469              		.loc 1 1103 0 discriminator 2
 1470 0016 FEE7     		b	.L99
 1471              	.L98:
1104:lib/FreeRTOS/queue.c **** 
1105:lib/FreeRTOS/queue.c **** 	uxReturn = pxQueue->uxMessagesWaiting;
 1472              		.loc 1 1105 0 is_stmt 1
 1473 0018 7B68     		ldr	r3, [r7, #4]
 1474 001a 9B6B     		ldr	r3, [r3, #56]
 1475 001c FB60     		str	r3, [r7, #12]
1106:lib/FreeRTOS/queue.c **** 
1107:lib/FreeRTOS/queue.c **** 	return uxReturn;
 1476              		.loc 1 1107 0
 1477 001e FB68     		ldr	r3, [r7, #12]
1108:lib/FreeRTOS/queue.c **** }
 1478              		.loc 1 1108 0
 1479 0020 1846     		mov	r0, r3
 1480 0022 07F11407 		add	r7, r7, #20
 1481 0026 BD46     		mov	sp, r7
 1482 0028 80BC     		pop	{r7}
 1483 002a 7047     		bx	lr
 1484              		.cfi_endproc
 1485              	.LFE120:
 1487              		.section	.text.vQueueDelete,"ax",%progbits
 1488              		.align	2
 1489              		.global	vQueueDelete
 1490              		.thumb
 1491              		.thumb_func
 1493              	vQueueDelete:
 1494              	.LFB121:
1109:lib/FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
1110:lib/FreeRTOS/queue.c **** 
1111:lib/FreeRTOS/queue.c **** void vQueueDelete( xQueueHandle pxQueue )
1112:lib/FreeRTOS/queue.c **** {
 1495              		.loc 1 1112 0
 1496              		.cfi_startproc
 1497              		@ args = 0, pretend = 0, frame = 8
 1498              		@ frame_needed = 1, uses_anonymous_args = 0
 1499 0000 80B5     		push	{r7, lr}
 1500              	.LCFI33:
 1501              		.cfi_def_cfa_offset 8
 1502 0002 82B0     		sub	sp, sp, #8
 1503              	.LCFI34:
 1504              		.cfi_def_cfa_offset 16
 1505 0004 00AF     		add	r7, sp, #0
 1506              		.cfi_offset 14, -4
 1507              		.cfi_offset 7, -8
 1508              	.LCFI35:
 1509              		.cfi_def_cfa_register 7
 1510 0006 7860     		str	r0, [r7, #4]
1113:lib/FreeRTOS/queue.c **** 	configASSERT( pxQueue );
 1511              		.loc 1 1113 0
 1512 0008 7B68     		ldr	r3, [r7, #4]
 1513 000a 002B     		cmp	r3, #0
 1514 000c 04D1     		bne	.L101
 1515              		.loc 1 1113 0 is_stmt 0 discriminator 1
 1516              	@ 1113 "lib/FreeRTOS/queue.c" 1
 1517 000e 4FF0BF00 			mov r0, #191								
 1518 0012 80F31188 		msr basepri, r0							
 1519              	
 1520              	@ 0 "" 2
 1521              		.thumb
 1522              	.L102:
 1523              		.loc 1 1113 0 discriminator 2
 1524 0016 FEE7     		b	.L102
 1525              	.L101:
1114:lib/FreeRTOS/queue.c **** 
1115:lib/FreeRTOS/queue.c **** 	traceQUEUE_DELETE( pxQueue );
1116:lib/FreeRTOS/queue.c **** 	vQueueUnregisterQueue( pxQueue );
 1526              		.loc 1 1116 0 is_stmt 1
 1527 0018 7868     		ldr	r0, [r7, #4]
 1528 001a FFF7FEFF 		bl	vQueueUnregisterQueue
1117:lib/FreeRTOS/queue.c **** 	vPortFree( pxQueue->pcHead );
 1529              		.loc 1 1117 0
 1530 001e 7B68     		ldr	r3, [r7, #4]
 1531 0020 1B68     		ldr	r3, [r3, #0]
 1532 0022 1846     		mov	r0, r3
 1533 0024 FFF7FEFF 		bl	vPortFree
1118:lib/FreeRTOS/queue.c **** 	vPortFree( pxQueue );
 1534              		.loc 1 1118 0
 1535 0028 7868     		ldr	r0, [r7, #4]
 1536 002a FFF7FEFF 		bl	vPortFree
1119:lib/FreeRTOS/queue.c **** }
 1537              		.loc 1 1119 0
 1538 002e 07F10807 		add	r7, r7, #8
 1539 0032 BD46     		mov	sp, r7
 1540 0034 80BD     		pop	{r7, pc}
 1541              		.cfi_endproc
 1542              	.LFE121:
 1544 0036 00BF     		.section	.text.ucQueueGetQueueNumber,"ax",%progbits
 1545              		.align	2
 1546              		.global	ucQueueGetQueueNumber
 1547              		.thumb
 1548              		.thumb_func
 1550              	ucQueueGetQueueNumber:
 1551              	.LFB122:
1120:lib/FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
1121:lib/FreeRTOS/queue.c **** 
1122:lib/FreeRTOS/queue.c **** #if ( configUSE_TRACE_FACILITY == 1 )
1123:lib/FreeRTOS/queue.c **** 
1124:lib/FreeRTOS/queue.c **** 	unsigned char ucQueueGetQueueNumber( xQueueHandle pxQueue )
1125:lib/FreeRTOS/queue.c **** 	{
 1552              		.loc 1 1125 0
 1553              		.cfi_startproc
 1554              		@ args = 0, pretend = 0, frame = 8
 1555              		@ frame_needed = 1, uses_anonymous_args = 0
 1556              		@ link register save eliminated.
 1557 0000 80B4     		push	{r7}
 1558              	.LCFI36:
 1559              		.cfi_def_cfa_offset 4
 1560 0002 83B0     		sub	sp, sp, #12
 1561              	.LCFI37:
 1562              		.cfi_def_cfa_offset 16
 1563 0004 00AF     		add	r7, sp, #0
 1564              		.cfi_offset 7, -4
 1565              	.LCFI38:
 1566              		.cfi_def_cfa_register 7
 1567 0006 7860     		str	r0, [r7, #4]
1126:lib/FreeRTOS/queue.c **** 		return pxQueue->ucQueueNumber;
 1568              		.loc 1 1126 0
 1569 0008 7B68     		ldr	r3, [r7, #4]
 1570 000a 93F84C30 		ldrb	r3, [r3, #76]	@ zero_extendqisi2
1127:lib/FreeRTOS/queue.c **** 	}
 1571              		.loc 1 1127 0
 1572 000e 1846     		mov	r0, r3
 1573 0010 07F10C07 		add	r7, r7, #12
 1574 0014 BD46     		mov	sp, r7
 1575 0016 80BC     		pop	{r7}
 1576 0018 7047     		bx	lr
 1577              		.cfi_endproc
 1578              	.LFE122:
 1580 001a 00BF     		.section	.text.vQueueSetQueueNumber,"ax",%progbits
 1581              		.align	2
 1582              		.global	vQueueSetQueueNumber
 1583              		.thumb
 1584              		.thumb_func
 1586              	vQueueSetQueueNumber:
 1587              	.LFB123:
1128:lib/FreeRTOS/queue.c **** 
1129:lib/FreeRTOS/queue.c **** #endif
1130:lib/FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
1131:lib/FreeRTOS/queue.c **** 
1132:lib/FreeRTOS/queue.c **** #if ( configUSE_TRACE_FACILITY == 1 )
1133:lib/FreeRTOS/queue.c **** 
1134:lib/FreeRTOS/queue.c **** 	void vQueueSetQueueNumber( xQueueHandle pxQueue, unsigned char ucQueueNumber )
1135:lib/FreeRTOS/queue.c **** 	{
 1588              		.loc 1 1135 0
 1589              		.cfi_startproc
 1590              		@ args = 0, pretend = 0, frame = 8
 1591              		@ frame_needed = 1, uses_anonymous_args = 0
 1592              		@ link register save eliminated.
 1593 0000 80B4     		push	{r7}
 1594              	.LCFI39:
 1595              		.cfi_def_cfa_offset 4
 1596 0002 83B0     		sub	sp, sp, #12
 1597              	.LCFI40:
 1598              		.cfi_def_cfa_offset 16
 1599 0004 00AF     		add	r7, sp, #0
 1600              		.cfi_offset 7, -4
 1601              	.LCFI41:
 1602              		.cfi_def_cfa_register 7
 1603 0006 7860     		str	r0, [r7, #4]
 1604 0008 0B46     		mov	r3, r1
 1605 000a FB70     		strb	r3, [r7, #3]
1136:lib/FreeRTOS/queue.c **** 		pxQueue->ucQueueNumber = ucQueueNumber;
 1606              		.loc 1 1136 0
 1607 000c 7B68     		ldr	r3, [r7, #4]
 1608 000e FA78     		ldrb	r2, [r7, #3]
 1609 0010 83F84C20 		strb	r2, [r3, #76]
1137:lib/FreeRTOS/queue.c **** 	}
 1610              		.loc 1 1137 0
 1611 0014 07F10C07 		add	r7, r7, #12
 1612 0018 BD46     		mov	sp, r7
 1613 001a 80BC     		pop	{r7}
 1614 001c 7047     		bx	lr
 1615              		.cfi_endproc
 1616              	.LFE123:
 1618 001e 00BF     		.section	.text.ucQueueGetQueueType,"ax",%progbits
 1619              		.align	2
 1620              		.global	ucQueueGetQueueType
 1621              		.thumb
 1622              		.thumb_func
 1624              	ucQueueGetQueueType:
 1625              	.LFB124:
1138:lib/FreeRTOS/queue.c **** 
1139:lib/FreeRTOS/queue.c **** #endif
1140:lib/FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
1141:lib/FreeRTOS/queue.c **** 
1142:lib/FreeRTOS/queue.c **** #if ( configUSE_TRACE_FACILITY == 1 )
1143:lib/FreeRTOS/queue.c **** 
1144:lib/FreeRTOS/queue.c **** 	unsigned char ucQueueGetQueueType( xQueueHandle pxQueue )
1145:lib/FreeRTOS/queue.c **** 	{
 1626              		.loc 1 1145 0
 1627              		.cfi_startproc
 1628              		@ args = 0, pretend = 0, frame = 8
 1629              		@ frame_needed = 1, uses_anonymous_args = 0
 1630              		@ link register save eliminated.
 1631 0000 80B4     		push	{r7}
 1632              	.LCFI42:
 1633              		.cfi_def_cfa_offset 4
 1634 0002 83B0     		sub	sp, sp, #12
 1635              	.LCFI43:
 1636              		.cfi_def_cfa_offset 16
 1637 0004 00AF     		add	r7, sp, #0
 1638              		.cfi_offset 7, -4
 1639              	.LCFI44:
 1640              		.cfi_def_cfa_register 7
 1641 0006 7860     		str	r0, [r7, #4]
1146:lib/FreeRTOS/queue.c **** 		return pxQueue->ucQueueType;
 1642              		.loc 1 1146 0
 1643 0008 7B68     		ldr	r3, [r7, #4]
 1644 000a 93F84D30 		ldrb	r3, [r3, #77]	@ zero_extendqisi2
1147:lib/FreeRTOS/queue.c **** 	}
 1645              		.loc 1 1147 0
 1646 000e 1846     		mov	r0, r3
 1647 0010 07F10C07 		add	r7, r7, #12
 1648 0014 BD46     		mov	sp, r7
 1649 0016 80BC     		pop	{r7}
 1650 0018 7047     		bx	lr
 1651              		.cfi_endproc
 1652              	.LFE124:
 1654 001a 00BF     		.section	.text.prvCopyDataToQueue,"ax",%progbits
 1655              		.align	2
 1656              		.thumb
 1657              		.thumb_func
 1659              	prvCopyDataToQueue:
 1660              	.LFB125:
1148:lib/FreeRTOS/queue.c **** 
1149:lib/FreeRTOS/queue.c **** #endif
1150:lib/FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
1151:lib/FreeRTOS/queue.c **** 
1152:lib/FreeRTOS/queue.c **** static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition
1153:lib/FreeRTOS/queue.c **** {
 1661              		.loc 1 1153 0
 1662              		.cfi_startproc
 1663              		@ args = 0, pretend = 0, frame = 16
 1664              		@ frame_needed = 1, uses_anonymous_args = 0
 1665 0000 80B5     		push	{r7, lr}
 1666              	.LCFI45:
 1667              		.cfi_def_cfa_offset 8
 1668 0002 84B0     		sub	sp, sp, #16
 1669              	.LCFI46:
 1670              		.cfi_def_cfa_offset 24
 1671 0004 00AF     		add	r7, sp, #0
 1672              		.cfi_offset 14, -4
 1673              		.cfi_offset 7, -8
 1674              	.LCFI47:
 1675              		.cfi_def_cfa_register 7
 1676 0006 F860     		str	r0, [r7, #12]
 1677 0008 B960     		str	r1, [r7, #8]
 1678 000a 7A60     		str	r2, [r7, #4]
1154:lib/FreeRTOS/queue.c **** 	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
 1679              		.loc 1 1154 0
 1680 000c FB68     		ldr	r3, [r7, #12]
 1681 000e 1B6C     		ldr	r3, [r3, #64]
 1682 0010 002B     		cmp	r3, #0
 1683 0012 0DD1     		bne	.L107
1155:lib/FreeRTOS/queue.c **** 	{
1156:lib/FreeRTOS/queue.c **** 		#if ( configUSE_MUTEXES == 1 )
1157:lib/FreeRTOS/queue.c **** 		{
1158:lib/FreeRTOS/queue.c **** 			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 1684              		.loc 1 1158 0
 1685 0014 FB68     		ldr	r3, [r7, #12]
 1686 0016 1B68     		ldr	r3, [r3, #0]
 1687 0018 002B     		cmp	r3, #0
 1688 001a 48D1     		bne	.L108
1159:lib/FreeRTOS/queue.c **** 			{
1160:lib/FreeRTOS/queue.c **** 				/* The mutex is no longer being held. */
1161:lib/FreeRTOS/queue.c **** 				vTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
 1689              		.loc 1 1161 0
 1690 001c FB68     		ldr	r3, [r7, #12]
 1691 001e 5B68     		ldr	r3, [r3, #4]
 1692 0020 1846     		mov	r0, r3
 1693 0022 FFF7FEFF 		bl	vTaskPriorityDisinherit
1162:lib/FreeRTOS/queue.c **** 				pxQueue->pxMutexHolder = NULL;
 1694              		.loc 1 1162 0
 1695 0026 FB68     		ldr	r3, [r7, #12]
 1696 0028 4FF00002 		mov	r2, #0
 1697 002c 5A60     		str	r2, [r3, #4]
 1698 002e 3EE0     		b	.L108
 1699              	.L107:
1163:lib/FreeRTOS/queue.c **** 			}
1164:lib/FreeRTOS/queue.c **** 		}
1165:lib/FreeRTOS/queue.c **** 		#endif
1166:lib/FreeRTOS/queue.c **** 	}
1167:lib/FreeRTOS/queue.c **** 	else if( xPosition == queueSEND_TO_BACK )
 1700              		.loc 1 1167 0
 1701 0030 7B68     		ldr	r3, [r7, #4]
 1702 0032 002B     		cmp	r3, #0
 1703 0034 1AD1     		bne	.L109
1168:lib/FreeRTOS/queue.c **** 	{
1169:lib/FreeRTOS/queue.c **** 		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
 1704              		.loc 1 1169 0
 1705 0036 FB68     		ldr	r3, [r7, #12]
 1706 0038 9A68     		ldr	r2, [r3, #8]
 1707 003a FB68     		ldr	r3, [r7, #12]
 1708 003c 1B6C     		ldr	r3, [r3, #64]
 1709 003e 1046     		mov	r0, r2
 1710 0040 B968     		ldr	r1, [r7, #8]
 1711 0042 1A46     		mov	r2, r3
 1712 0044 FFF7FEFF 		bl	memcpy
1170:lib/FreeRTOS/queue.c **** 		pxQueue->pcWriteTo += pxQueue->uxItemSize;
 1713              		.loc 1 1170 0
 1714 0048 FB68     		ldr	r3, [r7, #12]
 1715 004a 9A68     		ldr	r2, [r3, #8]
 1716 004c FB68     		ldr	r3, [r7, #12]
 1717 004e 1B6C     		ldr	r3, [r3, #64]
 1718 0050 D218     		adds	r2, r2, r3
 1719 0052 FB68     		ldr	r3, [r7, #12]
 1720 0054 9A60     		str	r2, [r3, #8]
1171:lib/FreeRTOS/queue.c **** 		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
 1721              		.loc 1 1171 0
 1722 0056 FB68     		ldr	r3, [r7, #12]
 1723 0058 9A68     		ldr	r2, [r3, #8]
 1724 005a FB68     		ldr	r3, [r7, #12]
 1725 005c 5B68     		ldr	r3, [r3, #4]
 1726 005e 9A42     		cmp	r2, r3
 1727 0060 25D3     		bcc	.L108
1172:lib/FreeRTOS/queue.c **** 		{
1173:lib/FreeRTOS/queue.c **** 			pxQueue->pcWriteTo = pxQueue->pcHead;
 1728              		.loc 1 1173 0
 1729 0062 FB68     		ldr	r3, [r7, #12]
 1730 0064 1A68     		ldr	r2, [r3, #0]
 1731 0066 FB68     		ldr	r3, [r7, #12]
 1732 0068 9A60     		str	r2, [r3, #8]
 1733 006a 20E0     		b	.L108
 1734              	.L109:
1174:lib/FreeRTOS/queue.c **** 		}
1175:lib/FreeRTOS/queue.c **** 	}
1176:lib/FreeRTOS/queue.c **** 	else
1177:lib/FreeRTOS/queue.c **** 	{
1178:lib/FreeRTOS/queue.c **** 		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
 1735              		.loc 1 1178 0
 1736 006c FB68     		ldr	r3, [r7, #12]
 1737 006e DA68     		ldr	r2, [r3, #12]
 1738 0070 FB68     		ldr	r3, [r7, #12]
 1739 0072 1B6C     		ldr	r3, [r3, #64]
 1740 0074 1046     		mov	r0, r2
 1741 0076 B968     		ldr	r1, [r7, #8]
 1742 0078 1A46     		mov	r2, r3
 1743 007a FFF7FEFF 		bl	memcpy
1179:lib/FreeRTOS/queue.c **** 		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
 1744              		.loc 1 1179 0
 1745 007e FB68     		ldr	r3, [r7, #12]
 1746 0080 DA68     		ldr	r2, [r3, #12]
 1747 0082 FB68     		ldr	r3, [r7, #12]
 1748 0084 1B6C     		ldr	r3, [r3, #64]
 1749 0086 C3F10003 		rsb	r3, r3, #0
 1750 008a D218     		adds	r2, r2, r3
 1751 008c FB68     		ldr	r3, [r7, #12]
 1752 008e DA60     		str	r2, [r3, #12]
1180:lib/FreeRTOS/queue.c **** 		if( pxQueue->pcReadFrom < pxQueue->pcHead )
 1753              		.loc 1 1180 0
 1754 0090 FB68     		ldr	r3, [r7, #12]
 1755 0092 DA68     		ldr	r2, [r3, #12]
 1756 0094 FB68     		ldr	r3, [r7, #12]
 1757 0096 1B68     		ldr	r3, [r3, #0]
 1758 0098 9A42     		cmp	r2, r3
 1759 009a 08D2     		bcs	.L108
1181:lib/FreeRTOS/queue.c **** 		{
1182:lib/FreeRTOS/queue.c **** 			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
 1760              		.loc 1 1182 0
 1761 009c FB68     		ldr	r3, [r7, #12]
 1762 009e 5A68     		ldr	r2, [r3, #4]
 1763 00a0 FB68     		ldr	r3, [r7, #12]
 1764 00a2 1B6C     		ldr	r3, [r3, #64]
 1765 00a4 C3F10003 		rsb	r3, r3, #0
 1766 00a8 D218     		adds	r2, r2, r3
 1767 00aa FB68     		ldr	r3, [r7, #12]
 1768 00ac DA60     		str	r2, [r3, #12]
 1769              	.L108:
1183:lib/FreeRTOS/queue.c **** 		}
1184:lib/FreeRTOS/queue.c **** 	}
1185:lib/FreeRTOS/queue.c **** 
1186:lib/FreeRTOS/queue.c **** 	++( pxQueue->uxMessagesWaiting );
 1770              		.loc 1 1186 0
 1771 00ae FB68     		ldr	r3, [r7, #12]
 1772 00b0 9B6B     		ldr	r3, [r3, #56]
 1773 00b2 03F10102 		add	r2, r3, #1
 1774 00b6 FB68     		ldr	r3, [r7, #12]
 1775 00b8 9A63     		str	r2, [r3, #56]
1187:lib/FreeRTOS/queue.c **** }
 1776              		.loc 1 1187 0
 1777 00ba 07F11007 		add	r7, r7, #16
 1778 00be BD46     		mov	sp, r7
 1779 00c0 80BD     		pop	{r7, pc}
 1780              		.cfi_endproc
 1781              	.LFE125:
 1783 00c2 00BF     		.section	.text.prvCopyDataFromQueue,"ax",%progbits
 1784              		.align	2
 1785              		.thumb
 1786              		.thumb_func
 1788              	prvCopyDataFromQueue:
 1789              	.LFB126:
1188:lib/FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
1189:lib/FreeRTOS/queue.c **** 
1190:lib/FreeRTOS/queue.c **** static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
1191:lib/FreeRTOS/queue.c **** {
 1790              		.loc 1 1191 0
 1791              		.cfi_startproc
 1792              		@ args = 0, pretend = 0, frame = 8
 1793              		@ frame_needed = 1, uses_anonymous_args = 0
 1794 0000 80B5     		push	{r7, lr}
 1795              	.LCFI48:
 1796              		.cfi_def_cfa_offset 8
 1797 0002 82B0     		sub	sp, sp, #8
 1798              	.LCFI49:
 1799              		.cfi_def_cfa_offset 16
 1800 0004 00AF     		add	r7, sp, #0
 1801              		.cfi_offset 14, -4
 1802              		.cfi_offset 7, -8
 1803              	.LCFI50:
 1804              		.cfi_def_cfa_register 7
 1805 0006 7860     		str	r0, [r7, #4]
 1806 0008 3960     		str	r1, [r7, #0]
1192:lib/FreeRTOS/queue.c **** 	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
 1807              		.loc 1 1192 0
 1808 000a 7B68     		ldr	r3, [r7, #4]
 1809 000c 1B68     		ldr	r3, [r3, #0]
 1810 000e 002B     		cmp	r3, #0
 1811 0010 19D0     		beq	.L110
1193:lib/FreeRTOS/queue.c **** 	{
1194:lib/FreeRTOS/queue.c **** 		pxQueue->pcReadFrom += pxQueue->uxItemSize;
 1812              		.loc 1 1194 0
 1813 0012 7B68     		ldr	r3, [r7, #4]
 1814 0014 DA68     		ldr	r2, [r3, #12]
 1815 0016 7B68     		ldr	r3, [r7, #4]
 1816 0018 1B6C     		ldr	r3, [r3, #64]
 1817 001a D218     		adds	r2, r2, r3
 1818 001c 7B68     		ldr	r3, [r7, #4]
 1819 001e DA60     		str	r2, [r3, #12]
1195:lib/FreeRTOS/queue.c **** 		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
 1820              		.loc 1 1195 0
 1821 0020 7B68     		ldr	r3, [r7, #4]
 1822 0022 DA68     		ldr	r2, [r3, #12]
 1823 0024 7B68     		ldr	r3, [r7, #4]
 1824 0026 5B68     		ldr	r3, [r3, #4]
 1825 0028 9A42     		cmp	r2, r3
 1826 002a 03D3     		bcc	.L112
1196:lib/FreeRTOS/queue.c **** 		{
1197:lib/FreeRTOS/queue.c **** 			pxQueue->pcReadFrom = pxQueue->pcHead;
 1827              		.loc 1 1197 0
 1828 002c 7B68     		ldr	r3, [r7, #4]
 1829 002e 1A68     		ldr	r2, [r3, #0]
 1830 0030 7B68     		ldr	r3, [r7, #4]
 1831 0032 DA60     		str	r2, [r3, #12]
 1832              	.L112:
1198:lib/FreeRTOS/queue.c **** 		}
1199:lib/FreeRTOS/queue.c **** 		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
 1833              		.loc 1 1199 0
 1834 0034 7B68     		ldr	r3, [r7, #4]
 1835 0036 DA68     		ldr	r2, [r3, #12]
 1836 0038 7B68     		ldr	r3, [r7, #4]
 1837 003a 1B6C     		ldr	r3, [r3, #64]
 1838 003c 3868     		ldr	r0, [r7, #0]
 1839 003e 1146     		mov	r1, r2
 1840 0040 1A46     		mov	r2, r3
 1841 0042 FFF7FEFF 		bl	memcpy
 1842              	.L110:
1200:lib/FreeRTOS/queue.c **** 	}
1201:lib/FreeRTOS/queue.c **** }
 1843              		.loc 1 1201 0
 1844 0046 07F10807 		add	r7, r7, #8
 1845 004a BD46     		mov	sp, r7
 1846 004c 80BD     		pop	{r7, pc}
 1847              		.cfi_endproc
 1848              	.LFE126:
 1850 004e 00BF     		.section	.text.prvUnlockQueue,"ax",%progbits
 1851              		.align	2
 1852              		.thumb
 1853              		.thumb_func
 1855              	prvUnlockQueue:
 1856              	.LFB127:
1202:lib/FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
1203:lib/FreeRTOS/queue.c **** 
1204:lib/FreeRTOS/queue.c **** static void prvUnlockQueue( xQueueHandle pxQueue )
1205:lib/FreeRTOS/queue.c **** {
 1857              		.loc 1 1205 0
 1858              		.cfi_startproc
 1859              		@ args = 0, pretend = 0, frame = 8
 1860              		@ frame_needed = 1, uses_anonymous_args = 0
 1861 0000 80B5     		push	{r7, lr}
 1862              	.LCFI51:
 1863              		.cfi_def_cfa_offset 8
 1864 0002 82B0     		sub	sp, sp, #8
 1865              	.LCFI52:
 1866              		.cfi_def_cfa_offset 16
 1867 0004 00AF     		add	r7, sp, #0
 1868              		.cfi_offset 14, -4
 1869              		.cfi_offset 7, -8
 1870              	.LCFI53:
 1871              		.cfi_def_cfa_register 7
 1872 0006 7860     		str	r0, [r7, #4]
1206:lib/FreeRTOS/queue.c **** 	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED. */
1207:lib/FreeRTOS/queue.c **** 
1208:lib/FreeRTOS/queue.c **** 	/* The lock counts contains the number of extra data items placed or
1209:lib/FreeRTOS/queue.c **** 	removed from the queue while the queue was locked.  When a queue is
1210:lib/FreeRTOS/queue.c **** 	locked items can be added or removed, but the event lists cannot be
1211:lib/FreeRTOS/queue.c **** 	updated. */
1212:lib/FreeRTOS/queue.c **** 	taskENTER_CRITICAL();
 1873              		.loc 1 1212 0
 1874 0008 FFF7FEFF 		bl	vPortEnterCritical
1213:lib/FreeRTOS/queue.c **** 	{
1214:lib/FreeRTOS/queue.c **** 		/* See if data was added to the queue while it was locked. */
1215:lib/FreeRTOS/queue.c **** 		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
 1875              		.loc 1 1215 0
 1876 000c 14E0     		b	.L114
 1877              	.L118:
1216:lib/FreeRTOS/queue.c **** 		{
1217:lib/FreeRTOS/queue.c **** 			/* Data was posted while the queue was locked.  Are any tasks
1218:lib/FreeRTOS/queue.c **** 			blocked waiting for data to become available? */
1219:lib/FreeRTOS/queue.c **** 			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 1878              		.loc 1 1219 0
 1879 000e 7B68     		ldr	r3, [r7, #4]
 1880 0010 5B6A     		ldr	r3, [r3, #36]
 1881 0012 002B     		cmp	r3, #0
 1882 0014 15D0     		beq	.L124
1220:lib/FreeRTOS/queue.c **** 			{
1221:lib/FreeRTOS/queue.c **** 				/* Tasks that are removed from the event list will get added to
1222:lib/FreeRTOS/queue.c **** 				the pending ready list as the scheduler is still suspended. */
1223:lib/FreeRTOS/queue.c **** 				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 1883              		.loc 1 1223 0
 1884 0016 7B68     		ldr	r3, [r7, #4]
 1885 0018 03F12403 		add	r3, r3, #36
 1886 001c 1846     		mov	r0, r3
 1887 001e FFF7FEFF 		bl	xTaskRemoveFromEventList
 1888 0022 0346     		mov	r3, r0
 1889 0024 002B     		cmp	r3, #0
 1890 0026 01D0     		beq	.L116
1224:lib/FreeRTOS/queue.c **** 				{
1225:lib/FreeRTOS/queue.c **** 					/* The task waiting has a higher priority so record that a
1226:lib/FreeRTOS/queue.c **** 					context	switch is required. */
1227:lib/FreeRTOS/queue.c **** 					vTaskMissedYield();
 1891              		.loc 1 1227 0
 1892 0028 FFF7FEFF 		bl	vTaskMissedYield
 1893              	.L116:
1228:lib/FreeRTOS/queue.c **** 				}
1229:lib/FreeRTOS/queue.c **** 
1230:lib/FreeRTOS/queue.c **** 				--( pxQueue->xTxLock );
 1894              		.loc 1 1230 0
 1895 002c 7B68     		ldr	r3, [r7, #4]
 1896 002e 9B6C     		ldr	r3, [r3, #72]
 1897 0030 03F1FF32 		add	r2, r3, #-1
 1898 0034 7B68     		ldr	r3, [r7, #4]
 1899 0036 9A64     		str	r2, [r3, #72]
 1900              	.L114:
1215:lib/FreeRTOS/queue.c **** 		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
 1901              		.loc 1 1215 0 discriminator 1
 1902 0038 7B68     		ldr	r3, [r7, #4]
 1903 003a 9B6C     		ldr	r3, [r3, #72]
 1904 003c 002B     		cmp	r3, #0
 1905 003e E6DC     		bgt	.L118
 1906 0040 00E0     		b	.L117
 1907              	.L124:
1231:lib/FreeRTOS/queue.c **** 			}
1232:lib/FreeRTOS/queue.c **** 			else
1233:lib/FreeRTOS/queue.c **** 			{
1234:lib/FreeRTOS/queue.c **** 				break;
 1908              		.loc 1 1234 0
 1909 0042 00BF     		nop
 1910              	.L117:
1235:lib/FreeRTOS/queue.c **** 			}
1236:lib/FreeRTOS/queue.c **** 		}
1237:lib/FreeRTOS/queue.c **** 
1238:lib/FreeRTOS/queue.c **** 		pxQueue->xTxLock = queueUNLOCKED;
 1911              		.loc 1 1238 0
 1912 0044 7B68     		ldr	r3, [r7, #4]
 1913 0046 4FF0FF32 		mov	r2, #-1
 1914 004a 9A64     		str	r2, [r3, #72]
1239:lib/FreeRTOS/queue.c **** 	}
1240:lib/FreeRTOS/queue.c **** 	taskEXIT_CRITICAL();
 1915              		.loc 1 1240 0
 1916 004c FFF7FEFF 		bl	vPortExitCritical
1241:lib/FreeRTOS/queue.c **** 
1242:lib/FreeRTOS/queue.c **** 	/* Do the same for the Rx lock. */
1243:lib/FreeRTOS/queue.c **** 	taskENTER_CRITICAL();
 1917              		.loc 1 1243 0
 1918 0050 FFF7FEFF 		bl	vPortEnterCritical
1244:lib/FreeRTOS/queue.c **** 	{
1245:lib/FreeRTOS/queue.c **** 		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
 1919              		.loc 1 1245 0
 1920 0054 14E0     		b	.L119
 1921              	.L123:
1246:lib/FreeRTOS/queue.c **** 		{
1247:lib/FreeRTOS/queue.c **** 			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 1922              		.loc 1 1247 0
 1923 0056 7B68     		ldr	r3, [r7, #4]
 1924 0058 1B69     		ldr	r3, [r3, #16]
 1925 005a 002B     		cmp	r3, #0
 1926 005c 15D0     		beq	.L125
1248:lib/FreeRTOS/queue.c **** 			{
1249:lib/FreeRTOS/queue.c **** 				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 1927              		.loc 1 1249 0
 1928 005e 7B68     		ldr	r3, [r7, #4]
 1929 0060 03F11003 		add	r3, r3, #16
 1930 0064 1846     		mov	r0, r3
 1931 0066 FFF7FEFF 		bl	xTaskRemoveFromEventList
 1932 006a 0346     		mov	r3, r0
 1933 006c 002B     		cmp	r3, #0
 1934 006e 01D0     		beq	.L121
1250:lib/FreeRTOS/queue.c **** 				{
1251:lib/FreeRTOS/queue.c **** 					vTaskMissedYield();
 1935              		.loc 1 1251 0
 1936 0070 FFF7FEFF 		bl	vTaskMissedYield
 1937              	.L121:
1252:lib/FreeRTOS/queue.c **** 				}
1253:lib/FreeRTOS/queue.c **** 
1254:lib/FreeRTOS/queue.c **** 				--( pxQueue->xRxLock );
 1938              		.loc 1 1254 0
 1939 0074 7B68     		ldr	r3, [r7, #4]
 1940 0076 5B6C     		ldr	r3, [r3, #68]
 1941 0078 03F1FF32 		add	r2, r3, #-1
 1942 007c 7B68     		ldr	r3, [r7, #4]
 1943 007e 5A64     		str	r2, [r3, #68]
 1944              	.L119:
1245:lib/FreeRTOS/queue.c **** 		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
 1945              		.loc 1 1245 0 discriminator 1
 1946 0080 7B68     		ldr	r3, [r7, #4]
 1947 0082 5B6C     		ldr	r3, [r3, #68]
 1948 0084 002B     		cmp	r3, #0
 1949 0086 E6DC     		bgt	.L123
 1950 0088 00E0     		b	.L122
 1951              	.L125:
1255:lib/FreeRTOS/queue.c **** 			}
1256:lib/FreeRTOS/queue.c **** 			else
1257:lib/FreeRTOS/queue.c **** 			{
1258:lib/FreeRTOS/queue.c **** 				break;
 1952              		.loc 1 1258 0
 1953 008a 00BF     		nop
 1954              	.L122:
1259:lib/FreeRTOS/queue.c **** 			}
1260:lib/FreeRTOS/queue.c **** 		}
1261:lib/FreeRTOS/queue.c **** 
1262:lib/FreeRTOS/queue.c **** 		pxQueue->xRxLock = queueUNLOCKED;
 1955              		.loc 1 1262 0
 1956 008c 7B68     		ldr	r3, [r7, #4]
 1957 008e 4FF0FF32 		mov	r2, #-1
 1958 0092 5A64     		str	r2, [r3, #68]
1263:lib/FreeRTOS/queue.c **** 	}
1264:lib/FreeRTOS/queue.c **** 	taskEXIT_CRITICAL();
 1959              		.loc 1 1264 0
 1960 0094 FFF7FEFF 		bl	vPortExitCritical
1265:lib/FreeRTOS/queue.c **** }
 1961              		.loc 1 1265 0
 1962 0098 07F10807 		add	r7, r7, #8
 1963 009c BD46     		mov	sp, r7
 1964 009e 80BD     		pop	{r7, pc}
 1965              		.cfi_endproc
 1966              	.LFE127:
 1968              		.section	.text.prvIsQueueEmpty,"ax",%progbits
 1969              		.align	2
 1970              		.thumb
 1971              		.thumb_func
 1973              	prvIsQueueEmpty:
 1974              	.LFB128:
1266:lib/FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
1267:lib/FreeRTOS/queue.c **** 
1268:lib/FreeRTOS/queue.c **** static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
1269:lib/FreeRTOS/queue.c **** {
 1975              		.loc 1 1269 0
 1976              		.cfi_startproc
 1977              		@ args = 0, pretend = 0, frame = 16
 1978              		@ frame_needed = 1, uses_anonymous_args = 0
 1979 0000 80B5     		push	{r7, lr}
 1980              	.LCFI54:
 1981              		.cfi_def_cfa_offset 8
 1982 0002 84B0     		sub	sp, sp, #16
 1983              	.LCFI55:
 1984              		.cfi_def_cfa_offset 24
 1985 0004 00AF     		add	r7, sp, #0
 1986              		.cfi_offset 14, -4
 1987              		.cfi_offset 7, -8
 1988              	.LCFI56:
 1989              		.cfi_def_cfa_register 7
 1990 0006 7860     		str	r0, [r7, #4]
1270:lib/FreeRTOS/queue.c **** signed portBASE_TYPE xReturn;
1271:lib/FreeRTOS/queue.c **** 
1272:lib/FreeRTOS/queue.c **** 	taskENTER_CRITICAL();
 1991              		.loc 1 1272 0
 1992 0008 FFF7FEFF 		bl	vPortEnterCritical
1273:lib/FreeRTOS/queue.c **** 		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
 1993              		.loc 1 1273 0
 1994 000c 7B68     		ldr	r3, [r7, #4]
 1995 000e 9B6B     		ldr	r3, [r3, #56]
 1996 0010 002B     		cmp	r3, #0
 1997 0012 14BF     		ite	ne
 1998 0014 0023     		movne	r3, #0
 1999 0016 0123     		moveq	r3, #1
 2000 0018 FB60     		str	r3, [r7, #12]
1274:lib/FreeRTOS/queue.c **** 	taskEXIT_CRITICAL();
 2001              		.loc 1 1274 0
 2002 001a FFF7FEFF 		bl	vPortExitCritical
1275:lib/FreeRTOS/queue.c **** 
1276:lib/FreeRTOS/queue.c **** 	return xReturn;
 2003              		.loc 1 1276 0
 2004 001e FB68     		ldr	r3, [r7, #12]
1277:lib/FreeRTOS/queue.c **** }
 2005              		.loc 1 1277 0
 2006 0020 1846     		mov	r0, r3
 2007 0022 07F11007 		add	r7, r7, #16
 2008 0026 BD46     		mov	sp, r7
 2009 0028 80BD     		pop	{r7, pc}
 2010              		.cfi_endproc
 2011              	.LFE128:
 2013 002a 00BF     		.section	.text.xQueueIsQueueEmptyFromISR,"ax",%progbits
 2014              		.align	2
 2015              		.global	xQueueIsQueueEmptyFromISR
 2016              		.thumb
 2017              		.thumb_func
 2019              	xQueueIsQueueEmptyFromISR:
 2020              	.LFB129:
1278:lib/FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
1279:lib/FreeRTOS/queue.c **** 
1280:lib/FreeRTOS/queue.c **** signed portBASE_TYPE xQueueIsQueueEmptyFromISR( const xQueueHandle pxQueue )
1281:lib/FreeRTOS/queue.c **** {
 2021              		.loc 1 1281 0
 2022              		.cfi_startproc
 2023              		@ args = 0, pretend = 0, frame = 16
 2024              		@ frame_needed = 1, uses_anonymous_args = 0
 2025              		@ link register save eliminated.
 2026 0000 80B4     		push	{r7}
 2027              	.LCFI57:
 2028              		.cfi_def_cfa_offset 4
 2029 0002 85B0     		sub	sp, sp, #20
 2030              	.LCFI58:
 2031              		.cfi_def_cfa_offset 24
 2032 0004 00AF     		add	r7, sp, #0
 2033              		.cfi_offset 7, -4
 2034              	.LCFI59:
 2035              		.cfi_def_cfa_register 7
 2036 0006 7860     		str	r0, [r7, #4]
1282:lib/FreeRTOS/queue.c **** signed portBASE_TYPE xReturn;
1283:lib/FreeRTOS/queue.c **** 
1284:lib/FreeRTOS/queue.c **** 	configASSERT( pxQueue );
 2037              		.loc 1 1284 0
 2038 0008 7B68     		ldr	r3, [r7, #4]
 2039 000a 002B     		cmp	r3, #0
 2040 000c 04D1     		bne	.L128
 2041              		.loc 1 1284 0 is_stmt 0 discriminator 1
 2042              	@ 1284 "lib/FreeRTOS/queue.c" 1
 2043 000e 4FF0BF00 			mov r0, #191								
 2044 0012 80F31188 		msr basepri, r0							
 2045              	
 2046              	@ 0 "" 2
 2047              		.thumb
 2048              	.L129:
 2049              		.loc 1 1284 0 discriminator 2
 2050 0016 FEE7     		b	.L129
 2051              	.L128:
1285:lib/FreeRTOS/queue.c **** 	xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
 2052              		.loc 1 1285 0 is_stmt 1
 2053 0018 7B68     		ldr	r3, [r7, #4]
 2054 001a 9B6B     		ldr	r3, [r3, #56]
 2055 001c 002B     		cmp	r3, #0
 2056 001e 14BF     		ite	ne
 2057 0020 0023     		movne	r3, #0
 2058 0022 0123     		moveq	r3, #1
 2059 0024 FB60     		str	r3, [r7, #12]
1286:lib/FreeRTOS/queue.c **** 
1287:lib/FreeRTOS/queue.c **** 	return xReturn;
 2060              		.loc 1 1287 0
 2061 0026 FB68     		ldr	r3, [r7, #12]
1288:lib/FreeRTOS/queue.c **** }
 2062              		.loc 1 1288 0
 2063 0028 1846     		mov	r0, r3
 2064 002a 07F11407 		add	r7, r7, #20
 2065 002e BD46     		mov	sp, r7
 2066 0030 80BC     		pop	{r7}
 2067 0032 7047     		bx	lr
 2068              		.cfi_endproc
 2069              	.LFE129:
 2071              		.section	.text.prvIsQueueFull,"ax",%progbits
 2072              		.align	2
 2073              		.thumb
 2074              		.thumb_func
 2076              	prvIsQueueFull:
 2077              	.LFB130:
1289:lib/FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
1290:lib/FreeRTOS/queue.c **** 
1291:lib/FreeRTOS/queue.c **** static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
1292:lib/FreeRTOS/queue.c **** {
 2078              		.loc 1 1292 0
 2079              		.cfi_startproc
 2080              		@ args = 0, pretend = 0, frame = 16
 2081              		@ frame_needed = 1, uses_anonymous_args = 0
 2082 0000 80B5     		push	{r7, lr}
 2083              	.LCFI60:
 2084              		.cfi_def_cfa_offset 8
 2085 0002 84B0     		sub	sp, sp, #16
 2086              	.LCFI61:
 2087              		.cfi_def_cfa_offset 24
 2088 0004 00AF     		add	r7, sp, #0
 2089              		.cfi_offset 14, -4
 2090              		.cfi_offset 7, -8
 2091              	.LCFI62:
 2092              		.cfi_def_cfa_register 7
 2093 0006 7860     		str	r0, [r7, #4]
1293:lib/FreeRTOS/queue.c **** signed portBASE_TYPE xReturn;
1294:lib/FreeRTOS/queue.c **** 
1295:lib/FreeRTOS/queue.c **** 	taskENTER_CRITICAL();
 2094              		.loc 1 1295 0
 2095 0008 FFF7FEFF 		bl	vPortEnterCritical
1296:lib/FreeRTOS/queue.c **** 		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
 2096              		.loc 1 1296 0
 2097 000c 7B68     		ldr	r3, [r7, #4]
 2098 000e 9A6B     		ldr	r2, [r3, #56]
 2099 0010 7B68     		ldr	r3, [r7, #4]
 2100 0012 DB6B     		ldr	r3, [r3, #60]
 2101 0014 9A42     		cmp	r2, r3
 2102 0016 14BF     		ite	ne
 2103 0018 0023     		movne	r3, #0
 2104 001a 0123     		moveq	r3, #1
 2105 001c FB60     		str	r3, [r7, #12]
1297:lib/FreeRTOS/queue.c **** 	taskEXIT_CRITICAL();
 2106              		.loc 1 1297 0
 2107 001e FFF7FEFF 		bl	vPortExitCritical
1298:lib/FreeRTOS/queue.c **** 
1299:lib/FreeRTOS/queue.c **** 	return xReturn;
 2108              		.loc 1 1299 0
 2109 0022 FB68     		ldr	r3, [r7, #12]
1300:lib/FreeRTOS/queue.c **** }
 2110              		.loc 1 1300 0
 2111 0024 1846     		mov	r0, r3
 2112 0026 07F11007 		add	r7, r7, #16
 2113 002a BD46     		mov	sp, r7
 2114 002c 80BD     		pop	{r7, pc}
 2115              		.cfi_endproc
 2116              	.LFE130:
 2118 002e 00BF     		.section	.text.xQueueIsQueueFullFromISR,"ax",%progbits
 2119              		.align	2
 2120              		.global	xQueueIsQueueFullFromISR
 2121              		.thumb
 2122              		.thumb_func
 2124              	xQueueIsQueueFullFromISR:
 2125              	.LFB131:
1301:lib/FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
1302:lib/FreeRTOS/queue.c **** 
1303:lib/FreeRTOS/queue.c **** signed portBASE_TYPE xQueueIsQueueFullFromISR( const xQueueHandle pxQueue )
1304:lib/FreeRTOS/queue.c **** {
 2126              		.loc 1 1304 0
 2127              		.cfi_startproc
 2128              		@ args = 0, pretend = 0, frame = 16
 2129              		@ frame_needed = 1, uses_anonymous_args = 0
 2130              		@ link register save eliminated.
 2131 0000 80B4     		push	{r7}
 2132              	.LCFI63:
 2133              		.cfi_def_cfa_offset 4
 2134 0002 85B0     		sub	sp, sp, #20
 2135              	.LCFI64:
 2136              		.cfi_def_cfa_offset 24
 2137 0004 00AF     		add	r7, sp, #0
 2138              		.cfi_offset 7, -4
 2139              	.LCFI65:
 2140              		.cfi_def_cfa_register 7
 2141 0006 7860     		str	r0, [r7, #4]
1305:lib/FreeRTOS/queue.c **** signed portBASE_TYPE xReturn;
1306:lib/FreeRTOS/queue.c **** 
1307:lib/FreeRTOS/queue.c **** 	configASSERT( pxQueue );
 2142              		.loc 1 1307 0
 2143 0008 7B68     		ldr	r3, [r7, #4]
 2144 000a 002B     		cmp	r3, #0
 2145 000c 04D1     		bne	.L132
 2146              		.loc 1 1307 0 is_stmt 0 discriminator 1
 2147              	@ 1307 "lib/FreeRTOS/queue.c" 1
 2148 000e 4FF0BF00 			mov r0, #191								
 2149 0012 80F31188 		msr basepri, r0							
 2150              	
 2151              	@ 0 "" 2
 2152              		.thumb
 2153              	.L133:
 2154              		.loc 1 1307 0 discriminator 2
 2155 0016 FEE7     		b	.L133
 2156              	.L132:
1308:lib/FreeRTOS/queue.c **** 	xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
 2157              		.loc 1 1308 0 is_stmt 1
 2158 0018 7B68     		ldr	r3, [r7, #4]
 2159 001a 9A6B     		ldr	r2, [r3, #56]
 2160 001c 7B68     		ldr	r3, [r7, #4]
 2161 001e DB6B     		ldr	r3, [r3, #60]
 2162 0020 9A42     		cmp	r2, r3
 2163 0022 14BF     		ite	ne
 2164 0024 0023     		movne	r3, #0
 2165 0026 0123     		moveq	r3, #1
 2166 0028 FB60     		str	r3, [r7, #12]
1309:lib/FreeRTOS/queue.c **** 
1310:lib/FreeRTOS/queue.c **** 	return xReturn;
 2167              		.loc 1 1310 0
 2168 002a FB68     		ldr	r3, [r7, #12]
1311:lib/FreeRTOS/queue.c **** }
 2169              		.loc 1 1311 0
 2170 002c 1846     		mov	r0, r3
 2171 002e 07F11407 		add	r7, r7, #20
 2172 0032 BD46     		mov	sp, r7
 2173 0034 80BC     		pop	{r7}
 2174 0036 7047     		bx	lr
 2175              		.cfi_endproc
 2176              	.LFE131:
 2178              		.section	.text.vQueueAddToRegistry,"ax",%progbits
 2179              		.align	2
 2180              		.global	vQueueAddToRegistry
 2181              		.thumb
 2182              		.thumb_func
 2184              	vQueueAddToRegistry:
 2185              	.LFB132:
1312:lib/FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
1313:lib/FreeRTOS/queue.c **** 
1314:lib/FreeRTOS/queue.c **** #if configUSE_CO_ROUTINES == 1
1315:lib/FreeRTOS/queue.c **** signed portBASE_TYPE xQueueCRSend( xQueueHandle pxQueue, const void *pvItemToQueue, portTickType xT
1316:lib/FreeRTOS/queue.c **** {
1317:lib/FreeRTOS/queue.c **** signed portBASE_TYPE xReturn;
1318:lib/FreeRTOS/queue.c **** 
1319:lib/FreeRTOS/queue.c **** 	/* If the queue is already full we may have to block.  A critical section
1320:lib/FreeRTOS/queue.c **** 	is required to prevent an interrupt removing something from the queue
1321:lib/FreeRTOS/queue.c **** 	between the check to see if the queue is full and blocking on the queue. */
1322:lib/FreeRTOS/queue.c **** 	portDISABLE_INTERRUPTS();
1323:lib/FreeRTOS/queue.c **** 	{
1324:lib/FreeRTOS/queue.c **** 		if( prvIsQueueFull( pxQueue ) != pdFALSE )
1325:lib/FreeRTOS/queue.c **** 		{
1326:lib/FreeRTOS/queue.c **** 			/* The queue is full - do we want to block or just leave without
1327:lib/FreeRTOS/queue.c **** 			posting? */
1328:lib/FreeRTOS/queue.c **** 			if( xTicksToWait > ( portTickType ) 0 )
1329:lib/FreeRTOS/queue.c **** 			{
1330:lib/FreeRTOS/queue.c **** 				/* As this is called from a coroutine we cannot block directly, but
1331:lib/FreeRTOS/queue.c **** 				return indicating that we need to block. */
1332:lib/FreeRTOS/queue.c **** 				vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToSend ) );
1333:lib/FreeRTOS/queue.c **** 				portENABLE_INTERRUPTS();
1334:lib/FreeRTOS/queue.c **** 				return errQUEUE_BLOCKED;
1335:lib/FreeRTOS/queue.c **** 			}
1336:lib/FreeRTOS/queue.c **** 			else
1337:lib/FreeRTOS/queue.c **** 			{
1338:lib/FreeRTOS/queue.c **** 				portENABLE_INTERRUPTS();
1339:lib/FreeRTOS/queue.c **** 				return errQUEUE_FULL;
1340:lib/FreeRTOS/queue.c **** 			}
1341:lib/FreeRTOS/queue.c **** 		}
1342:lib/FreeRTOS/queue.c **** 	}
1343:lib/FreeRTOS/queue.c **** 	portENABLE_INTERRUPTS();
1344:lib/FreeRTOS/queue.c **** 
1345:lib/FreeRTOS/queue.c **** 	portNOP();
1346:lib/FreeRTOS/queue.c **** 
1347:lib/FreeRTOS/queue.c **** 	portDISABLE_INTERRUPTS();
1348:lib/FreeRTOS/queue.c **** 	{
1349:lib/FreeRTOS/queue.c **** 		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
1350:lib/FreeRTOS/queue.c **** 		{
1351:lib/FreeRTOS/queue.c **** 			/* There is room in the queue, copy the data into the queue. */
1352:lib/FreeRTOS/queue.c **** 			prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
1353:lib/FreeRTOS/queue.c **** 			xReturn = pdPASS;
1354:lib/FreeRTOS/queue.c **** 
1355:lib/FreeRTOS/queue.c **** 			/* Were any co-routines waiting for data to become available? */
1356:lib/FreeRTOS/queue.c **** 			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
1357:lib/FreeRTOS/queue.c **** 			{
1358:lib/FreeRTOS/queue.c **** 				/* In this instance the co-routine could be placed directly
1359:lib/FreeRTOS/queue.c **** 				into the ready list as we are within a critical section.
1360:lib/FreeRTOS/queue.c **** 				Instead the same pending ready list mechanism is used as if
1361:lib/FreeRTOS/queue.c **** 				the event were caused from within an interrupt. */
1362:lib/FreeRTOS/queue.c **** 				if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
1363:lib/FreeRTOS/queue.c **** 				{
1364:lib/FreeRTOS/queue.c **** 					/* The co-routine waiting has a higher priority so record
1365:lib/FreeRTOS/queue.c **** 					that a yield might be appropriate. */
1366:lib/FreeRTOS/queue.c **** 					xReturn = errQUEUE_YIELD;
1367:lib/FreeRTOS/queue.c **** 				}
1368:lib/FreeRTOS/queue.c **** 			}
1369:lib/FreeRTOS/queue.c **** 		}
1370:lib/FreeRTOS/queue.c **** 		else
1371:lib/FreeRTOS/queue.c **** 		{
1372:lib/FreeRTOS/queue.c **** 			xReturn = errQUEUE_FULL;
1373:lib/FreeRTOS/queue.c **** 		}
1374:lib/FreeRTOS/queue.c **** 	}
1375:lib/FreeRTOS/queue.c **** 	portENABLE_INTERRUPTS();
1376:lib/FreeRTOS/queue.c **** 
1377:lib/FreeRTOS/queue.c **** 	return xReturn;
1378:lib/FreeRTOS/queue.c **** }
1379:lib/FreeRTOS/queue.c **** #endif
1380:lib/FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
1381:lib/FreeRTOS/queue.c **** 
1382:lib/FreeRTOS/queue.c **** #if configUSE_CO_ROUTINES == 1
1383:lib/FreeRTOS/queue.c **** signed portBASE_TYPE xQueueCRReceive( xQueueHandle pxQueue, void *pvBuffer, portTickType xTicksToWa
1384:lib/FreeRTOS/queue.c **** {
1385:lib/FreeRTOS/queue.c **** signed portBASE_TYPE xReturn;
1386:lib/FreeRTOS/queue.c **** 
1387:lib/FreeRTOS/queue.c **** 	/* If the queue is already empty we may have to block.  A critical section
1388:lib/FreeRTOS/queue.c **** 	is required to prevent an interrupt adding something to the queue
1389:lib/FreeRTOS/queue.c **** 	between the check to see if the queue is empty and blocking on the queue. */
1390:lib/FreeRTOS/queue.c **** 	portDISABLE_INTERRUPTS();
1391:lib/FreeRTOS/queue.c **** 	{
1392:lib/FreeRTOS/queue.c **** 		if( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 )
1393:lib/FreeRTOS/queue.c **** 		{
1394:lib/FreeRTOS/queue.c **** 			/* There are no messages in the queue, do we want to block or just
1395:lib/FreeRTOS/queue.c **** 			leave with nothing? */
1396:lib/FreeRTOS/queue.c **** 			if( xTicksToWait > ( portTickType ) 0 )
1397:lib/FreeRTOS/queue.c **** 			{
1398:lib/FreeRTOS/queue.c **** 				/* As this is a co-routine we cannot block directly, but return
1399:lib/FreeRTOS/queue.c **** 				indicating that we need to block. */
1400:lib/FreeRTOS/queue.c **** 				vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToReceive ) );
1401:lib/FreeRTOS/queue.c **** 				portENABLE_INTERRUPTS();
1402:lib/FreeRTOS/queue.c **** 				return errQUEUE_BLOCKED;
1403:lib/FreeRTOS/queue.c **** 			}
1404:lib/FreeRTOS/queue.c **** 			else
1405:lib/FreeRTOS/queue.c **** 			{
1406:lib/FreeRTOS/queue.c **** 				portENABLE_INTERRUPTS();
1407:lib/FreeRTOS/queue.c **** 				return errQUEUE_FULL;
1408:lib/FreeRTOS/queue.c **** 			}
1409:lib/FreeRTOS/queue.c **** 		}
1410:lib/FreeRTOS/queue.c **** 	}
1411:lib/FreeRTOS/queue.c **** 	portENABLE_INTERRUPTS();
1412:lib/FreeRTOS/queue.c **** 
1413:lib/FreeRTOS/queue.c **** 	portNOP();
1414:lib/FreeRTOS/queue.c **** 
1415:lib/FreeRTOS/queue.c **** 	portDISABLE_INTERRUPTS();
1416:lib/FreeRTOS/queue.c **** 	{
1417:lib/FreeRTOS/queue.c **** 		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
1418:lib/FreeRTOS/queue.c **** 		{
1419:lib/FreeRTOS/queue.c **** 			/* Data is available from the queue. */
1420:lib/FreeRTOS/queue.c **** 			pxQueue->pcReadFrom += pxQueue->uxItemSize;
1421:lib/FreeRTOS/queue.c **** 			if( pxQueue->pcReadFrom >= pxQueue->pcTail )
1422:lib/FreeRTOS/queue.c **** 			{
1423:lib/FreeRTOS/queue.c **** 				pxQueue->pcReadFrom = pxQueue->pcHead;
1424:lib/FreeRTOS/queue.c **** 			}
1425:lib/FreeRTOS/queue.c **** 			--( pxQueue->uxMessagesWaiting );
1426:lib/FreeRTOS/queue.c **** 			memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
1427:lib/FreeRTOS/queue.c **** 
1428:lib/FreeRTOS/queue.c **** 			xReturn = pdPASS;
1429:lib/FreeRTOS/queue.c **** 
1430:lib/FreeRTOS/queue.c **** 			/* Were any co-routines waiting for space to become available? */
1431:lib/FreeRTOS/queue.c **** 			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
1432:lib/FreeRTOS/queue.c **** 			{
1433:lib/FreeRTOS/queue.c **** 				/* In this instance the co-routine could be placed directly
1434:lib/FreeRTOS/queue.c **** 				into the ready list as we are within a critical section.
1435:lib/FreeRTOS/queue.c **** 				Instead the same pending ready list mechanism is used as if
1436:lib/FreeRTOS/queue.c **** 				the event were caused from within an interrupt. */
1437:lib/FreeRTOS/queue.c **** 				if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
1438:lib/FreeRTOS/queue.c **** 				{
1439:lib/FreeRTOS/queue.c **** 					xReturn = errQUEUE_YIELD;
1440:lib/FreeRTOS/queue.c **** 				}
1441:lib/FreeRTOS/queue.c **** 			}
1442:lib/FreeRTOS/queue.c **** 		}
1443:lib/FreeRTOS/queue.c **** 		else
1444:lib/FreeRTOS/queue.c **** 		{
1445:lib/FreeRTOS/queue.c **** 			xReturn = pdFAIL;
1446:lib/FreeRTOS/queue.c **** 		}
1447:lib/FreeRTOS/queue.c **** 	}
1448:lib/FreeRTOS/queue.c **** 	portENABLE_INTERRUPTS();
1449:lib/FreeRTOS/queue.c **** 
1450:lib/FreeRTOS/queue.c **** 	return xReturn;
1451:lib/FreeRTOS/queue.c **** }
1452:lib/FreeRTOS/queue.c **** #endif
1453:lib/FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
1454:lib/FreeRTOS/queue.c **** 
1455:lib/FreeRTOS/queue.c **** 
1456:lib/FreeRTOS/queue.c **** 
1457:lib/FreeRTOS/queue.c **** #if configUSE_CO_ROUTINES == 1
1458:lib/FreeRTOS/queue.c **** signed portBASE_TYPE xQueueCRSendFromISR( xQueueHandle pxQueue, const void *pvItemToQueue, signed p
1459:lib/FreeRTOS/queue.c **** {
1460:lib/FreeRTOS/queue.c **** 	/* Cannot block within an ISR so if there is no space on the queue then
1461:lib/FreeRTOS/queue.c **** 	exit without doing anything. */
1462:lib/FreeRTOS/queue.c **** 	if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
1463:lib/FreeRTOS/queue.c **** 	{
1464:lib/FreeRTOS/queue.c **** 		prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
1465:lib/FreeRTOS/queue.c **** 
1466:lib/FreeRTOS/queue.c **** 		/* We only want to wake one co-routine per ISR, so check that a
1467:lib/FreeRTOS/queue.c **** 		co-routine has not already been woken. */
1468:lib/FreeRTOS/queue.c **** 		if( xCoRoutinePreviouslyWoken == pdFALSE )
1469:lib/FreeRTOS/queue.c **** 		{
1470:lib/FreeRTOS/queue.c **** 			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
1471:lib/FreeRTOS/queue.c **** 			{
1472:lib/FreeRTOS/queue.c **** 				if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
1473:lib/FreeRTOS/queue.c **** 				{
1474:lib/FreeRTOS/queue.c **** 					return pdTRUE;
1475:lib/FreeRTOS/queue.c **** 				}
1476:lib/FreeRTOS/queue.c **** 			}
1477:lib/FreeRTOS/queue.c **** 		}
1478:lib/FreeRTOS/queue.c **** 	}
1479:lib/FreeRTOS/queue.c **** 
1480:lib/FreeRTOS/queue.c **** 	return xCoRoutinePreviouslyWoken;
1481:lib/FreeRTOS/queue.c **** }
1482:lib/FreeRTOS/queue.c **** #endif
1483:lib/FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
1484:lib/FreeRTOS/queue.c **** 
1485:lib/FreeRTOS/queue.c **** #if configUSE_CO_ROUTINES == 1
1486:lib/FreeRTOS/queue.c **** signed portBASE_TYPE xQueueCRReceiveFromISR( xQueueHandle pxQueue, void *pvBuffer, signed portBASE_
1487:lib/FreeRTOS/queue.c **** {
1488:lib/FreeRTOS/queue.c **** signed portBASE_TYPE xReturn;
1489:lib/FreeRTOS/queue.c **** 
1490:lib/FreeRTOS/queue.c **** 	/* We cannot block from an ISR, so check there is data available. If
1491:lib/FreeRTOS/queue.c **** 	not then just leave without doing anything. */
1492:lib/FreeRTOS/queue.c **** 	if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
1493:lib/FreeRTOS/queue.c **** 	{
1494:lib/FreeRTOS/queue.c **** 		/* Copy the data from the queue. */
1495:lib/FreeRTOS/queue.c **** 		pxQueue->pcReadFrom += pxQueue->uxItemSize;
1496:lib/FreeRTOS/queue.c **** 		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
1497:lib/FreeRTOS/queue.c **** 		{
1498:lib/FreeRTOS/queue.c **** 			pxQueue->pcReadFrom = pxQueue->pcHead;
1499:lib/FreeRTOS/queue.c **** 		}
1500:lib/FreeRTOS/queue.c **** 		--( pxQueue->uxMessagesWaiting );
1501:lib/FreeRTOS/queue.c **** 		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
1502:lib/FreeRTOS/queue.c **** 
1503:lib/FreeRTOS/queue.c **** 		if( ( *pxCoRoutineWoken ) == pdFALSE )
1504:lib/FreeRTOS/queue.c **** 		{
1505:lib/FreeRTOS/queue.c **** 			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
1506:lib/FreeRTOS/queue.c **** 			{
1507:lib/FreeRTOS/queue.c **** 				if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
1508:lib/FreeRTOS/queue.c **** 				{
1509:lib/FreeRTOS/queue.c **** 					*pxCoRoutineWoken = pdTRUE;
1510:lib/FreeRTOS/queue.c **** 				}
1511:lib/FreeRTOS/queue.c **** 			}
1512:lib/FreeRTOS/queue.c **** 		}
1513:lib/FreeRTOS/queue.c **** 
1514:lib/FreeRTOS/queue.c **** 		xReturn = pdPASS;
1515:lib/FreeRTOS/queue.c **** 	}
1516:lib/FreeRTOS/queue.c **** 	else
1517:lib/FreeRTOS/queue.c **** 	{
1518:lib/FreeRTOS/queue.c **** 		xReturn = pdFAIL;
1519:lib/FreeRTOS/queue.c **** 	}
1520:lib/FreeRTOS/queue.c **** 
1521:lib/FreeRTOS/queue.c **** 	return xReturn;
1522:lib/FreeRTOS/queue.c **** }
1523:lib/FreeRTOS/queue.c **** #endif
1524:lib/FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
1525:lib/FreeRTOS/queue.c **** 
1526:lib/FreeRTOS/queue.c **** #if configQUEUE_REGISTRY_SIZE > 0
1527:lib/FreeRTOS/queue.c **** 
1528:lib/FreeRTOS/queue.c **** 	void vQueueAddToRegistry( xQueueHandle xQueue, signed char *pcQueueName )
1529:lib/FreeRTOS/queue.c **** 	{
 2186              		.loc 1 1529 0
 2187              		.cfi_startproc
 2188              		@ args = 0, pretend = 0, frame = 16
 2189              		@ frame_needed = 1, uses_anonymous_args = 0
 2190              		@ link register save eliminated.
 2191 0000 80B4     		push	{r7}
 2192              	.LCFI66:
 2193              		.cfi_def_cfa_offset 4
 2194 0002 85B0     		sub	sp, sp, #20
 2195              	.LCFI67:
 2196              		.cfi_def_cfa_offset 24
 2197 0004 00AF     		add	r7, sp, #0
 2198              		.cfi_offset 7, -4
 2199              	.LCFI68:
 2200              		.cfi_def_cfa_register 7
 2201 0006 7860     		str	r0, [r7, #4]
 2202 0008 3960     		str	r1, [r7, #0]
1530:lib/FreeRTOS/queue.c **** 	unsigned portBASE_TYPE ux;
1531:lib/FreeRTOS/queue.c **** 
1532:lib/FreeRTOS/queue.c **** 		/* See if there is an empty space in the registry.  A NULL name denotes
1533:lib/FreeRTOS/queue.c **** 		a free slot. */
1534:lib/FreeRTOS/queue.c **** 		for( ux = ( unsigned portBASE_TYPE ) 0U; ux < ( unsigned portBASE_TYPE ) configQUEUE_REGISTRY_SIZ
 2203              		.loc 1 1534 0
 2204 000a 4FF00003 		mov	r3, #0
 2205 000e FB60     		str	r3, [r7, #12]
 2206 0010 16E0     		b	.L135
 2207              	.L138:
1535:lib/FreeRTOS/queue.c **** 		{
1536:lib/FreeRTOS/queue.c **** 			if( xQueueRegistry[ ux ].pcQueueName == NULL )
 2208              		.loc 1 1536 0
 2209 0012 0F4B     		ldr	r3, .L139
 2210 0014 FA68     		ldr	r2, [r7, #12]
 2211 0016 53F83230 		ldr	r3, [r3, r2, lsl #3]
 2212 001a 002B     		cmp	r3, #0
 2213 001c 0CD1     		bne	.L136
1537:lib/FreeRTOS/queue.c **** 			{
1538:lib/FreeRTOS/queue.c **** 				/* Store the information on this queue. */
1539:lib/FreeRTOS/queue.c **** 				xQueueRegistry[ ux ].pcQueueName = pcQueueName;
 2214              		.loc 1 1539 0
 2215 001e 0C4B     		ldr	r3, .L139
 2216 0020 FA68     		ldr	r2, [r7, #12]
 2217 0022 3968     		ldr	r1, [r7, #0]
 2218 0024 43F83210 		str	r1, [r3, r2, lsl #3]
1540:lib/FreeRTOS/queue.c **** 				xQueueRegistry[ ux ].xHandle = xQueue;
 2219              		.loc 1 1540 0
 2220 0028 094A     		ldr	r2, .L139
 2221 002a FB68     		ldr	r3, [r7, #12]
 2222 002c 4FEAC303 		lsl	r3, r3, #3
 2223 0030 D318     		adds	r3, r2, r3
 2224 0032 7A68     		ldr	r2, [r7, #4]
 2225 0034 5A60     		str	r2, [r3, #4]
1541:lib/FreeRTOS/queue.c **** 				break;
 2226              		.loc 1 1541 0
 2227 0036 06E0     		b	.L134
 2228              	.L136:
1534:lib/FreeRTOS/queue.c **** 		for( ux = ( unsigned portBASE_TYPE ) 0U; ux < ( unsigned portBASE_TYPE ) configQUEUE_REGISTRY_SIZ
 2229              		.loc 1 1534 0
 2230 0038 FB68     		ldr	r3, [r7, #12]
 2231 003a 03F10103 		add	r3, r3, #1
 2232 003e FB60     		str	r3, [r7, #12]
 2233              	.L135:
1534:lib/FreeRTOS/queue.c **** 		for( ux = ( unsigned portBASE_TYPE ) 0U; ux < ( unsigned portBASE_TYPE ) configQUEUE_REGISTRY_SIZ
 2234              		.loc 1 1534 0 is_stmt 0 discriminator 1
 2235 0040 FB68     		ldr	r3, [r7, #12]
 2236 0042 072B     		cmp	r3, #7
 2237 0044 E5D9     		bls	.L138
 2238              	.L134:
1542:lib/FreeRTOS/queue.c **** 			}
1543:lib/FreeRTOS/queue.c **** 		}
1544:lib/FreeRTOS/queue.c **** 	}
 2239              		.loc 1 1544 0 is_stmt 1
 2240 0046 07F11407 		add	r7, r7, #20
 2241 004a BD46     		mov	sp, r7
 2242 004c 80BC     		pop	{r7}
 2243 004e 7047     		bx	lr
 2244              	.L140:
 2245              		.align	2
 2246              	.L139:
 2247 0050 00000000 		.word	xQueueRegistry
 2248              		.cfi_endproc
 2249              	.LFE132:
 2251              		.section	.text.vQueueUnregisterQueue,"ax",%progbits
 2252              		.align	2
 2253              		.thumb
 2254              		.thumb_func
 2256              	vQueueUnregisterQueue:
 2257              	.LFB133:
1545:lib/FreeRTOS/queue.c **** 
1546:lib/FreeRTOS/queue.c **** #endif
1547:lib/FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
1548:lib/FreeRTOS/queue.c **** 
1549:lib/FreeRTOS/queue.c **** #if configQUEUE_REGISTRY_SIZE > 0
1550:lib/FreeRTOS/queue.c **** 
1551:lib/FreeRTOS/queue.c **** 	static void vQueueUnregisterQueue( xQueueHandle xQueue )
1552:lib/FreeRTOS/queue.c **** 	{
 2258              		.loc 1 1552 0
 2259              		.cfi_startproc
 2260              		@ args = 0, pretend = 0, frame = 16
 2261              		@ frame_needed = 1, uses_anonymous_args = 0
 2262              		@ link register save eliminated.
 2263 0000 80B4     		push	{r7}
 2264              	.LCFI69:
 2265              		.cfi_def_cfa_offset 4
 2266 0002 85B0     		sub	sp, sp, #20
 2267              	.LCFI70:
 2268              		.cfi_def_cfa_offset 24
 2269 0004 00AF     		add	r7, sp, #0
 2270              		.cfi_offset 7, -4
 2271              	.LCFI71:
 2272              		.cfi_def_cfa_register 7
 2273 0006 7860     		str	r0, [r7, #4]
1553:lib/FreeRTOS/queue.c **** 	unsigned portBASE_TYPE ux;
1554:lib/FreeRTOS/queue.c **** 
1555:lib/FreeRTOS/queue.c **** 		/* See if the handle of the queue being unregistered in actually in the
1556:lib/FreeRTOS/queue.c **** 		registry. */
1557:lib/FreeRTOS/queue.c **** 		for( ux = ( unsigned portBASE_TYPE ) 0U; ux < ( unsigned portBASE_TYPE ) configQUEUE_REGISTRY_SIZ
 2274              		.loc 1 1557 0
 2275 0008 4FF00003 		mov	r3, #0
 2276 000c FB60     		str	r3, [r7, #12]
 2277 000e 13E0     		b	.L142
 2278              	.L145:
1558:lib/FreeRTOS/queue.c **** 		{
1559:lib/FreeRTOS/queue.c **** 			if( xQueueRegistry[ ux ].xHandle == xQueue )
 2279              		.loc 1 1559 0
 2280 0010 0D4A     		ldr	r2, .L146
 2281 0012 FB68     		ldr	r3, [r7, #12]
 2282 0014 4FEAC303 		lsl	r3, r3, #3
 2283 0018 D318     		adds	r3, r2, r3
 2284 001a 5A68     		ldr	r2, [r3, #4]
 2285 001c 7B68     		ldr	r3, [r7, #4]
 2286 001e 9A42     		cmp	r2, r3
 2287 0020 06D1     		bne	.L143
1560:lib/FreeRTOS/queue.c **** 			{
1561:lib/FreeRTOS/queue.c **** 				/* Set the name to NULL to show that this slot if free again. */
1562:lib/FreeRTOS/queue.c **** 				xQueueRegistry[ ux ].pcQueueName = NULL;
 2288              		.loc 1 1562 0
 2289 0022 094B     		ldr	r3, .L146
 2290 0024 FA68     		ldr	r2, [r7, #12]
 2291 0026 4FF00001 		mov	r1, #0
 2292 002a 43F83210 		str	r1, [r3, r2, lsl #3]
1563:lib/FreeRTOS/queue.c **** 				break;
 2293              		.loc 1 1563 0
 2294 002e 06E0     		b	.L141
 2295              	.L143:
1557:lib/FreeRTOS/queue.c **** 		for( ux = ( unsigned portBASE_TYPE ) 0U; ux < ( unsigned portBASE_TYPE ) configQUEUE_REGISTRY_SIZ
 2296              		.loc 1 1557 0
 2297 0030 FB68     		ldr	r3, [r7, #12]
 2298 0032 03F10103 		add	r3, r3, #1
 2299 0036 FB60     		str	r3, [r7, #12]
 2300              	.L142:
1557:lib/FreeRTOS/queue.c **** 		for( ux = ( unsigned portBASE_TYPE ) 0U; ux < ( unsigned portBASE_TYPE ) configQUEUE_REGISTRY_SIZ
 2301              		.loc 1 1557 0 is_stmt 0 discriminator 1
 2302 0038 FB68     		ldr	r3, [r7, #12]
 2303 003a 072B     		cmp	r3, #7
 2304 003c E8D9     		bls	.L145
 2305              	.L141:
1564:lib/FreeRTOS/queue.c **** 			}
1565:lib/FreeRTOS/queue.c **** 		}
1566:lib/FreeRTOS/queue.c **** 
1567:lib/FreeRTOS/queue.c **** 	}
 2306              		.loc 1 1567 0 is_stmt 1
 2307 003e 07F11407 		add	r7, r7, #20
 2308 0042 BD46     		mov	sp, r7
 2309 0044 80BC     		pop	{r7}
 2310 0046 7047     		bx	lr
 2311              	.L147:
 2312              		.align	2
 2313              	.L146:
 2314 0048 00000000 		.word	xQueueRegistry
 2315              		.cfi_endproc
 2316              	.LFE133:
 2318              		.section	.text.vQueueWaitForMessageRestricted,"ax",%progbits
 2319              		.align	2
 2320              		.global	vQueueWaitForMessageRestricted
 2321              		.thumb
 2322              		.thumb_func
 2324              	vQueueWaitForMessageRestricted:
 2325              	.LFB134:
1568:lib/FreeRTOS/queue.c **** 
1569:lib/FreeRTOS/queue.c **** #endif
1570:lib/FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
1571:lib/FreeRTOS/queue.c **** 
1572:lib/FreeRTOS/queue.c **** #if configUSE_TIMERS == 1
1573:lib/FreeRTOS/queue.c **** 
1574:lib/FreeRTOS/queue.c **** 	void vQueueWaitForMessageRestricted( xQueueHandle pxQueue, portTickType xTicksToWait )
1575:lib/FreeRTOS/queue.c **** 	{
 2326              		.loc 1 1575 0
 2327              		.cfi_startproc
 2328              		@ args = 0, pretend = 0, frame = 8
 2329              		@ frame_needed = 1, uses_anonymous_args = 0
 2330 0000 80B5     		push	{r7, lr}
 2331              	.LCFI72:
 2332              		.cfi_def_cfa_offset 8
 2333 0002 82B0     		sub	sp, sp, #8
 2334              	.LCFI73:
 2335              		.cfi_def_cfa_offset 16
 2336 0004 00AF     		add	r7, sp, #0
 2337              		.cfi_offset 14, -4
 2338              		.cfi_offset 7, -8
 2339              	.LCFI74:
 2340              		.cfi_def_cfa_register 7
 2341 0006 7860     		str	r0, [r7, #4]
 2342 0008 3960     		str	r1, [r7, #0]
1576:lib/FreeRTOS/queue.c **** 		/* This function should not be called by application code hence the
1577:lib/FreeRTOS/queue.c **** 		'Restricted' in its name.  It is not part of the public API.  It is
1578:lib/FreeRTOS/queue.c **** 		designed for use by kernel code, and has special calling requirements.
1579:lib/FreeRTOS/queue.c **** 		It can result in vListInsert() being called on a list that can only
1580:lib/FreeRTOS/queue.c **** 		possibly ever have one item in it, so the list will be fast, but even
1581:lib/FreeRTOS/queue.c **** 		so it should be called with the scheduler locked and not from a critical
1582:lib/FreeRTOS/queue.c **** 		section. */
1583:lib/FreeRTOS/queue.c **** 
1584:lib/FreeRTOS/queue.c **** 		/* Only do anything if there are no messages in the queue.  This function
1585:lib/FreeRTOS/queue.c **** 		will not actually cause the task to block, just place it on a blocked
1586:lib/FreeRTOS/queue.c **** 		list.  It will not block until the scheduler is unlocked - at which
1587:lib/FreeRTOS/queue.c **** 		time a yield will be performed.  If an item is added to the queue while
1588:lib/FreeRTOS/queue.c **** 		the queue is locked, and the calling task blocks on the queue, then the
1589:lib/FreeRTOS/queue.c **** 		calling task will be immediately unblocked when the queue is unlocked. */
1590:lib/FreeRTOS/queue.c **** 		prvLockQueue( pxQueue );
 2343              		.loc 1 1590 0
 2344 000a FFF7FEFF 		bl	vPortEnterCritical
 2345 000e 7B68     		ldr	r3, [r7, #4]
 2346 0010 5B6C     		ldr	r3, [r3, #68]
 2347 0012 B3F1FF3F 		cmp	r3, #-1
 2348 0016 03D1     		bne	.L149
 2349              		.loc 1 1590 0 is_stmt 0 discriminator 1
 2350 0018 7B68     		ldr	r3, [r7, #4]
 2351 001a 4FF00002 		mov	r2, #0
 2352 001e 5A64     		str	r2, [r3, #68]
 2353              	.L149:
 2354              		.loc 1 1590 0 discriminator 2
 2355 0020 7B68     		ldr	r3, [r7, #4]
 2356 0022 9B6C     		ldr	r3, [r3, #72]
 2357 0024 B3F1FF3F 		cmp	r3, #-1
 2358 0028 03D1     		bne	.L150
 2359              		.loc 1 1590 0 discriminator 3
 2360 002a 7B68     		ldr	r3, [r7, #4]
 2361 002c 4FF00002 		mov	r2, #0
 2362 0030 9A64     		str	r2, [r3, #72]
 2363              	.L150:
 2364              		.loc 1 1590 0 discriminator 4
 2365 0032 FFF7FEFF 		bl	vPortExitCritical
1591:lib/FreeRTOS/queue.c **** 		if( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0U )
 2366              		.loc 1 1591 0 is_stmt 1 discriminator 4
 2367 0036 7B68     		ldr	r3, [r7, #4]
 2368 0038 9B6B     		ldr	r3, [r3, #56]
 2369 003a 002B     		cmp	r3, #0
 2370 003c 06D1     		bne	.L151
1592:lib/FreeRTOS/queue.c **** 		{
1593:lib/FreeRTOS/queue.c **** 			/* There is nothing in the queue, block for the specified period. */
1594:lib/FreeRTOS/queue.c **** 			vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 2371              		.loc 1 1594 0
 2372 003e 7B68     		ldr	r3, [r7, #4]
 2373 0040 03F12403 		add	r3, r3, #36
 2374 0044 1846     		mov	r0, r3
 2375 0046 3968     		ldr	r1, [r7, #0]
 2376 0048 FFF7FEFF 		bl	vTaskPlaceOnEventListRestricted
 2377              	.L151:
1595:lib/FreeRTOS/queue.c **** 		}
1596:lib/FreeRTOS/queue.c **** 		prvUnlockQueue( pxQueue );
 2378              		.loc 1 1596 0
 2379 004c 7868     		ldr	r0, [r7, #4]
 2380 004e FFF7FEFF 		bl	prvUnlockQueue
1597:lib/FreeRTOS/queue.c **** 	}
 2381              		.loc 1 1597 0
 2382 0052 07F10807 		add	r7, r7, #8
 2383 0056 BD46     		mov	sp, r7
 2384 0058 80BD     		pop	{r7, pc}
 2385              		.cfi_endproc
 2386              	.LFE134:
 2388 005a 00BF     		.text
 2389              	.Letext0:
DEFINED SYMBOLS
                            *ABS*:00000000 queue.c
C:\Users\junpei\AppData\Local\Temp\ccxs5P2H.s:29     .bss.xQueueRegistry:00000000 xQueueRegistry
C:\Users\junpei\AppData\Local\Temp\ccxs5P2H.s:26     .bss.xQueueRegistry:00000000 $d
C:\Users\junpei\AppData\Local\Temp\ccxs5P2H.s:32     .text.xQueueGenericCreate:00000000 $t
C:\Users\junpei\AppData\Local\Temp\ccxs5P2H.s:37     .text.xQueueGenericCreate:00000000 xQueueGenericCreate
C:\Users\junpei\AppData\Local\Temp\ccxs5P2H.s:186    .text.xQueueCreateMutex:00000000 $t
C:\Users\junpei\AppData\Local\Temp\ccxs5P2H.s:191    .text.xQueueCreateMutex:00000000 xQueueCreateMutex
C:\Users\junpei\AppData\Local\Temp\ccxs5P2H.s:543    .text.xQueueGenericSend:00000000 xQueueGenericSend
C:\Users\junpei\AppData\Local\Temp\ccxs5P2H.s:302    .text.xQueueGiveMutexRecursive:00000000 $t
C:\Users\junpei\AppData\Local\Temp\ccxs5P2H.s:307    .text.xQueueGiveMutexRecursive:00000000 xQueueGiveMutexRecursive
C:\Users\junpei\AppData\Local\Temp\ccxs5P2H.s:386    .text.xQueueTakeMutexRecursive:00000000 $t
C:\Users\junpei\AppData\Local\Temp\ccxs5P2H.s:391    .text.xQueueTakeMutexRecursive:00000000 xQueueTakeMutexRecursive
C:\Users\junpei\AppData\Local\Temp\ccxs5P2H.s:932    .text.xQueueGenericReceive:00000000 xQueueGenericReceive
C:\Users\junpei\AppData\Local\Temp\ccxs5P2H.s:473    .text.xQueueCreateCountingSemaphore:00000000 $t
C:\Users\junpei\AppData\Local\Temp\ccxs5P2H.s:478    .text.xQueueCreateCountingSemaphore:00000000 xQueueCreateCountingSemaphore
C:\Users\junpei\AppData\Local\Temp\ccxs5P2H.s:538    .text.xQueueGenericSend:00000000 $t
C:\Users\junpei\AppData\Local\Temp\ccxs5P2H.s:1659   .text.prvCopyDataToQueue:00000000 prvCopyDataToQueue
C:\Users\junpei\AppData\Local\Temp\ccxs5P2H.s:2076   .text.prvIsQueueFull:00000000 prvIsQueueFull
C:\Users\junpei\AppData\Local\Temp\ccxs5P2H.s:1855   .text.prvUnlockQueue:00000000 prvUnlockQueue
C:\Users\junpei\AppData\Local\Temp\ccxs5P2H.s:761    .text.xQueueGenericSendFromISR:00000000 $t
C:\Users\junpei\AppData\Local\Temp\ccxs5P2H.s:766    .text.xQueueGenericSendFromISR:00000000 xQueueGenericSendFromISR
C:\Users\junpei\AppData\Local\Temp\ccxs5P2H.s:927    .text.xQueueGenericReceive:00000000 $t
C:\Users\junpei\AppData\Local\Temp\ccxs5P2H.s:1788   .text.prvCopyDataFromQueue:00000000 prvCopyDataFromQueue
C:\Users\junpei\AppData\Local\Temp\ccxs5P2H.s:1973   .text.prvIsQueueEmpty:00000000 prvIsQueueEmpty
C:\Users\junpei\AppData\Local\Temp\ccxs5P2H.s:1209   .text.xQueueReceiveFromISR:00000000 $t
C:\Users\junpei\AppData\Local\Temp\ccxs5P2H.s:1214   .text.xQueueReceiveFromISR:00000000 xQueueReceiveFromISR
C:\Users\junpei\AppData\Local\Temp\ccxs5P2H.s:1377   .text.uxQueueMessagesWaiting:00000000 $t
C:\Users\junpei\AppData\Local\Temp\ccxs5P2H.s:1382   .text.uxQueueMessagesWaiting:00000000 uxQueueMessagesWaiting
C:\Users\junpei\AppData\Local\Temp\ccxs5P2H.s:1434   .text.uxQueueMessagesWaitingFromISR:00000000 $t
C:\Users\junpei\AppData\Local\Temp\ccxs5P2H.s:1439   .text.uxQueueMessagesWaitingFromISR:00000000 uxQueueMessagesWaitingFromISR
C:\Users\junpei\AppData\Local\Temp\ccxs5P2H.s:1488   .text.vQueueDelete:00000000 $t
C:\Users\junpei\AppData\Local\Temp\ccxs5P2H.s:1493   .text.vQueueDelete:00000000 vQueueDelete
C:\Users\junpei\AppData\Local\Temp\ccxs5P2H.s:2256   .text.vQueueUnregisterQueue:00000000 vQueueUnregisterQueue
C:\Users\junpei\AppData\Local\Temp\ccxs5P2H.s:1545   .text.ucQueueGetQueueNumber:00000000 $t
C:\Users\junpei\AppData\Local\Temp\ccxs5P2H.s:1550   .text.ucQueueGetQueueNumber:00000000 ucQueueGetQueueNumber
C:\Users\junpei\AppData\Local\Temp\ccxs5P2H.s:1581   .text.vQueueSetQueueNumber:00000000 $t
C:\Users\junpei\AppData\Local\Temp\ccxs5P2H.s:1586   .text.vQueueSetQueueNumber:00000000 vQueueSetQueueNumber
C:\Users\junpei\AppData\Local\Temp\ccxs5P2H.s:1619   .text.ucQueueGetQueueType:00000000 $t
C:\Users\junpei\AppData\Local\Temp\ccxs5P2H.s:1624   .text.ucQueueGetQueueType:00000000 ucQueueGetQueueType
C:\Users\junpei\AppData\Local\Temp\ccxs5P2H.s:1655   .text.prvCopyDataToQueue:00000000 $t
C:\Users\junpei\AppData\Local\Temp\ccxs5P2H.s:1784   .text.prvCopyDataFromQueue:00000000 $t
C:\Users\junpei\AppData\Local\Temp\ccxs5P2H.s:1851   .text.prvUnlockQueue:00000000 $t
C:\Users\junpei\AppData\Local\Temp\ccxs5P2H.s:1969   .text.prvIsQueueEmpty:00000000 $t
C:\Users\junpei\AppData\Local\Temp\ccxs5P2H.s:2014   .text.xQueueIsQueueEmptyFromISR:00000000 $t
C:\Users\junpei\AppData\Local\Temp\ccxs5P2H.s:2019   .text.xQueueIsQueueEmptyFromISR:00000000 xQueueIsQueueEmptyFromISR
C:\Users\junpei\AppData\Local\Temp\ccxs5P2H.s:2072   .text.prvIsQueueFull:00000000 $t
C:\Users\junpei\AppData\Local\Temp\ccxs5P2H.s:2119   .text.xQueueIsQueueFullFromISR:00000000 $t
C:\Users\junpei\AppData\Local\Temp\ccxs5P2H.s:2124   .text.xQueueIsQueueFullFromISR:00000000 xQueueIsQueueFullFromISR
C:\Users\junpei\AppData\Local\Temp\ccxs5P2H.s:2179   .text.vQueueAddToRegistry:00000000 $t
C:\Users\junpei\AppData\Local\Temp\ccxs5P2H.s:2184   .text.vQueueAddToRegistry:00000000 vQueueAddToRegistry
C:\Users\junpei\AppData\Local\Temp\ccxs5P2H.s:2247   .text.vQueueAddToRegistry:00000050 $d
C:\Users\junpei\AppData\Local\Temp\ccxs5P2H.s:2252   .text.vQueueUnregisterQueue:00000000 $t
C:\Users\junpei\AppData\Local\Temp\ccxs5P2H.s:2314   .text.vQueueUnregisterQueue:00000048 $d
C:\Users\junpei\AppData\Local\Temp\ccxs5P2H.s:2319   .text.vQueueWaitForMessageRestricted:00000000 $t
C:\Users\junpei\AppData\Local\Temp\ccxs5P2H.s:2324   .text.vQueueWaitForMessageRestricted:00000000 vQueueWaitForMessageRestricted
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
pvPortMalloc
vListInitialise
vPortFree
xTaskGetCurrentTaskHandle
vPortEnterCritical
xTaskRemoveFromEventList
vPortYieldFromISR
vPortExitCritical
vTaskSetTimeOutState
vTaskSuspendAll
xTaskCheckForTimeOut
vTaskPlaceOnEventList
xTaskResumeAll
vTaskPriorityInherit
vTaskPriorityDisinherit
memcpy
vTaskMissedYield
vTaskPlaceOnEventListRestricted
